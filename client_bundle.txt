--- .env ---

# Firebase Configuration (для локальной разработки)
VITE_FIREBASE_API_KEY=demo-key
VITE_FIREBASE_AUTH_DOMAIN=progress-quest-universal.firebaseapp.com
VITE_FIREBASE_PROJECT_ID=progress-quest-universal
VITE_FIREBASE_STORAGE_BUCKET=progress-quest-universal.appspot.com
VITE_FIREBASE_MESSAGING_SENDER_ID=123456789
VITE_FIREBASE_APP_ID=1:123456789:web:demo

# Application Configuration
VITE_APP_NAME=ProgressQuest Universal
VITE_APP_VERSION=1.0.0
VITE_APP_ENVIRONMENT=development

# Emulator Configuration
VITE_USE_FIREBASE_EMULATORS=true

# Feature Flags
VITE_ENABLE_ANALYTICS=false
VITE_ENABLE_NOTIFICATIONS=true
VITE_ENABLE_GARDEN=true
VITE_ENABLE_COLLABORATION=true


--- .env.example ---

# Firebase Configuration
VITE_FIREBASE_API_KEY=your_api_key_here
VITE_FIREBASE_AUTH_DOMAIN=your_project.firebaseapp.com
VITE_FIREBASE_PROJECT_ID=your_project_id
VITE_FIREBASE_STORAGE_BUCKET=your_project.appspot.com
VITE_FIREBASE_MESSAGING_SENDER_ID=123456789
VITE_FIREBASE_APP_ID=1:123456789:web:abcdefghijklmnop

# Application Configuration
VITE_APP_NAME=ProgressQuest Universal
VITE_APP_VERSION=1.0.0
VITE_APP_ENVIRONMENT=production

# API Configuration
VITE_API_BASE_URL=https://api.progressquest.com
VITE_API_TIMEOUT=30000

# Analytics
VITE_GOOGLE_ANALYTICS_ID=G-XXXXXXXXXX

# Feature Flags
VITE_ENABLE_ANALYTICS=true
VITE_ENABLE_NOTIFICATIONS=true
VITE_ENABLE_GARDEN=true
VITE_ENABLE_COLLABORATION=true

# External Services
VITE_SUPPORT_EMAIL=support@progressquest.com
VITE_FEEDBACK_URL=https://feedback.progressquest.com


--- .env.local ---

VITE_FIREBASE_API_KEY=AIzaSyCYXSYFEKHWbfQiVypZoWQK05hamae_Q0g
VITE_FIREBASE_AUTH_DOMAIN=progress-quest-universal.firebaseapp.com
VITE_FIREBASE_PROJECT_ID=progress-quest-universal
VITE_FIREBASE_STORAGE_BUCKET=progress-quest-universal.appspot.com
VITE_FIREBASE_MESSAGING_SENDER_ID=1039559255344
VITE_FIREBASE_APP_ID=1:1039559255344:web:dd296d7ea524be2f8554f5
VITE_FIREBASE_MEASUREMENT_ID=G-JLFRTXVRXR

# ==================================
# Application Configuration
# ==================================
VITE_APP_NAME=ProgressQuest Universal
VITE_APP_VERSION=1.0.0
VITE_APP_ENVIRONMENT=development

# ==================================
# API Configuration (может понадобиться для Cloud Functions)
# ==================================
# Если вы используете Cloud Functions, укажите здесь регион
VITE_FIREBASE_FUNCTIONS_REGION=europe-west1

# ==================================
# Feature Flags (управление фичами)
# ==================================
VITE_ENABLE_ANALYTICS=true
VITE_ENABLE_NOTIFICATIONS=true
VITE_ENABLE_GARDEN=true
VITE_ENABLE_COLLABORATION=true

# ==================================
# Development Settings
# ==================================
# Enable Firebase Emulators for Development
VITE_USE_FIREBASE_EMULATORS=true

# ==================================
# External Services
# ==================================
VITE_SUPPORT_EMAIL=support@progressquest.com
VITE_FEEDBACK_URL=https://feedback.progressquest.com


--- .eslintrc.cjs ---

module.exports = {
  root: true,
  env: { browser: true, es2020: true },
  extends: [
    'eslint:recommended',
    '@typescript-eslint/recommended',
    'plugin:react-hooks/recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:react/recommended',
  ],
  ignorePatterns: ['dist', '.eslintrc.cjs'],
  parser: '@typescript-eslint/parser',
  plugins: ['react-refresh', '@typescript-eslint', 'react'],
  settings: {
    react: {
      version: 'detect',
    },
  },
  rules: {
    'react-refresh/only-export-components': [
      'warn',
      { allowConstantExport: true },
    ],
    'react/react-in-jsx-scope': 'off',
    '@typescript-eslint/no-unused-vars': ['error', { argsIgnorePattern: '^_' }],
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'warn',
    'prefer-const': 'error',
    'no-var': 'error',
  },
}


--- .gitignore ---

# Created by https://www.toptal.com/developers/gitignore/api/react,typescript,vite,firebase,visualstudiocode,node
# Edit at https://www.toptal.com/developers/gitignore?templates=react,typescript,vite,firebase,visualstudiocode,node

### Firebase ###
# Firebase Emulator Data
.firebase/emulators/
*.emulators.log

# Firebase Crashlytics
*.dSYM/
*.firebase/

# Firebase Hosting
.firebase/hosting.*.cache

# Firebase Test Lab
test-lab-results.json

### Node ###
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-temporary-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/
web_modules/

# Snowpack dependency directory (https://www.snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build output
.nuxt
dist

# Docusaurus build output
.docusaurus

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores files
.changeset

# Lockfiles
package-lock.json
yarn.lock
pnpm-lock.yaml

### React ###
build/
.DS_Store
*.js.map
*.css.map
coverage/

### TypeScript ###
# TypeScript v1 declaration files
typings/

# TypeScript cache
*.tsbuildinfo

#ts-jest cache
.ts-jest

# Typescript v2.0 temporary folder
.tscache/

### Vite ###
# Vite build output
dist

# Vite cache
.vite

### VisualStudioCode ###
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
*.code-workspace

# Local History for Visual Studio Code
.history/

# END https://www.toptal.com/developers/gitignore/api/react,typescript,vite,firebase,visualstudiocode,node
merged_ts_files.txt


--- bundle_client_files.py ---

import os

def bundle_files(start_path, output_file):
    ignore_dirs = ['node_modules', 'dist', 'build', 'coverage', '.git', '.vscode', '__pycache__']
    ignore_files = ['package-lock.json', os.path.basename(output_file)]

    with open(output_file, 'w', encoding='utf-8') as outfile:
        for root, dirs, files in os.walk(start_path):
            # Exclude specified directories
            dirs[:] = [d for d in dirs if d not in ignore_dirs]
            
            for file in files:
                if file in ignore_files:
                    continue
                
                file_path = os.path.join(root, file)
                relative_path = os.path.relpath(file_path, start_path)
                
                outfile.write(f"--- {relative_path.replace(os.sep, '/')} ---\n\n")
                try:
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as infile:
                        outfile.write(infile.read())
                        outfile.write('\n\n')
                except Exception as e:
                    outfile.write(f"Could not read file: {e}\n\n")

if __name__ == '__main__':
    client_path = os.path.join(os.path.dirname(os.path.abspath(__file__)))
    output_file_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'client_bundle.txt')
    
    if os.path.isdir(client_path):
        bundle_files(client_path, output_file_path)
        print(f"All files from '{client_path}' have been bundled into '{output_file_path}'")
    else:
        print(f"Error: Directory not found at '{client_path}'")



--- components.json ---

{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "src/index.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}

--- firebase.json ---

{
  "hosting": {
    "public": "dist",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ],
    "headers": [
      {
        "source": "**/*.@(js|jsx|ts|tsx)",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "max-age=31536000"
          }
        ]
      },
      {
        "source": "**/*.@(css|scss)",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "max-age=31536000"
          }
        ]
      },
      {
        "source": "/service-worker.js",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "no-cache"
          }
        ]
      }
    ]
  },
  "firestore": {
    "rules": "firestore.rules",
    "indexes": "firestore.indexes.json"
  },
  "functions": {
    "predeploy": [
      "npm --prefix \"$RESOURCE_DIR\" run lint",
      "npm --prefix \"$RESOURCE_DIR\" run build"
    ]
  },
  "storage": {
    "rules": "storage.rules"
  },
  "emulators": {
    "auth": {
      "port": 9099
    },
    "functions": {
      "port": 5001
    },
    "firestore": {
      "port": 8080
    },
    "storage": {
      "port": 9199
    },
    "ui": {
      "enabled": true,
      "port": 4000
    },
    "singleProjectMode": true
  }
}


--- firestore.indexes.json ---

{
  "indexes": [
    {
      "collectionGroup": "tasks",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "workspaceId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "status",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "createdAt",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "tasks",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "assigneeId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "dueDate",
          "order": "ASCENDING"
        }
      ]
    },
    {
      "collectionGroup": "tasks",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "projectId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "priority",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "pomodoroSessions",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "userId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "startTime",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "notifications",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "userId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "isRead",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "createdAt",
          "order": "DESCENDING"
        }
      ]
    },
    {
      "collectionGroup": "userAchievements",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "userId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "unlockedAt",
          "order": "DESCENDING"
        }
      ]
    }
  ],
  "fieldOverrides": [
    {
      "collectionGroup": "tasks",
      "fieldPath": "tags",
      "indexes": [
        {
          "order": "ASCENDING",
          "queryScope": "COLLECTION"
        },
        {
          "arrayConfig": "CONTAINS",
          "queryScope": "COLLECTION"
        }
      ]
    }
  ]
}


--- firestore.rules ---

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Users can read and write their own user document
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    
    // Workspaces - users can read/write workspaces they're members of
    match /workspaces/{workspaceId} {
      allow read, write: if request.auth != null && 
        request.auth.uid in resource.data.memberIds;
      allow create: if request.auth != null;
    }
    
    // Projects - users can read/write projects in workspaces they're members of
    match /projects/{projectId} {
      allow read, write: if request.auth != null && 
        request.auth.uid in get(/databases/$(database)/documents/workspaces/$(resource.data.workspaceId)).data.memberIds;
      allow create: if request.auth != null;
    }
    
    // Tasks - users can read/write tasks in workspaces they're members of
    match /tasks/{taskId} {
      allow read, write: if request.auth != null && 
        request.auth.uid in get(/databases/$(database)/documents/workspaces/$(resource.data.workspaceId)).data.memberIds;
      allow create: if request.auth != null;
    }
    
    // Pomodoro sessions - users can only access their own sessions
    match /pomodoroSessions/{sessionId} {
      allow read, write: if request.auth != null && 
        request.auth.uid == resource.data.userId;
      allow create: if request.auth != null;
    }
    
    // User achievements - users can only read their own achievements
    match /userAchievements/{achievementId} {
      allow read: if request.auth != null && 
        request.auth.uid == resource.data.userId;
      allow write: if false; // Only server can write achievements
    }
    
    // Garden plants - users can read all, write only their own
    match /gardenPlants/{plantId} {
      allow read: if request.auth != null;
      allow write: if false; // Only server can modify plant definitions
    }
    
    // User garden plants - users can only access their own
    match /userGardenPlants/{userPlantId} {
      allow read, write: if request.auth != null && 
        request.auth.uid == resource.data.userId;
      allow create: if request.auth != null;
    }
    
    // Notifications - users can only access their own
    match /notifications/{notificationId} {
      allow read: if request.auth != null && 
        request.auth.uid == resource.data.userId;
      allow write: if false; // Only server can write notifications
    }
    
    // Analytics - users can only read their own data
    match /analytics/{analyticsId} {
      allow read: if request.auth != null && 
        request.auth.uid == resource.data.userId;
      allow write: if false; // Only server can write analytics
    }
    
    // Custom views - users can read/write their own views
    match /customViews/{viewId} {
      allow read, write: if request.auth != null && 
        request.auth.uid == resource.data.createdById;
      allow create: if request.auth != null;
    }
  }
}


--- index.html ---

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ProgressQuest Universal</title>
    <meta name="description" content="Boost your productivity with gamified task management and Pomodoro technique" />
    <meta name="theme-color" content="#3b82f6" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet" />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


--- merged_ts_files.txt ---

// ----- FILE: A:\Progects\Progress Quest Universal\progressquest-backend\functions\src\config.ts -----
// --- Глобальные Настройки Функций ---
export const functionRegion = "europe-west1"; // ЗАМЕНИТЕ НА ВАШ РЕГИОН!
export const defaultMemoryOption = "256MiB" as const;

export const commonRuntimeOpts = {
  region: functionRegion,
  memory: defaultMemoryOption,
  // timeoutSeconds: 60,
  // retry: true,
};

// --- Названия Firestore Коллекций ---
export const USERS_COLLECTION = "users";
export const TEAMS_COLLECTION = "teams";
export const WORKSPACES_COLLECTION = "workspaces";
export const TASKS_COLLECTION = "tasks";
export const DELETED_ENTITIES_COLLECTION = "deletedEntities";
export const SUBTASKS_COLLECTION = "subtasks";
export const COMMENTS_COLLECTION = "comments";

export const POMODORO_SESSIONS_COLLECTION = "pomodoroSessions";

export const GAMIFICATION_PROFILES_COLLECTION = "gamificationProfiles";
export const EARNED_BADGES_SUBCOLLECTION = "earnedBadges";
export const CHALLENGE_PROGRESS_SUBCOLLECTION = "challengeProgress";
export const VIRTUAL_GARDEN_SUBCOLLECTION = "virtualGarden";
export const BADGE_DEFINITIONS_COLLECTION = "badgeDefinitions";
export const STORE_ITEMS_COLLECTION = "storeItems";

export const TASK_STATISTICS_COLLECTION = "taskStatistics";
export const GLOBAL_STATISTICS_COLLECTION = "globalStatistics";
export const GAMIFICATION_HISTORY_COLLECTION = "gamificationHistory";
export const USER_VIEWS_COLLECTION = "userViews";
export const CHALLENGE_DEFINITIONS_COLLECTION = "challengeDefinitions";
// export const REWARD_DEFINITIONS_COLLECTION = "rewardDefinitions";

// --- Названия Pub/Sub Топиков ---
export const USER_EVENTS_TOPIC = "user-events";
export const TEAM_EVENTS_TOPIC = "team-events";
export const WORKSPACE_EVENTS_TOPIC = "workspace-events";
export const TASK_EVENTS_TOPIC = "task-events";
export const POMODORO_EVENTS_TOPIC = "pomodoro-events";
export const GAMIFICATION_EVENTS_TOPIC = "gamification-events";

// --- Имена полей для Firestore (опционально, для избежания опечаток) ---
// export const FIELD_USER_UID = "uid";
// export const FIELD_TASK_STATUS = "status";

// --- Настройки по умолчанию для новых сущностей ---
export const DEFAULT_USER_DISPLAY_NAME = "Новый Искатель";
export const DEFAULT_PERSONAL_WORKSPACE_NAME = "Мое пространство";
export const DEFAULT_POMODORO_FOCUS_MIN = 25;
export const DEFAULT_POMODORO_SHORT_BREAK_MIN = 5;
export const DEFAULT_POMODORO_LONG_BREAK_MIN = 15;
export const DEFAULT_POMODORO_INTERVAL = 4;

// --- Константы для Геймификации ---
export const XP_FOR_TASK_COMPLETION = 50;
export const COINS_FOR_TASK_COMPLETION = 10;
export const XP_PER_POMODORO_FOCUS_MINUTE = 1;
// 1 монета за каждые N XP от Pomodoro
export const COINS_PER_XP_BATCH_POMODORO = 5;
export const XP_BATCH_FOR_COIN_POMODORO = 10; // N=10
// Мин. фокус для награды
export const MIN_FOCUS_DURATION_FOR_REWARD_SECONDS = 60;

// --- Другие общие константы приложения ---
// export const MAX_TEAM_MEMBERS = 50;
// export const MAX_WORKSPACES_PER_USER = 10;

// --- Константы для типов событий ---
// export const EVENT_TYPE_USER_CREATED = "USER_CREATED";
// export const EVENT_TYPE_TASK_COMPLETED = "TASK_COMPLETED";


// ----- FILE: A:\Progects\Progress Quest Universal\progressquest-backend\functions\src\index.ts -----
import {initializeApp} from "firebase-admin/app";
import {setGlobalOptions} from "firebase-functions/v2";
import {commonRuntimeOpts} from "./config";

initializeApp();
setGlobalOptions(commonRuntimeOpts);
export * from "./auth";
export * from "./http";
export * from "./pubsub";

console.log(
  `[Index] Functions initialized with region: ${commonRuntimeOpts.region}`
);


// ----- FILE: A:\Progects\Progress Quest Universal\progressquest-backend\functions\src\auth\index.ts -----
import * as functionsV1 from "firebase-functions/v1";
import {
  getFirestore,
  FieldValue,
  Timestamp,
  Query,
} from "firebase-admin/firestore";
import {PubSub} from "@google-cloud/pubsub";

import {
  USERS_COLLECTION,
  WORKSPACES_COLLECTION,
  GAMIFICATION_PROFILES_COLLECTION,
  GLOBAL_STATISTICS_COLLECTION,
  USER_EVENTS_TOPIC,
  functionRegion,
  TASKS_COLLECTION,
} from "../config";
import {
  UserDocument,
  WorkspaceDocument,
  GamificationProfileDocument,
  GlobalStatisticsDocument,
} from "../types/firestore.types";
import {UserCreatedEventData} from "../types/events.types";

const db = getFirestore();
const pubsub = new PubSub();
const BATCH_SIZE = 500;

/**
 * Рекурсивно удаляет документы из коллекции или по запросу пачками.
 * @param {Query} query Запрос для получения документов.
 * @param {number} batchSize Размер пачки для удаления.
 * @return {Promise<void>}
 */
async function deleteCollection(
  query: Query,
  batchSize: number
): Promise<void> {
  const snapshot = await query.limit(batchSize).get();

  if (snapshot.size === 0) {
    return;
  }

  const batch = db.batch();
  snapshot.docs.forEach((doc) => {
    batch.delete(doc.ref);
  });
  await batch.commit();

  process.nextTick(() => {
    deleteCollection(query, batchSize);
  });
}

export const processNewUser = functionsV1
  .region(functionRegion)
  .auth.user()
  .onCreate(async (user) => {
    const {uid, email, displayName, photoURL, metadata} = user;
    const now = FieldValue.serverTimestamp();

    const creationTime = metadata.creationTime ?
      new Date(metadata.creationTime) :
      new Date();
    const lastSignInTime = metadata.lastSignInTime ?
      new Date(metadata.lastSignInTime) :
      new Date();

    console.log(`[AuthTrigger] Processing new user: ${uid}, Email: ${email}`);

    const userDocRef = db.collection(USERS_COLLECTION).doc(uid);
    const gamificationProfileRef = db
      .collection(GAMIFICATION_PROFILES_COLLECTION)
      .doc(uid);
    const globalStatsRef = db
      .collection(GLOBAL_STATISTICS_COLLECTION)
      .doc(uid);
    const personalWorkspaceRef = db
      .collection(WORKSPACES_COLLECTION)
      .doc();

    const batch = db.batch();

    const newUserDocData: UserDocument = {
      uid,
      email: email || "",
      displayName: displayName || `User-${uid.substring(0, 5)}`,
      avatarUrl: photoURL || null,
      createdAt: Timestamp.fromDate(creationTime),
      lastLoginAt: Timestamp.fromDate(lastSignInTime),
      personalWorkspaceId: personalWorkspaceRef.id,
      activeItems: {
        workspaceId: personalWorkspaceRef.id,
        viewId: null,
      },
      defaultViewId: null,
      appSettings: {
        theme: "SYSTEM",
        dynamicColorEnabled: true,
        notificationsEnabled: true,
        taskNotifications: true,
        pomodoroNotifications: true,
        gamificationNotifications: true,
      },
      pomodoroSettings: {
        focusDurationMinutes: 25,
        shortBreakMinutes: 5,
        longBreakMinutes: 15,
        intervalBeforeLongBreak: 4,
        autoStartFocus: false,
        autoStartBreak: true,
        focusSoundUri: null,
        breakSoundUri: null,
        vibrationEnabled: true,
      },
      teamMemberships: [],
    };
    batch.set(userDocRef, newUserDocData);

    const personalWorkspaceData: Omit<WorkspaceDocument, "id"> = {
      name: "Личное пространство",
      description: "Мои задачи и проекты",
      ownerUid: uid,
      isPersonal: true,
      teamId: null,
      createdAt: now,
      updatedAt: now,
      activeApproach: "CALENDAR",
      defaultTags: ["важно", "идея"],
      settings: {
        allowMembersToCreateTasks: true,
        taskVisibility: "all_visible",
        pomodoroOverrides: null,
      },
      lastClientSyncTimestamp: null,
      syncStatus: "pending_upload",
    };
    batch.set(personalWorkspaceRef, personalWorkspaceData);

    const gamificationProfileData: GamificationProfileDocument = {
      level: 1,
      experience: 0,
      coins: 50,
      maxExperienceForLevel: 100,
      currentStreak: 0,
      lastClaimedDate: Timestamp.fromDate(new Date(0)),
      maxStreak: 0,
      selectedPlantInstanceId: null,
      lastPomodoroCompletionTime: null,
      lastTaskCompletionTime: null,
    };
    batch.set(gamificationProfileRef, gamificationProfileData);

    const globalStatsData: GlobalStatisticsDocument = {
      userId: uid,
      totalPersonalWorkspacesCreated: 1,
      totalTeamWorkspacesMemberOf: 0,
      totalTasksCreated: 0,
      totalTasksCompleted: 0,
      totalPomodoroFocusMinutes: 0,
      totalTimeSpentMinutesOverall: 0,
      lastActive: now,
      registrationDate: Timestamp.fromDate(creationTime),
    };
    batch.set(globalStatsRef, globalStatsData);

    try {
      await batch.commit();
      console.log(`[AuthTrigger] User documents created for UID: ${uid}`);

      const eventPayload: UserCreatedEventData = {
        userId: uid,
        email: email || undefined,
        displayName: displayName || undefined,
      };
      await pubsub.topic(USER_EVENTS_TOPIC).publishMessage({
        json: {
          eventType: "USER_CREATED",
          eventTimestamp: new Date().toISOString(),
          data: eventPayload,
        },
      });
      console.log(
        `[AuthTrigger] Event USER_CREATED published for UID: ${uid}`
      );
    } catch (error) {
      console.error(
        `[AuthTrigger] Error in onUserCreate for UID: ${uid}`,
        error
      );
    }
  });

export const processUserDeletion = functionsV1
  .region(functionRegion)
  .auth.user()
  .onDelete(async (user) => {
    const {uid} = user;
    console.log(`[AuthTrigger] Deleting data for user UID: ${uid}`);

    const batch = db.batch();

    batch.delete(db.collection(USERS_COLLECTION).doc(uid));
    batch.delete(db
      .collection(GAMIFICATION_PROFILES_COLLECTION)
      .doc(uid));
    batch.delete(db.collection(GLOBAL_STATISTICS_COLLECTION).doc(uid));

    try {
      await batch.commit();
      console.log(`[AuthTrigger] Core user documents for ${uid} deleted.`);
    } catch (error) {
      console.error(
        `[AuthTrigger] Error deleting core documents for UID: ${uid}`,
        error
      );
    }

    const personalWorkspacesQuery = db
      .collection(WORKSPACES_COLLECTION)
      .where("ownerUid", "==", uid)
      .where("isPersonal", "==", true);
    const tasksQuery = db
      .collection(TASKS_COLLECTION)
      .where("creatorUid", "==", uid);

    const fcmTokensQuery = db
      .collection(USERS_COLLECTION)
      .doc(uid)
      .collection("fcmTokens");
    const earnedBadgesQuery = db
      .collection(GAMIFICATION_PROFILES_COLLECTION)
      .doc(uid)
      .collection("earnedBadges");

    try {
      await Promise.all([
        deleteCollection(personalWorkspacesQuery, BATCH_SIZE),
        deleteCollection(tasksQuery, BATCH_SIZE),
        deleteCollection(fcmTokensQuery, BATCH_SIZE),
        deleteCollection(earnedBadgesQuery, BATCH_SIZE),
      ]);
      console.log(
        `[AuthTrigger] All associated data for user ${uid} ` +
        "has been queued for deletion."
      );
    } catch (error) {
      console.error(
        "[AuthTrigger] Critical error during collection deletion " +
        `for UID: ${uid}`,
        error
      );
    }
  });


// ----- FILE: A:\Progects\Progress Quest Universal\progressquest-backend\functions\src\gamification\challengeProcessor.ts -----
import {
  getFirestore,
  FieldValue,
  Transaction,
  Timestamp,
  PartialWithFieldValue,
} from "firebase-admin/firestore";
import * as functions from "firebase-functions";
import {
  CHALLENGE_DEFINITIONS_COLLECTION,
  CHALLENGE_PROGRESS_SUBCOLLECTION,
  GAMIFICATION_PROFILES_COLLECTION,
  EARNED_BADGES_SUBCOLLECTION,
} from "../config";
import {
  ChallengeDefinitionDocument,
  ChallengeProgressDocument,
  ChallengeEventType,
  EarnedBadgeDocument,
} from "../types/firestore.types";

const db = getFirestore();
const logger = functions.logger;

interface UpdateChallengeProgressParams {
  transaction: Transaction;
  userId: string;
  eventType: ChallengeEventType;
  eventValue?: number;
  eventTimestamp: Date;
  eventContext?: Record<string, any>;
}

/**
 * Обновляет прогресс по челленджам пользователя на основе события.
 * @param {UpdateChallengeProgressParams} params - Параметры для обновления.
 */
export async function updateChallengeProgress(
  params: UpdateChallengeProgressParams
): Promise<void> {
  const {transaction, userId, eventType, eventValue = 1} = params;
  logger.debug(
    `[ChallengeProcessor] Updating progress for user ${userId}, ` +
    `event: ${eventType}`
  );

  const personalChallengesQuery = db
    .collection(CHALLENGE_DEFINITIONS_COLLECTION)
    .where("creatorUid", "==", userId)
    .where("type", "==", eventType);
  const systemChallengesQuery = db
    .collection(CHALLENGE_DEFINITIONS_COLLECTION)
    .where("isActiveSystemChallenge", "==", true)
    .where("type", "==", eventType);

  const [personalSnapshot, systemSnapshot] = await Promise.all([
    transaction.get(personalChallengesQuery),
    transaction.get(systemChallengesQuery),
  ]);

  const allRelevantChallenges = [
    ...personalSnapshot.docs,
    ...systemSnapshot.docs,
  ];

  if (allRelevantChallenges.length === 0) {
    logger.debug(
      "[ChallengeProcessor] No active challenges found for event type: " +
      eventType
    );
    return;
  }

  for (const challengeDoc of allRelevantChallenges) {
    const challengeId = challengeDoc.id;
    const challengeData = challengeDoc.data() as ChallengeDefinitionDocument;
    const progressRef = db
      .collection(GAMIFICATION_PROFILES_COLLECTION)
      .doc(userId)
      .collection(CHALLENGE_PROGRESS_SUBCOLLECTION)
      .doc(challengeId);

    const progressDoc = await transaction.get(progressRef);
    let currentProgress = 0;

    if (progressDoc.exists) {
      const progressData = progressDoc.data() as ChallengeProgressDocument;
      if (progressData.isCompleted && challengeData.period === "ONCE") {
        continue; // error: Strings must use doublequote - исправлено на "ONCE"
      }
      currentProgress = (progressData.progress as number) || 0;
    }

    const newProgress = currentProgress + eventValue;
    const isCompletedNow = newProgress >= challengeData.targetValue;

    const progressUpdate: PartialWithFieldValue<ChallengeProgressDocument> = {
      progress: newProgress,
      isCompleted: isCompletedNow,
      lastUpdated: FieldValue.serverTimestamp(),
    };

    if (
      isCompletedNow &&
      (!progressDoc.exists ||
        !(progressDoc.data() as ChallengeProgressDocument).isCompleted)
    ) {
      progressUpdate.completedAt = FieldValue.serverTimestamp();
      logger.info(
        `[ChallengeProcessor] Challenge "${challengeData.name}" completed ` +
        `for user ${userId}. Applying reward...`
      );
      await applyReward(transaction, userId, challengeData);
    }
    transaction.set(progressRef, progressUpdate, {merge: true});
  }
}

/**
 * Применяет награду за выполненный челлендж.
 * @param {Transaction} transaction - Текущая транзакция Firestore.
 * @param {string} userId - ID пользователя.
 * @param {ChallengeDefinitionDocument} challenge - Определение челленджа.
 */
async function applyReward(
  transaction: Transaction,
  userId: string,
  challenge: ChallengeDefinitionDocument
) {
  const reward = challenge.reward;
  const profileRef = db
    .collection(GAMIFICATION_PROFILES_COLLECTION)
    .doc(userId);

  switch (reward.type) {
  case "XP":
    transaction.update(profileRef, {
      experience: FieldValue.increment(Number(reward.value)),
    });
    break;
  case "COINS":
    transaction.update(profileRef, {
      coins: FieldValue.increment(Number(reward.value)),
    });
    break;
  case "BADGE_ID": {
    const earnedBadgeRef = profileRef
      .collection(EARNED_BADGES_SUBCOLLECTION)
      .doc(reward.value);

    if (!reward.badgeName || !reward.badgeImageUrl) {
      logger.warn(
        "[ChallengeProcessor] Badge reward for challenge " +
        `${challenge.name} is missing denormalized name/imageUrl.`
      );
      break;
    }

    const newEarnedBadge: EarnedBadgeDocument = {
      badgeDefinitionId: reward.value,
      earnedAt: Timestamp.now(),
      name: reward.badgeName,
      imageUrl: reward.badgeImageUrl,
      criteria: challenge.description,
    };
    transaction.set(earnedBadgeRef, newEarnedBadge);
    break;
  }
  case "TEXT":
    // Никаких действий на сервере
    break;
  }
}


// ----- FILE: A:\Progects\Progress Quest Universal\progressquest-backend\functions\src\http\gamification.ts -----
import {
  onCall,
  HttpsError,
  CallableRequest,
} from "firebase-functions/v2/https";
import * as functions from "firebase-functions";
import {getFirestore, Timestamp, FieldValue} from "firebase-admin/firestore";
import {
  commonRuntimeOpts,
  GAMIFICATION_PROFILES_COLLECTION,
  CHALLENGE_PROGRESS_SUBCOLLECTION,
  BADGE_DEFINITIONS_COLLECTION,
  EARNED_BADGES_SUBCOLLECTION,
  VIRTUAL_GARDEN_SUBCOLLECTION,
  STORE_ITEMS_COLLECTION,
  CHALLENGE_DEFINITIONS_COLLECTION,
} from "../config";
import {assertAuthenticated} from "../utils";
import {
  GamificationProfileDocument,
  ChallengeDefinitionDocument,
  BadgeDefinitionDocument,
  EarnedBadgeDocument,
  VirtualPlantDocument,
  StoreItemDocument,
} from "../types/firestore.types";
import {
  GetGamificationProfileResponse,
  GamificationProfileClientDto,
  ClaimDailyRewardResponseDto,
  ChallengeDefinitionClientDto,
  CreateCustomChallengePayload,
  CreateChallengeResponse,
  DeleteChallengePayload,
  SuccessResponse,
  GetBadgesResponse,
  BadgeDefinitionClientDto,
  EarnedBadgeClientDto,
  GetVirtualGardenResponse,
  VirtualPlantClientDto,
  SelectPlantRequestPayload,
  GetStoreItemsResponse,
  StoreItemClientDto,
  PurchaseStoreItemPayload,
  PurchaseStoreItemResponse,
  GetChallengesResponse,
  GetAllBadgeDefinitionsResponseDto,
  RewardClientDto,
  WaterPlantRequestPayload,
  WaterPlantResponseDto,
} from "../types/api.types";

const db = getFirestore();
const logger = functions.logger;

// --- ПОЛУЧЕНИЕ ДАННЫХ ---

export const getGamificationProfile = onCall(
  commonRuntimeOpts,
  async (
    request: CallableRequest // warning: no-unused-vars - оставляем
  ): Promise<GetGamificationProfileResponse> => {
    const uid = assertAuthenticated(request.auth);
    const profileRef = db.collection(GAMIFICATION_PROFILES_COLLECTION).doc(uid);

    try {
      const profileDoc = await profileRef.get();
      if (!profileDoc.exists) {
        logger.error(
          `[Gamification] Profile not found for user: ${uid}. ` +
          "Possible onUserCreate trigger issue."
        );
        throw new HttpsError(
          "not-found",
          "Профиль геймификации не найден."
        );
      }
      const profileData = profileDoc.data() as GamificationProfileDocument;
      const clientProfile: GamificationProfileClientDto = {
        level: profileData.level,
        experience: profileData.experience,
        coins: profileData.coins,
        maxExperienceForLevel: profileData.maxExperienceForLevel,
        currentStreak: profileData.currentStreak,
        lastClaimedDate: (
          profileData.lastClaimedDate as Timestamp
        ).toDate().toISOString(),
        maxStreak: profileData.maxStreak,
        selectedPlantId: profileData.selectedPlantInstanceId,
        lastPomodoroCompletionTime: profileData.lastPomodoroCompletionTime ?
          (
            profileData.lastPomodoroCompletionTime as Timestamp
          ).toDate().toISOString() :
          null,
        lastTaskCompletionTime: profileData.lastTaskCompletionTime ?
          (
            profileData.lastTaskCompletionTime as Timestamp
          ).toDate().toISOString() :
          null,
      };
      return {profile: clientProfile};
    } catch (error: unknown) {
      logger.error(
        `[Gamification] Error fetching profile for user ${uid}:`, error
      );
      if (error instanceof HttpsError) {
        throw error;
      }
      throw new HttpsError(
        "internal", "Не удалось загрузить профиль геймификации."
      );
    }
  }
);

export const getAllBadgeDefinitions = onCall(
  commonRuntimeOpts,
  async (
    request: CallableRequest
  ): Promise<GetAllBadgeDefinitionsResponseDto> => {
    assertAuthenticated(request.auth);
    try {
      const snapshot = await db.collection(BADGE_DEFINITIONS_COLLECTION).get();
      const badges: BadgeDefinitionClientDto[] = snapshot.docs.map((doc) => {
        const data = doc.data() as BadgeDefinitionDocument;
        return {
          id: doc.id,
          name: data.name,
          description: data.description,
          imageUrl: data.imageUrl,
          criteria: data.criteriaText,
          rewardXp: data.rewardXp,
          rewardCoins: data.rewardCoins,
          isHidden: data.isHidden,
        };
      });
      return {badges: badges};
    } catch (error) {
      logger.error("[Gamification] Error fetching all badge def:", error);
      throw new HttpsError("internal", "Не удалось загрузить список.");
    }
  }
);

export const getEarnedBadges = onCall(
  commonRuntimeOpts,
  async (request: CallableRequest): Promise<GetBadgesResponse> => {
    const uid = assertAuthenticated(request.auth);
    try {
      const badgesRef = db
        .collection(GAMIFICATION_PROFILES_COLLECTION)
        .doc(uid)
        .collection(EARNED_BADGES_SUBCOLLECTION);
      const snapshot = await badgesRef.orderBy("earnedAt", "desc").get();
      const earnedBadges: EarnedBadgeClientDto[] = snapshot.docs.map((doc) => {
        const data = doc.data() as EarnedBadgeDocument;
        return {
          badgeDefinitionId: doc.id,
          earnedAt: (data.earnedAt as Timestamp).toDate().toISOString(),
          name: data.name,
          imageUrl: data.imageUrl,
          criteria: data.criteria,
        };
      });
      return {badges: earnedBadges};
    } catch (error) {
      logger.error(
        `[Gamification] Error fetching earned badges for user ${uid}:`,
        error
      );
      throw new HttpsError(
        "internal", "Не удалось загрузить ваши достижения."
      );
    }
  }
);

export const getActiveChallenges = onCall(
  commonRuntimeOpts,
  async (
    request: CallableRequest // warning: no-unused-vars - оставляем
  ): Promise<GetChallengesResponse> => {
    logger.warn(
      "[Gamification] getActiveChallenges is not fully implemented " +
      "and returns a placeholder."
    );
    return {challenges: []};
  }
);

export const getVirtualGarden = onCall(
  commonRuntimeOpts,
  async (request: CallableRequest): Promise<GetVirtualGardenResponse> => {
    const uid = assertAuthenticated(request.auth);
    try {
      const [profileDoc, gardenSnapshot] = await Promise.all([
        db.collection(GAMIFICATION_PROFILES_COLLECTION).doc(uid).get(),
        db
          .collection(GAMIFICATION_PROFILES_COLLECTION)
          .doc(uid)
          .collection(VIRTUAL_GARDEN_SUBCOLLECTION)
          .get(),
      ]);

      const selectedPlantId =
        profileDoc.data()?.selectedPlantInstanceId || null;
      const plants: VirtualPlantClientDto[] = gardenSnapshot.docs.map((doc) => {
        const data = doc.data() as VirtualPlantDocument;
        return {
          id: doc.id,
          plantType: data.plantType,
          growthStage: data.growthStage,
          growthPoints: data.growthPoints,
          lastWateredAt: (
            data.lastWateredAt as Timestamp
          ).toDate().toISOString(),
          createdAt: (data.createdAt as Timestamp).toDate().toISOString(),
        };
      });
      return {plants: plants, selectedPlantId: selectedPlantId};
    } catch (error) {
      logger.error(
        `[Gamification] Error fetching virtual garden for user ${uid}:`, error
      );
      throw new HttpsError("internal", "Не удалось загрузить сад.");
    }
  }
);

export const getStoreItems = onCall(
  commonRuntimeOpts,
  async (request: CallableRequest): Promise<GetStoreItemsResponse> => {
    assertAuthenticated(request.auth);
    try {
      const snapshot = await db
        .collection(STORE_ITEMS_COLLECTION)
        .where("isAvailable", "==", true)
        .orderBy("category")
        .orderBy("costInCoins")
        .get();

      const items: StoreItemClientDto[] = snapshot.docs.map((doc) => {
        const data = doc.data() as StoreItemDocument;
        return {
          id: doc.id,
          name: data.name,
          description: data.description,
          costInCoins: data.costInCoins,
          category: data.category,
          itemValue: data.itemValue,
          imageUrl: data.imageUrl,
          isAvailable: data.isAvailable,
        };
      });

      return {items};
    } catch (error) {
      logger.error("[Gamification] Error fetching store items:", error);
      throw new HttpsError("internal", "Не удалось загрузить предметы.");
    }
  }
);

// --- ДЕЙСТВИЯ ПОЛЬЗОВАТЕЛЯ ---

export const claimDailyReward = onCall(
  commonRuntimeOpts,
  async (request: CallableRequest): Promise<ClaimDailyRewardResponseDto> => {
    const uid = assertAuthenticated(request.auth);
    const profileRef = db.collection(GAMIFICATION_PROFILES_COLLECTION).doc(uid);

    try {
      let response: ClaimDailyRewardResponseDto | null = null;
      await db.runTransaction(async (t) => {
        const profileDoc = await t.get(profileRef);
        if (!profileDoc.exists) {
          throw new HttpsError("not-found", "Профиль не найден.");
        }

        const profileData = profileDoc.data() as GamificationProfileDocument;
        const today = new Date();
        today.setUTCHours(0, 0, 0, 0);

        const lastClaimedDate = (
          profileData.lastClaimedDate as Timestamp
        ).toDate();
        lastClaimedDate.setUTCHours(0, 0, 0, 0);

        if (today.getTime() <= lastClaimedDate.getTime()) {
          throw new HttpsError(
            "failed-precondition",
            "Ежедневная награда уже получена сегодня." // max-len: 284 -> OK
          );
        }

        const yesterday = new Date(today);
        yesterday.setDate(yesterday.getDate() - 1);
        const newStreak =
          lastClaimedDate.getTime() === yesterday.getTime() ?
            profileData.currentStreak + 1 :
            1;

        // Здесь должна быть логика получения награды для `newStreak` дня
        // Для примера, заглушка:
        const rewardValue = 10 + newStreak * 2;
        const reward: RewardClientDto = {
          type: "COINS",
          value: rewardValue.toString(),
        };
        const coinsGained = Number(reward.value);

        t.update(profileRef, {
          currentStreak: newStreak,
          maxStreak: Math.max(profileData.maxStreak, newStreak),
          lastClaimedDate: Timestamp.fromDate(today),
          coins: FieldValue.increment(coinsGained),
        });

        response = {
          success: true,
          message: `Награда за ${newStreak}-й день получена!`,
          rewardReceived: reward,
          newStreak: newStreak,
          newXp: 0, // В этом примере XP не дается
          newCoins: coinsGained,
        };
      });

      if (response === null) {
        throw new HttpsError(
          "internal",
          "Транзакция не вернула результат." // max-len: 288 -> OK
        );
      }
      return response;
    } catch (error: unknown) {
      logger.error(
        `[Gamification] Error claiming daily reward for user ${uid}:`,
        error
      );
      if (error instanceof HttpsError) {
        throw error;
      }
      throw new HttpsError(
        "internal",
        "Не удалось получить награду." // max-len: 293 -> OK
      );
    }
  }
);


export const selectPlantInGarden = onCall(
  commonRuntimeOpts,
  async (
    request: CallableRequest<SelectPlantRequestPayload>
  ): Promise<SuccessResponse> => {
    const uid = assertAuthenticated(request.auth);
    const {plantInstanceId} = request.data;
    if (!plantInstanceId) {
      throw new HttpsError(
        "invalid-argument",
        "Необходим ID растения." // max-len: 326 -> OK
      );
    }

    try {
      const profileRef = db
        .collection(GAMIFICATION_PROFILES_COLLECTION)
        .doc(uid);
      await profileRef.update({selectedPlantInstanceId: plantInstanceId});
      return {success: true};
    } catch (error) {
      logger.error(
        `[Gamification] Error selecting plant ${plantInstanceId} ` +
        `for user ${uid}:`,
        error
      );
      throw new HttpsError(
        "internal",
        "Не удалось выбрать растение." // max-len: 365 -> OK
      );
    }
  }
);

export const waterPlantInGarden = onCall(
  commonRuntimeOpts,
  async (
    request: CallableRequest<WaterPlantRequestPayload>
  ): Promise<WaterPlantResponseDto> => {
    const uid = assertAuthenticated(request.auth);
    // const {plantInstanceId} = request.data; // Пока не используется

    const gardenRef = db
      .collection(GAMIFICATION_PROFILES_COLLECTION)
      .doc(uid)
      .collection(VIRTUAL_GARDEN_SUBCOLLECTION);
    const now = Timestamp.now();

    try {
      const allPlantsSnapshot = await gardenRef.get();
      if (allPlantsSnapshot.empty) {
        throw new HttpsError(
          "not-found",
          "У вас нет растений для полива."
        );
      }

      const batch = db.batch();
      const updatedPlantsDto: VirtualPlantClientDto[] = [];

      allPlantsSnapshot.forEach((doc) => {
        batch.update(doc.ref, {lastWateredAt: now});
        const data = doc.data() as VirtualPlantDocument;
        updatedPlantsDto.push({
          id: doc.id,
          ...data,
          lastWateredAt: now.toDate().toISOString(),
          createdAt: (data.createdAt as Timestamp).toDate().toISOString(),
        });
      });

      await batch.commit();

      logger.info(`[Gamification] Watered all plants for user ${uid}.`);
      return {
        success: true,
        message: "Все растения политы!",
        updatedPlants: updatedPlantsDto,
      };
    } catch (error) {
      logger.error(
        `[Gamification] Error watering plants for user ${uid}:`,
        error
      );
      if (error instanceof HttpsError) {
        throw error;
      }
      throw new HttpsError(
        "internal",
        "Не удалось полить растения."
      );
    }
  }
);

export const purchaseStoreItem = onCall(
  commonRuntimeOpts,
  async (
    request: CallableRequest<PurchaseStoreItemPayload>
  ): Promise<PurchaseStoreItemResponse> => {
    const uid = assertAuthenticated(request.auth);
    const {itemId} = request.data;
    if (!itemId) {
      throw new HttpsError(
        "invalid-argument",
        "Необходим ID предмета."
      );
    }

    const profileRef = db.collection(GAMIFICATION_PROFILES_COLLECTION).doc(uid);
    const itemRef = db.collection(STORE_ITEMS_COLLECTION).doc(itemId);

    try {
      let purchaseResponse: PurchaseStoreItemResponse | null = null;
      await db.runTransaction(async (t) => {
        const [profileDoc, itemDoc] = await t.getAll(profileRef, itemRef);
        if (!profileDoc.exists) {
          throw new HttpsError("not-found", "Профиль не найден.");
        }
        if (!itemDoc.exists) {
          throw new HttpsError("not-found", "Предмет не найден.");
        }

        const profile = profileDoc.data() as GamificationProfileDocument;
        const item = itemDoc.data() as StoreItemDocument;
        if (profile.coins < item.costInCoins) {
          throw new HttpsError(
            "failed-precondition",
            "Недостаточно монет." // max-len: 456 -> OK
          );
        }

        t.update(profileRef, {
          coins: FieldValue.increment(-item.costInCoins),
        });

        if (item.category === "PLANT_SEED") {
          const newPlantRef = profileRef
            .collection(VIRTUAL_GARDEN_SUBCOLLECTION)
            .doc();
          const newPlant: VirtualPlantDocument = {
            plantType: item.itemValue,
            growthStage: 0,
            growthPoints: 0,
            createdAt: FieldValue.serverTimestamp(),
            lastWateredAt: Timestamp.fromDate(new Date(0)),
          };
          t.set(newPlantRef, newPlant);
        }

        const remainingCoins = profile.coins - item.costInCoins;
        const itemDto: StoreItemClientDto = {id: itemDoc.id, ...item};

        purchaseResponse = {
          success: true,
          message: `Предмет "${item.name}" успешно куплен!`,
          remainingCoins: remainingCoins,
          itemReceived: itemDto,
        };
      });

      if (!purchaseResponse) {
        throw new HttpsError("internal", "Ошибка транзакции.");
      }
      return purchaseResponse;
    } catch (error) {
      logger.error(
        `[Gamification] Error purchasing item ${itemId} for user ${uid}:`,
        error
      );
      if (error instanceof HttpsError) {
        throw error;
      }
      throw new HttpsError(
        "internal",
        "Не удалось совершить покупку."
      );
    }
  }
);

// --- УПРАВЛЕНИЕ ЧЕЛЛЕНДЖАМИ ---

export const createCustomChallenge = onCall(
  commonRuntimeOpts,
  async (
    request: CallableRequest<CreateCustomChallengePayload>
  ): Promise<CreateChallengeResponse> => {
    const uid = assertAuthenticated(request.auth);
    const data = request.data;
    if (
      !data.name ||
      !data.type ||
      !data.period ||
      !data.reward ||
      !data.targetValue
    ) {
      throw new HttpsError(
        "invalid-argument",
        "Не все обязательные поля для челленджа были предоставлены."
      );
    }

    const newChallengeRef = db
      .collection(CHALLENGE_DEFINITIONS_COLLECTION)
      .doc();
    const newChallengeData: Omit<ChallengeDefinitionDocument, "id"> = {
      name: data.name,
      description: data.description,
      creatorUid: uid,
      scope: "personal",
      targetEntityId: null,
      isPublicTemplate: false,
      reward: data.reward,
      period: data.period,
      type: data.type,
      targetValue: data.targetValue,
      conditionJson: data.conditionJson || null,
      createdAt: FieldValue.serverTimestamp(),
      updatedAt: FieldValue.serverTimestamp(),
    };

    try {
      await newChallengeRef.set(newChallengeData);
      const createdDoc = await newChallengeRef.get();
      const createdData = createdDoc.data() as ChallengeDefinitionDocument;
      const responseChallenge: ChallengeDefinitionClientDto = {
        ...createdData,
        id: createdDoc.id,
        createdAt: (
          createdData.createdAt as Timestamp
        ).toDate().toISOString(),
        updatedAt: (
          createdData.updatedAt as Timestamp
        ).toDate().toISOString(),
      };
      logger.log(
        `[Gamification] Custom challenge '${data.name}' created ` +
        `by user ${uid}.`
      );
      return {challenge: responseChallenge};
    } catch (error) {
      logger.error(
        `[Gamification] Error creating custom challenge for user ${uid}:`,
        error
      );
      throw new HttpsError("internal", "Не удалось создать испытание.");
    }
  }
);

export const deleteCustomChallenge = onCall(
  commonRuntimeOpts,
  async (
    request: CallableRequest<DeleteChallengePayload>
  ): Promise<SuccessResponse> => {
    const uid = assertAuthenticated(request.auth);
    const {challengeDefId} = request.data;
    if (!challengeDefId) {
      throw new HttpsError(
        "invalid-argument",
        "Необходим ID испытания для удаления."
      );
    }

    const challengeRef = db
      .collection(CHALLENGE_DEFINITIONS_COLLECTION)
      .doc(challengeDefId);
    const progressRef = db
      .collection(GAMIFICATION_PROFILES_COLLECTION)
      .doc(uid)
      .collection(CHALLENGE_PROGRESS_SUBCOLLECTION)
      .doc(challengeDefId);

    try {
      await db.runTransaction(async (t) => {
        const challengeDoc = await t.get(challengeRef);
        if (!challengeDoc.exists) {
          throw new HttpsError("not-found", "Испытание не найдено.");
        }
        const challengeData =
          challengeDoc.data() as ChallengeDefinitionDocument;
        if (challengeData.creatorUid !== uid) {
          throw new HttpsError(
            "permission-denied",
            "Вы не можете удалить это испытание."
          );
        }
        t.delete(challengeRef);
        t.delete(progressRef);
      });

      logger.log(
        `[Gamification] Custom challenge ${challengeDefId} deleted ` +
        `by user ${uid}.`
      );
      return {success: true};
    } catch (error) {
      logger.error(
        `[Gamification] Error deleting custom challenge ${challengeDefId} ` +
        `for user ${uid}:`,
        error
      );
      if (error instanceof HttpsError) {
        throw error;
      }
      throw new HttpsError("internal", "Не удалось удалить испытание.");
    }
  }
);


// ----- FILE: A:\Progects\Progress Quest Universal\progressquest-backend\functions\src\http\index.ts -----
export * from "./users";
export * from "./workspaces";
export * from "./tasks";
export * from "./pomodoro";
export * from "./gamification";
// export * from "./teams";
// export * from "./views";
// export * from "./gamification";


// ----- FILE: A:\Progects\Progress Quest Universal\progressquest-backend\functions\src\http\pomodoro.ts -----
import {
  HttpsError,
  onCall,
  CallableRequest,
} from "firebase-functions/v2/https";
import {
  getFirestore,
  FieldValue,
  Timestamp,
  PartialWithFieldValue,
} from "firebase-admin/firestore";
import {
  commonRuntimeOpts,
  POMODORO_SESSIONS_COLLECTION,
  POMODORO_EVENTS_TOPIC,
} from "../config";
import {assertAuthenticated, assertPersonalWorkspaceOwner} from "../utils";
import {
  PomodoroSessionDocument,
} from "../types/firestore.types";
import {
  StartPomodoroPhasePayload,
  StartPomodoroPhaseResponse,
  CompletePomodoroPhasePayload,
  SuccessResponse,
} from "../types/api.types";
import {
  PomodoroPhaseStartedEventData,
  PomodoroPhaseCompletedEventData,
} from "../types/events.types";
import {PubSub} from "@google-cloud/pubsub";

const db = getFirestore();
const pubsub = new PubSub();

export const startPomodoroPhase = onCall(
  commonRuntimeOpts,
  async (request: CallableRequest<StartPomodoroPhasePayload>) => {
    const uid = assertAuthenticated(request.auth);
    const data = request.data;

    if (
      !data.taskId ||
      !data.workspaceId ||
      !data.sessionType ||
      data.plannedDurationSeconds == null ||
      data.plannedDurationSeconds <= 0
    ) {
      throw new HttpsError(
        "invalid-argument",
        "Отсутствуют или некорректны обязательные поля для старта фазы " +
          "Pomodoro."
      );
    }

    try {
      await assertPersonalWorkspaceOwner(data.workspaceId, uid);
    } catch (e: any) {
      if (e instanceof HttpsError) {
        throw e;
      }
      console.error(
        "[Pomo] Permission check failed for startPomodoroPhase for user " +
          `${uid}, ws ${data.workspaceId}`,
        e
      );
      throw new HttpsError("permission-denied", "Доступ запрещен.");
    }

    const now = FieldValue.serverTimestamp();
    const newSessionData: Omit<PomodoroSessionDocument, "id" | "updatedAt"> = {
      userId: uid,
      taskId: data.taskId,
      workspaceId: data.workspaceId,
      sessionType: data.sessionType,
      plannedDurationSeconds: data.plannedDurationSeconds,
      phaseNumberInCycle: data.phaseNumberInCycle || 0,
      totalFocusSessionIndex: data.totalFocusSessionIndex || 0,
      startTime: now,
      actualDurationSeconds: 0,
      interruptions: 0,
      completed: false,
    };

    try {
      const sessionRef = await db
        .collection(POMODORO_SESSIONS_COLLECTION)
        .add(newSessionData);

      const eventPayload: PomodoroPhaseStartedEventData = {
        sessionId: sessionRef.id,
        userId: uid,
        taskId: data.taskId,
        workspaceId: data.workspaceId,
        phaseType: data.sessionType,
        plannedDurationSeconds: data.plannedDurationSeconds,
        phaseNumberInCycle: newSessionData.phaseNumberInCycle,
        totalFocusSessionIndex: newSessionData.totalFocusSessionIndex,
        startTime: new Date().toISOString(),
      };
      await pubsub.topic(POMODORO_EVENTS_TOPIC).publishMessage({
        json: {
          eventType: "POMODORO_PHASE_STARTED",
          data: eventPayload,
          eventTimestamp: new Date().toISOString(),
        },
      });
      // Исправлено max-len
      console.log(`[Pomo] Started Pomodoro phase, ID: ${sessionRef.id}`);
      return {sessionId: sessionRef.id} as StartPomodoroPhaseResponse;
    } catch (e: any) {
      console.error(`[Pomo] Error starting pomodoro phase for user ${uid}:`, e);
      throw new HttpsError(
        "internal",
        "Не удалось начать Pomodoro фазу.",
        String(e?.message)
      );
    }
  }
);

export const completePomodoroPhase = onCall(
  commonRuntimeOpts,
  async (request: CallableRequest<CompletePomodoroPhasePayload>) => {
    const uid = assertAuthenticated(request.auth);
    const data = request.data;

    if (
      !data.sessionId ||
      data.actualDurationSeconds == null ||
      data.interruptions == null ||
      data.completed == null
    ) {
      throw new HttpsError(
        "invalid-argument",
        "Отсутствуют обязательные поля для завершения фазы Pomodoro."
      );
    }

    const sessionRef = db
      .collection(POMODORO_SESSIONS_COLLECTION)
      .doc(data.sessionId);
    const now = FieldValue.serverTimestamp();

    try {
      let phaseDataForEvent: PomodoroPhaseCompletedEventData | null = null;

      await db.runTransaction(async (t) => {
        const sessionDoc = await t.get(sessionRef);
        if (!sessionDoc.exists) {
          throw new HttpsError("not-found", "Сессия Pomodoro не найдена.");
        }
        const sessionData = sessionDoc.data() as PomodoroSessionDocument;
        if (sessionData.userId !== uid) {
          throw new HttpsError(
            "permission-denied",
            "Вы не можете завершить эту сессию Pomodoro."
          );
        }
        if (sessionData.completed) {
          console.warn(
            `[Pomo] Session ${data.sessionId} already marked as completed. ` +
            "Skipping update, but will re-publish event."
          );
        }

        const updatePayload: PartialWithFieldValue<PomodoroSessionDocument> = {
          actualDurationSeconds: data.actualDurationSeconds,
          interruptions: data.interruptions,
          completed: data.completed,
          updatedAt: now,
        };
        t.update(sessionRef, updatePayload);

        phaseDataForEvent = {
          sessionId: data.sessionId,
          userId: uid,
          taskId: sessionData.taskId,
          workspaceId: sessionData.workspaceId,
          phaseType: sessionData.sessionType,
          plannedDurationSeconds: sessionData.plannedDurationSeconds,
          actualDurationSeconds: data.actualDurationSeconds,
          interruptions: data.interruptions,
          completed: data.completed,
          phaseStartTime:
            (sessionData.startTime as Timestamp).toDate().toISOString(),
          completionTime: new Date().toISOString(),
        };
      });

      if (phaseDataForEvent) {
        await pubsub.topic(POMODORO_EVENTS_TOPIC).publishMessage({
          json: {
            eventType: "POMODORO_PHASE_COMPLETED",
            data: phaseDataForEvent,
            eventTimestamp: new Date().toISOString(),
          },
        });
        console.log(
          `[Pomo] Pomodoro phase ${data.sessionId} processed. Event published.`
        );
      } else {
        console.error(
          "[Pomo] phaseDataForEvent was null after transaction for session " +
            `${data.sessionId}.`
        );
      }
      return {
        success: true,
        message: "Pomodoro фаза обработана.",
      } as SuccessResponse;
    } catch (e: any) {
      console.error(
        `[Pomo] Error completing pomodoro phase ${data.sessionId}:`,
        e
      );
      if (e instanceof HttpsError) {
        throw e;
      }
      throw new HttpsError(
        "internal",
        "Не удалось завершить Pomodoro фазу.",
        String(e?.message)
      );
    }
  }
);


// ----- FILE: A:\Progects\Progress Quest Universal\progressquest-backend\functions\src\http\statistics.ts -----
import {
  HttpsError,
  onCall,
  CallableRequest,
} from "firebase-functions/v2/https";
import {getFirestore, Timestamp} from "firebase-admin/firestore";
import * as functions from "firebase-functions";
import {
  commonRuntimeOpts,
  GLOBAL_STATISTICS_COLLECTION,
  TASK_STATISTICS_COLLECTION,
  GAMIFICATION_HISTORY_COLLECTION,
} from "../config";
import {assertAuthenticated} from "../utils";
import {
  GlobalStatisticsDocument,
  TaskStatisticsDocument,
  GamificationHistoryEntryDocument,
} from "../types/firestore.types";
import {
  GetGlobalStatisticsResponse,
  GetTaskStatisticsResponse,
  GetGamificationHistoryPayload,
  GetGamificationHistoryResponse,
  GamificationHistoryEntryClientDto,
  GetTaskStatisticsPayload,
  TaskStatisticsClientDto,
  StatsPeriodSummaryClientDto,
  StatsTrendRequestPayload,
} from "../types/api.types";

const db = getFirestore();
const logger = functions.logger;

export const getGlobalStatistics = onCall(
  commonRuntimeOpts,
  async (request: CallableRequest): Promise<GetGlobalStatisticsResponse> => {
    const uid = assertAuthenticated(request.auth);
    try {
      const doc = await db
        .collection(GLOBAL_STATISTICS_COLLECTION)
        .doc(uid)
        .get();
      if (!doc.exists) {
        throw new HttpsError("not-found", "Статистика не найдена.");
      }
      const data = doc.data() as GlobalStatisticsDocument;
      return {
        statistics: {
          ...data,
          lastActive: (
            data.lastActive as Timestamp
          ).toDate().toISOString(),
          registrationDate: (
            data.registrationDate as Timestamp
          ).toDate().toISOString(),
        },
      };
    } catch (error) {
      logger.error(
        `[Stats] Error fetching global stats for ${uid}:`,
        error
      );
      if (error instanceof HttpsError) {
        throw error;
      }
      throw new HttpsError(
        "internal",
        "Ошибка загрузки статистики."
      );
    }
  }
);

export const getTaskStatistics = onCall(
  commonRuntimeOpts,
  async (
    request: CallableRequest<GetTaskStatisticsPayload>
  ): Promise<GetTaskStatisticsResponse> => {
    assertAuthenticated(request.auth);
    const {taskId} = request.data;
    if (!taskId) {
      throw new HttpsError("invalid-argument", "Необходим ID задачи.");
    }

    try {
      const doc = await db
        .collection(TASK_STATISTICS_COLLECTION)
        .doc(taskId)
        .get();
      if (!doc.exists) {
        throw new HttpsError(
          "not-found",
          "Статистика для задачи не найдена."
        );
      }

      const data = doc.data() as TaskStatisticsDocument;
      const responseDto: TaskStatisticsClientDto = {
        completionTime: data.completionTime ?
          (data.completionTime as Timestamp).toDate().toISOString() :
          null,
        timeSpentSeconds: data.timeSpentSeconds,
        totalPomodoroFocusSeconds: data.totalPomodoroFocusSeconds,
        completedPomodoroFocusSessions:
          data.completedPomodoroFocusSessions,
        totalPomodoroInterrupts: data.totalPomodoroInterrupts,
        wasCompletedOnce: data.wasCompletedOnce,
        firstCompletionTime: data.firstCompletionTime ?
          (
            data.firstCompletionTime as Timestamp
          ).toDate().toISOString() :
          null,
        updatedAt: (data.updatedAt as Timestamp).toDate().toISOString(),
      };
      return {statistics: responseDto};
    } catch (error) {
      logger.error(
        `[Stats] Error fetching task stats for ${taskId}:`,
        error
      );
      throw new HttpsError(
        "internal",
        "Ошибка загрузки статистики задачи."
      );
    }
  }
);

export const getGamificationHistory = onCall(
  commonRuntimeOpts,
  async (
    request: CallableRequest<GetGamificationHistoryPayload>
  ): Promise<GetGamificationHistoryResponse> => {
    const uid = assertAuthenticated(request.auth);
    const {limit = 20, startAfterEntryId} = request.data;

    try {
      let query = db
        .collection(GAMIFICATION_HISTORY_COLLECTION)
        .where("userId", "==", uid)
        .orderBy("timestamp", "desc")
        .limit(limit);

      if (startAfterEntryId) {
        const lastDoc = await db
          .collection(GAMIFICATION_HISTORY_COLLECTION)
          .doc(startAfterEntryId)
          .get();
        if (lastDoc.exists) {
          query = query.startAfter(lastDoc);
        }
      }

      const snapshot = await query.get();
      const history: GamificationHistoryEntryClientDto[] =
        snapshot.docs.map((doc) => {
          const data = doc.data() as GamificationHistoryEntryDocument;
          return {
            id: doc.id,
            timestamp: (
              data.timestamp as Timestamp
            ).toDate().toISOString(),
            eventType: data.eventType,
            xpChange: data.xpChange,
            coinsChange: data.coinsChange,
            relatedEntityCloudId: data.relatedEntityId,
            relatedEntityType: data.relatedEntityType,
            description: data.description,
          };
        });

      const lastVisibleDoc = snapshot.docs[snapshot.docs.length - 1];
      const nextPageToken = lastVisibleDoc ?
        lastVisibleDoc.id :
        null;

      return {history, nextPageToken};
    } catch (error) {
      logger.error(
        `[Stats] Error fetching gamification history for ${uid}:`,
        error
      );
      throw new HttpsError(
        "internal",
        "Ошибка загрузки истории."
      );
    }
  }
);

export const getStatsPeriodSummary = onCall(
  commonRuntimeOpts,
  async (
    request: CallableRequest<StatsTrendRequestPayload>
  ): Promise<StatsPeriodSummaryClientDto> => {
    assertAuthenticated(request.auth);
    // Это сложная функция, которая требует агрегации данных.
    // Для MVP она возвращает заглушку.
    logger.warn(
      "[Stats] getStatsPeriodSummary is a placeholder and not implemented."
    );
    return {
      startDate: request.data.startDate,
      endDate: request.data.endDate,
    };
  }
);


// ----- FILE: A:\Progects\Progress Quest Universal\progressquest-backend\functions\src\http\tasks.ts -----
import {
  HttpsError,
  onCall,
  CallableRequest,
} from "firebase-functions/v2/https";
import {
  getFirestore,
  FieldValue,
  Timestamp,
  Query,
  PartialWithFieldValue,
} from "firebase-admin/firestore";
import {
  commonRuntimeOpts,
  TASKS_COLLECTION,
  GLOBAL_STATISTICS_COLLECTION,
  TASK_EVENTS_TOPIC,
  USERS_COLLECTION,
  DELETED_ENTITIES_COLLECTION,
  SUBTASKS_COLLECTION,
} from "../config";
import {assertAuthenticated, assertPersonalWorkspaceOwner} from "../utils";
import {
  SubtaskDocument,
  TaskDocument,
  TaskStatusType,
  UserViewDocument,
} from "../types/firestore.types";
import {
  CreateTaskPayload,
  TaskClientDto,
  GetTasksPayload,
  GetTasksResponse,
  GetTaskDetailsPayload,
  GetTaskDetailsResponse,
  UpdateTaskPayload,
  UpdateTaskResponse,
  DeleteTaskPayload,
  SuccessResponse,
  UpdateTaskStatusPayload,
  CreateTaskResponse,
  DateRangeFilterClientDto,
  ViewFiltersClientDto,
  CreateSubtaskPayload,
  SubtaskClientDto,
  GetTaskChangesPayload,
  GetTaskChangesResponse,
  DeleteSubtaskPayload,
} from "../types/api.types";
import {
  TaskCreatedEventData,
  TaskStatusUpdatedEventData,
} from "../types/events.types";
import {PubSub} from "@google-cloud/pubsub";

const db = getFirestore();
const pubsub = new PubSub();

export const createTask = onCall(
  commonRuntimeOpts,
  async (request: CallableRequest<CreateTaskPayload>) => {
    const uid = assertAuthenticated(request.auth);
    const data = request.data;

    if (!data.title || !data.workspaceId) {
      throw new HttpsError(
        "invalid-argument",
        "Title & WorkspaceId required."
      );
    }
    await assertPersonalWorkspaceOwner(data.workspaceId, uid);

    const now = FieldValue.serverTimestamp();
    const newTaskRef = db.collection(TASKS_COLLECTION).doc();

    const newTaskData: Omit<TaskDocument, "id"> = {
      title: data.title.trim(),
      description: data.description?.trim() || null,
      status: "TODO",
      priority: data.priority || "MEDIUM",
      dueDate: data.dueDate ?
        Timestamp.fromDate(new Date(data.dueDate)) :
        null,
      createdAt: now,
      updatedAt: now,
      completedAt: null,
      creatorUid: uid,
      assigneeUid: uid,
      workspaceId: data.workspaceId,
      tags: data.tags || [],
      pomodoroEstimatedCycles: null,
      pomodoroEstimatedMinutes: data.pomodoroEstimatedMinutes || null,
      approachParams: data.approachParams || null,
      orderInList: 0,
      lastSyncClientTimestamp: null,
      localId: null,
    };

    try {
      await db.runTransaction(async (t) => {
        t.set(newTaskRef, newTaskData);
        const gsRef = db.collection(GLOBAL_STATISTICS_COLLECTION).doc(uid);
        t.update(gsRef, {
          totalTasksCreated: FieldValue.increment(1),
          lastActive: now,
        });
      });

      const eventPayload: TaskCreatedEventData = {
        taskId: newTaskRef.id,
        workspaceId: data.workspaceId,
        creatorUid: uid,
        assigneeUid: uid,
        title: newTaskData.title,
      };
      await pubsub.topic(TASK_EVENTS_TOPIC).publishMessage({
        json: {
          eventType: "TASK_CREATED",
          data: eventPayload,
          eventTimestamp: new Date().toISOString(),
        },
      });
      console.log(
        `[Tasks] Task ${newTaskRef.id} created in ws ${data.workspaceId}`
      );
      const createdDoc = await newTaskRef.get();
      const createdData = createdDoc.data() as TaskDocument;
      return {
        task: {
          id: newTaskRef.id,
          ...createdData,
          createdAt: (
            createdData.createdAt as Timestamp
          ).toDate().toISOString(),
          updatedAt: (
            createdData.updatedAt as Timestamp
          ).toDate().toISOString(),
          dueDate: createdData.dueDate ?
            (createdData.dueDate as Timestamp).toDate().toISOString() :
            null,
          completedAt: null,
        },
      } as CreateTaskResponse;
    } catch (e: any) {
      console.error(
        `[Tasks] Error creating task for ws ${data.workspaceId}:`,
        e
      );
      if (e instanceof HttpsError) {
        throw e;
      }
      throw new HttpsError(
        "internal",
        "Failed to create task.",
        String(e?.message)
      );
    }
  }
);

export const getTasks = onCall(
  commonRuntimeOpts,
  async (request: CallableRequest<GetTasksPayload>) => {
    const uid = assertAuthenticated(request.auth);
    const {viewId, workspaceId, filters, sortBy, sortDirection} = request.data;

    let targetWorkspaceIds: string[] = [];
    let effectiveFilters: ViewFiltersClientDto | null = filters || null;
    let effectiveSortBy = sortBy;
    let effectiveSortDir = sortDirection;

    try {
      if (viewId) {
        const viewRef = db.collection(USERS_COLLECTION).doc(uid)
          .collection("views").doc(viewId);
        const viewDoc = await viewRef.get();
        if (!viewDoc.exists) {
          throw new HttpsError("not-found", "Представление не найдено.");
        }
        const viewDataFromDb = viewDoc.data() as UserViewDocument;
        targetWorkspaceIds = viewDataFromDb.workspaceIds;

        if (viewDataFromDb.filters) {
          const dbFilters = viewDataFromDb.filters;
          let clientDateRange: DateRangeFilterClientDto | null | undefined =
            undefined;

          if (dbFilters.dateRange) {
            const dr = dbFilters.dateRange;
            clientDateRange = {
              start: dr.start ?
                (dr.start as Timestamp).toDate().toISOString() :
                null,
              end: dr.end ? (dr.end as Timestamp).toDate().toISOString() : null,
              type: dr.type,
            };
          }

          effectiveFilters = {
            status: dbFilters.status || undefined,
            priority: dbFilters.priority || undefined,
            tagsInclude: dbFilters.tagsInclude || undefined,
            tagsExclude: dbFilters.tagsExclude || undefined,
            dateRange: clientDateRange,
            assignee: dbFilters.assignee || undefined,
          };
        } else {
          effectiveFilters = null;
        }

        effectiveSortBy = viewDataFromDb.sortBy || effectiveSortBy;
        effectiveSortDir = viewDataFromDb.sortDirection || effectiveSortDir;

        if (targetWorkspaceIds.length === 0) {
          return {tasks: []} as GetTasksResponse;
        }
      } else if (workspaceId) {
        targetWorkspaceIds = [workspaceId];
      } else {
        throw new HttpsError(
          "invalid-argument",
          "Должен быть предоставлен viewId или workspaceId."
        );
      }

      for (const wsId of targetWorkspaceIds) {
        await assertPersonalWorkspaceOwner(wsId, uid);
      }

      let query: Query = db.collection(TASKS_COLLECTION)
        .where("workspaceId", "in", targetWorkspaceIds)
        .where("creatorUid", "==", uid);

      if (effectiveFilters) {
        if (effectiveFilters.status && effectiveFilters.status.length > 0) {
          if (effectiveFilters.status.length < 30) {
            query = query.where("status", "in", effectiveFilters.status);
          }
        }
        if (effectiveFilters.priority && effectiveFilters.priority.length > 0) {
          if (effectiveFilters.priority.length < 30) {
            query = query.where("priority", "in", effectiveFilters.priority);
          }
        }
        if (
          effectiveFilters.tagsInclude &&
          effectiveFilters.tagsInclude.length > 0
        ) {
          if (effectiveFilters.tagsInclude.length < 30) {
            query = query.where(
              "tags",
              "array-contains-any",
              effectiveFilters.tagsInclude
            );
          }
        }
        if (effectiveFilters.dateRange) {
          const drClient = effectiveFilters.dateRange;
          const fieldToFilter =
            drClient.type === "created" ?
              "createdAt" :
              drClient.type === "completed" ?
                "completedAt" :
                "dueDate";
          if (drClient.start) {
            query = query.where(
              fieldToFilter,
              ">=",
              Timestamp.fromDate(new Date(drClient.start))
            );
          }
          if (drClient.end) {
            const endDate = new Date(drClient.end as string | number);
            const endOfDay = new Date(
              endDate.getFullYear(),
              endDate.getMonth(),
              endDate.getDate() + 1
            );
            query = query.where(
              fieldToFilter,
              "<",
              Timestamp.fromDate(endOfDay)
            );
          }
        }
        if (effectiveFilters.assignee) {
          if (effectiveFilters.assignee === "me") {
            query = query.where("assigneeUid", "==", uid);
          } else if (effectiveFilters.assignee === "unassigned") {
            query = query.where("assigneeUid", "==", null);
          } else {
            query = query.where(
              "assigneeUid",
              "==",
              effectiveFilters.assignee
            );
          }
        }
      }

      const finalSortBy = effectiveSortBy || "createdAt";
      const finalSortDir = effectiveSortDir || "desc";
      query = query.orderBy(finalSortBy, finalSortDir);

      const snapshot = await query.limit(100).get();
      const tasks = snapshot.docs.map((doc) => {
        const data = doc.data() as TaskDocument;
        return {
          id: doc.id,
          ...data,
          createdAt: (data.createdAt as Timestamp).toDate().toISOString(),
          updatedAt: (data.updatedAt as Timestamp).toDate().toISOString(),
          dueDate: data.dueDate ?
            (data.dueDate as Timestamp).toDate().toISOString() :
            null,
          completedAt: data.completedAt ?
            (data.completedAt as Timestamp).toDate().toISOString() :
            null,
        } as TaskClientDto;
      });
      return {tasks} as GetTasksResponse;
    } catch (e: any) {
      console.error(
        `[Tasks] Error fetching tasks for user ${uid} ` +
          `(wsId: ${workspaceId}, viewId: ${viewId}):`,
        e
      );
      if (e instanceof HttpsError) {
        throw e;
      }
      throw new HttpsError(
        "internal",
        "Не удалось загрузить задачи.",
        String(e?.message)
      );
    }
  }
);

export const getTaskDetails = onCall(
  commonRuntimeOpts,
  async (request: CallableRequest<GetTaskDetailsPayload>) => {
    const uid = assertAuthenticated(request.auth);
    const {taskId} = request.data;

    if (!taskId) {
      throw new HttpsError("invalid-argument", "TaskId is required.");
    }
    try {
      const taskRef = db.collection(TASKS_COLLECTION).doc(taskId);
      const taskDoc = await taskRef.get();
      if (!taskDoc.exists) {
        throw new HttpsError("not-found", "Task not found.");
      }
      const taskData = taskDoc.data() as TaskDocument;
      await assertPersonalWorkspaceOwner(taskData.workspaceId, uid);

      return {
        task: {
          id: taskDoc.id,
          ...taskData,
          createdAt: (
            taskData.createdAt as Timestamp
          ).toDate().toISOString(),
          updatedAt: (
            taskData.updatedAt as Timestamp
          ).toDate().toISOString(),
          dueDate: taskData.dueDate ?
            (taskData.dueDate as Timestamp).toDate().toISOString() :
            null,
          completedAt: taskData.completedAt ?
            (taskData.completedAt as Timestamp).toDate().toISOString() :
            null,
        },
      } as GetTaskDetailsResponse;
    } catch (e: any) {
      console.error(
        `[Tasks] Error fetching details for task ${taskId}:`,
        e
      );
      if (e instanceof HttpsError) {
        throw e;
      }
      throw new HttpsError(
        "internal",
        "Fetch task details failed.",
        String(e?.message)
      );
    }
  }
);

export const updateTask = onCall(
  commonRuntimeOpts,
  async (request: CallableRequest<UpdateTaskPayload>) => {
    const uid = assertAuthenticated(request.auth);
    const data = request.data;
    const {taskId} = data;

    if (!taskId) {
      throw new HttpsError("invalid-argument", "TaskId is required.");
    }
    const taskRef = db.collection(TASKS_COLLECTION).doc(taskId);
    const updates: PartialWithFieldValue<TaskDocument> = {};
    let hasUpdates = false;

    if (data.title !== undefined) {
      updates.title = data.title;
      hasUpdates = true;
    }
    if (data.description !== undefined) {
      updates.description = data.description;
      hasUpdates = true;
    }
    if (data.priority !== undefined) {
      updates.priority = data.priority;
      hasUpdates = true;
    }
    if (data.dueDate !== undefined) {
      updates.dueDate = data.dueDate ?
        Timestamp.fromDate(new Date(data.dueDate)) :
        null;
      hasUpdates = true;
    }
    if (data.tags !== undefined) {
      updates.tags = data.tags;
      hasUpdates = true;
    }
    if (data.approachParams !== undefined) {
      updates.approachParams = data.approachParams;
      hasUpdates = true;
    }
    if (data.pomodoroEstimatedMinutes !== undefined) {
      updates.pomodoroEstimatedMinutes = data.pomodoroEstimatedMinutes;
      hasUpdates = true;
    }

    if (!hasUpdates) {
      throw new HttpsError("invalid-argument", "No data to update.");
    }
    updates.updatedAt = FieldValue.serverTimestamp();

    try {
      await db.runTransaction(async (t) => {
        const taskDoc = await t.get(taskRef);
        if (!taskDoc.exists) {
          throw new HttpsError("not-found", "Task not found.");
        }
        const taskData = taskDoc.data() as TaskDocument;
        await assertPersonalWorkspaceOwner(taskData.workspaceId, uid);
        t.update(taskRef, updates);
      });

      const updatedDoc = await taskRef.get();
      const updatedData = updatedDoc.data() as TaskDocument;
      console.log(`[Tasks] Task ${taskId} updated.`);
      return {
        success: true,
        updatedTask: {
          id: updatedDoc.id,
          ...updatedData,
          createdAt: (
            updatedData.createdAt as Timestamp
          ).toDate().toISOString(),
          updatedAt: (
            updatedData.updatedAt as Timestamp
          ).toDate().toISOString(),
          dueDate: updatedData.dueDate ?
            (updatedData.dueDate as Timestamp).toDate().toISOString() :
            null,
          completedAt: updatedData.completedAt ?
            (updatedData.completedAt as Timestamp).toDate().toISOString() :
            null,
        },
      } as UpdateTaskResponse;
    } catch (e: any) {
      console.error(`[Tasks] Error updating task ${taskId}:`, e);
      if (e instanceof HttpsError) {
        throw e;
      }
      throw new HttpsError(
        "internal",
        "Failed to update task.",
        String(e?.message)
      );
    }
  }
);

export const updateTaskStatus = onCall(
  commonRuntimeOpts,
  async (request: CallableRequest<UpdateTaskStatusPayload>) => {
    const uid = assertAuthenticated(request.auth);
    const {taskId, newStatus, workspaceId} = request.data;

    if (!taskId || !newStatus || !workspaceId) {
      throw new HttpsError("invalid-argument", "Required fields missing.");
    }
    const taskRef = db.collection(TASKS_COLLECTION).doc(taskId);
    const now = FieldValue.serverTimestamp();
    try {
      let oldStatus: TaskStatusType | undefined;
      let taskInfoForEvent: Partial<
        Pick<TaskDocument, "title" | "assigneeUid" | "creatorUid">
      > | undefined;

      await db.runTransaction(async (t) => {
        const taskDoc = await t.get(taskRef);
        if (
          !taskDoc.exists ||
          (taskDoc.data() as TaskDocument).workspaceId !== workspaceId
        ) {
          throw new HttpsError("not-found", "Task not found or invalid ws.");
        }
        const currentTaskData = taskDoc.data() as TaskDocument;
        await assertPersonalWorkspaceOwner(currentTaskData.workspaceId, uid);
        oldStatus = currentTaskData.status;
        taskInfoForEvent = {
          title: currentTaskData.title,
          assigneeUid: currentTaskData.assigneeUid,
          creatorUid: currentTaskData.creatorUid,
        };
        const updatePayload: PartialWithFieldValue<TaskDocument> = {
          status: newStatus,
          updatedAt: now,
        };
        if (newStatus === "DONE" && oldStatus !== "DONE") {
          updatePayload.completedAt = now;
        } else if (newStatus !== "DONE" && oldStatus === "DONE") {
          updatePayload.completedAt = null;
        }
        t.update(taskRef, updatePayload);
      });

      const eventData: TaskStatusUpdatedEventData = {
        taskId,
        workspaceId,
        userId: uid,
        newStatus,
        oldStatus,
        completedAt:
          newStatus === "DONE" ? new Date().toISOString() : undefined,
        taskData: taskInfoForEvent,
      };
      await pubsub.topic(TASK_EVENTS_TOPIC).publishMessage({
        json: {
          eventType: "TASK_STATUS_UPDATED",
          data: eventData,
          eventTimestamp: new Date().toISOString(),
        },
      });
      console.log(
        `[Tasks] Status of task ${taskId} updated to ${newStatus}.`
      );
      return {
        success: true,
        message: "Статус задачи обновлен.",
      } as SuccessResponse;
    } catch (e: any) {
      console.error(
        `[Tasks] Error updating status for task ${taskId}:`,
        e
      );
      if (e instanceof HttpsError) {
        throw e;
      }
      throw new HttpsError(
        "internal",
        "Update status failed.",
        String(e?.message)
      );
    }
  }
);

export const deleteTask = onCall(
  commonRuntimeOpts,
  async (request: CallableRequest<DeleteTaskPayload>) => {
    const uid = assertAuthenticated(request.auth);
    const {taskId} = request.data;
    if (!taskId) {
      throw new HttpsError("invalid-argument", "TaskId is required.");
    }

    const taskRef = db.collection(TASKS_COLLECTION).doc(taskId);

    try {
      const taskDoc = await taskRef.get();
      if (!taskDoc.exists) {
        throw new HttpsError("not-found", "Task not found.");
      }

      const taskData = taskDoc.data() as TaskDocument;
      await assertPersonalWorkspaceOwner(taskData.workspaceId, uid);

      // Просто удаляем документ. Триггер сделает остальную работу.
      await taskRef.delete();

      console.log(
        `[Tasks] Task ${taskId} deletion initiated by user ${uid}.`
      );
      return {success: true, message: "Задача удалена."};
    } catch (e: any) {
      console.error(`[Tasks] Error deleting task ${taskId}:`, e);
      if (e instanceof HttpsError) {
        throw e;
      }
      throw new HttpsError("internal", "Failed to delete task.", e.message);
    }
  }
);

export const getTaskChanges = onCall(
  commonRuntimeOpts,
  async (
    request: CallableRequest<GetTaskChangesPayload>
  ): Promise<GetTaskChangesResponse> => {
    const uid = assertAuthenticated(request.auth);
    const {since, workspaceIds} = request.data;

    if (!Array.isArray(workspaceIds) || workspaceIds.length === 0) {
      throw new HttpsError(
        "invalid-argument",
        "Workspace IDs must be a non-empty array."
      );
    }
    if (!since) {
      throw new HttpsError(
        "invalid-argument",
        "A 'since' timestamp is required."
      );
    }

    // Проверяем права на все запрашиваемые РП
    for (const wsId of workspaceIds) {
      await assertPersonalWorkspaceOwner(wsId, uid);
    }

    const sinceTimestamp = Timestamp.fromDate(new Date(since));
    const serverTimestamp = Timestamp.now().toDate().toISOString();

    const updatedTasksPromise = db
      .collection(TASKS_COLLECTION)
      .where("workspaceId", "in", workspaceIds)
      .where("updatedAt", ">", sinceTimestamp)
      .get();

    const deletedTasksPromise = db
      .collection(DELETED_ENTITIES_COLLECTION)
      .where("entityType", "==", "task")
      .where("workspaceId", "in", workspaceIds)
      .where("deletedAt", ">", sinceTimestamp)
      .get();

    try {
      const [updatedSnapshot, deletedSnapshot] = await Promise.all([
        updatedTasksPromise,
        deletedTasksPromise,
      ]);

      const updatedTasks: TaskClientDto[] = updatedSnapshot.docs.map((doc) => {
        const data = doc.data() as TaskDocument;
        // eslint-disable-next-line max-len
        return {
          /* ...маппинг в TaskClientDto... */ id: doc.id,
          ...data,
        } as unknown as TaskClientDto;
      });

      const deletedTaskCloudIds = deletedSnapshot.docs.map((doc) => doc.id);

      console.info(
        `[Sync] Returning ${updatedTasks.length} updated and ` +
        `${deletedTaskCloudIds.length} deleted tasks for user ${uid}.`
      );

      return {
        updatedTasks,
        deletedTaskCloudIds,
        serverTimestamp,
      };
    } catch (error) {
      console.error(
        `[Sync] Error getting task changes for user ${uid}`,
        error
      );
      throw new HttpsError(
        "internal",
        "Ошибка получения изменений задач."
      );
    }
  }
);

export const addSubtask = onCall(
  commonRuntimeOpts,
  async (
    request: CallableRequest<CreateSubtaskPayload>
  ): Promise<SubtaskClientDto> => {
    const uid = assertAuthenticated(request.auth);
    const {parentTaskId, title} = request.data;
    if (!parentTaskId || !title) {
      throw new HttpsError(
        "invalid-argument",
        "Parent taskId and title are required."
      );
    }

    const parentTaskRef = db.collection(TASKS_COLLECTION).doc(parentTaskId);
    const subtaskRef = parentTaskRef.collection(SUBTASKS_COLLECTION).doc();

    try {
      const parentTaskDoc = await parentTaskRef.get();
      if (!parentTaskDoc.exists) {
        throw new HttpsError("not-found", "Parent task not found.");
      }
      await assertPersonalWorkspaceOwner(
        (parentTaskDoc.data() as TaskDocument).workspaceId,
        uid
      );

      const newSubtask: SubtaskDocument = {
        title: title.trim(),
        completed: false,
        order: 0, // Логику порядка лучше делать на клиенте или при запросе
        createdAt: FieldValue.serverTimestamp(),
      };

      // Запускаем в транзакции, чтобы обновить и родительскую задачу
      await db.runTransaction(async (t) => {
        t.set(subtaskRef, newSubtask);
        // Важно! Обновляем updatedAt у родителя
        t.update(parentTaskRef, {updatedAt: FieldValue.serverTimestamp()});
      });

      const createdDoc = await subtaskRef.get();
      const createdData = createdDoc.data() as SubtaskDocument;
      return {
        id: createdDoc.id,
        ...createdData,
        createdAt: (
          createdData.createdAt as Timestamp
        ).toDate().toISOString(),
      };
    } catch (e) {
      console.error(
        `[Subtask] Error adding subtask to task ${parentTaskId}`,
        e
      );
      if (e instanceof HttpsError) {
        throw e;
      }
      throw new HttpsError("internal", "Не удалось добавить подзадачу.");
    }
  }
);

// === НОВАЯ ФУНКЦИЯ: deleteSubtask ===
export const deleteSubtask = onCall(
  commonRuntimeOpts,
  async (
    request: CallableRequest<DeleteSubtaskPayload>
  ): Promise<SuccessResponse> => {
    const uid = assertAuthenticated(request.auth);
    const {parentTaskId, subtaskId} = request.data;

    if (!parentTaskId || !subtaskId) {
      throw new HttpsError(
        "invalid-argument",
        "Parent taskId and subtaskId are required."
      );
    }

    const parentTaskRef = db.collection(TASKS_COLLECTION).doc(parentTaskId);
    const subtaskRef = parentTaskRef
      .collection(SUBTASKS_COLLECTION)
      .doc(subtaskId);

    try {
      await db.runTransaction(async (t) => {
        const parentTaskDoc = await t.get(parentTaskRef);
        if (!parentTaskDoc.exists) {
          // Если родительской задачи нет, то и подзадачи нет.
          // Просто выходим.
          console.warn(
            `[Subtask] Parent task ${parentTaskId} not found ` +
            "during subtask deletion. Skipping."
          );
          return;
        }
        // Проверяем права на родительскую задачу
        await assertPersonalWorkspaceOwner(
          (parentTaskDoc.data() as TaskDocument).workspaceId,
          uid
        );

        const subtaskDoc = await t.get(subtaskRef);
        if (subtaskDoc.exists) {
          t.delete(subtaskRef);
          // КЛЮЧЕВОЙ МОМЕНТ: Обновляем updatedAt у родителя
          t.update(parentTaskRef, {updatedAt: FieldValue.serverTimestamp()});
        }
      });

      console.info(
        `[Subtask] Subtask ${subtaskId} of task ${parentTaskId} was deleted.`
      );

      return {success: true, message: "Подзадача удалена."};
    } catch (e) {
      console.error(
        `[Subtask] Error deleting subtask ${subtaskId} for task ` +
        parentTaskId,
        e
      );
      if (e instanceof HttpsError) {
        throw e;
      }
      throw new HttpsError("internal", "Не удалось удалить подзадачу.");
    }
  }
);


// ----- FILE: A:\Progects\Progress Quest Universal\progressquest-backend\functions\src\http\teams.ts -----


// ----- FILE: A:\Progects\Progress Quest Universal\progressquest-backend\functions\src\http\users.ts -----
import {
  HttpsError,
  onCall,
  CallableRequest,
} from "firebase-functions/v2/https";
import {
  getFirestore,
  FieldValue,
  Timestamp,
  WriteBatch,
} from "firebase-admin/firestore";
import {getAuth} from "firebase-admin/auth";
import * as functions from "firebase-functions";
import {PubSub} from "@google-cloud/pubsub";

import {
  commonRuntimeOpts,
  USERS_COLLECTION,
  USER_EVENTS_TOPIC,
  WORKSPACES_COLLECTION,
  TASKS_COLLECTION,
  GAMIFICATION_PROFILES_COLLECTION,
  GLOBAL_STATISTICS_COLLECTION,
} from "../config";
import {assertAuthenticated} from "../utils";
import {
  UserDocument,
  FcmTokenDocument,
  WorkspaceDocument,
  TaskDocument,
  ActiveItems,
} from "../types/firestore.types";
import {
  GetUserProfileResponse,
  UpdateUserProfilePayload,
  UpdateUserProfileResponse,
  UpdateUserAppSettingsPayload,
  UpdateUserAppSettingsResponse,
  UpdateUserPomodoroSettingsPayload,
  UpdateUserPomodoroSettingsResponse,
  UpdateUserActiveItemsPayload,
  UpdateUserActiveItemsResponse,
  SuccessResponse,
  SendPasswordResetEmailPayload,
  RegisterFcmTokenPayload,
  UnregisterFcmTokenPayload,
  MigrateGuestDataPayload,
  MigrateGuestDataResponse,
} from "../types/api.types";
import {UserProfileUpdatedEventData} from "../types/events.types";

const db = getFirestore();
const authAdmin = getAuth();
const pubsub = new PubSub();
const logger = functions.logger;
const FIRESTORE_BATCH_LIMIT = 500;

// --- Профиль и Настройки ---

const delay = (ms: number) => new Promise((res) => setTimeout(res, ms));

export const getCurrentUserProfile = onCall(
  commonRuntimeOpts,
  async (request: CallableRequest): Promise<GetUserProfileResponse> => {
    const uid = assertAuthenticated(request.auth);
    const userDocRef = db.collection(USERS_COLLECTION).doc(uid);

    try {
      let userDoc = await userDocRef.get();
      let attempts = 0;
      const maxAttempts = 5;
      const retryDelay = 500;

      while (!userDoc.exists && attempts < maxAttempts) {
        attempts++;
        logger.warn(
          `[Users] Profile for user ${uid} not found on attempt ${attempts}. ` +
          `Retrying in ${retryDelay}ms...`
        );
        await delay(retryDelay);
        userDoc = await userDocRef.get();
      }

      if (!userDoc.exists) {
        logger.error(
          `[Users] Profile for user ${uid} not found ` +
          `after ${maxAttempts} attempts.`
        );
        throw new HttpsError(
          "not-found",
          "Профиль пользователя не найден. Пожалуйста, попробуйте войти снова."
        );
      }

      const userData = userDoc.data() as UserDocument;
      const clientProfile = {
        ...userData,
        createdAt: (userData.createdAt as Timestamp).toDate()
          .toISOString(),
        lastLoginAt: (userData.lastLoginAt as Timestamp).toDate()
          .toISOString(),
      };

      return {
        userProfile: clientProfile,
      } as unknown as GetUserProfileResponse;
    } catch (error: unknown) {
      logger.error(`[Users] Error fetching profile for ${uid}:`, error);
      if (error instanceof HttpsError) {
        throw error;
      }
      throw new HttpsError(
        "internal",
        "Ошибка получения профиля.",
        (error as Error).message
      );
    }
  }
);

export const updateUserProfile = onCall(
  commonRuntimeOpts,
  async (
    request: CallableRequest<UpdateUserProfilePayload>
  ): Promise<UpdateUserProfileResponse> => {
    const uid = assertAuthenticated(request.auth);
    const data = request.data;
    const userDocRef = db.collection(USERS_COLLECTION).doc(uid);

    const updates: Partial<Pick<UserDocument, "displayName" | "avatarUrl">> =
      {};
    const updatedFields: Array<
      keyof Pick<UserDocument, "displayName" | "avatarUrl">
    > = [];

    if (typeof data.displayName === "string") {
      updates.displayName = data.displayName.trim();
      updatedFields.push("displayName");
    }
    if (data.avatarUrl !== undefined) {
      updates.avatarUrl = data.avatarUrl;
      updatedFields.push("avatarUrl");
    }

    if (updatedFields.length === 0) {
      throw new HttpsError("invalid-argument", "Нет данных для обновления.");
    }
    (updates as any).lastLoginAt = FieldValue.serverTimestamp();

    try {
      await userDocRef.update(updates);
      const authUpdates: {displayName?: string; photoURL?: string | null} = {};
      if (updates.displayName) {
        authUpdates.displayName = updates.displayName;
      }
      if (updates.avatarUrl !== undefined) {
        authUpdates.photoURL = updates.avatarUrl;
      }
      if (Object.keys(authUpdates).length > 0) {
        await authAdmin.updateUser(uid, authUpdates);
      }

      const eventPayload: UserProfileUpdatedEventData = {
        userId: uid,
        updatedFields,
      };
      await pubsub.topic(USER_EVENTS_TOPIC).publishMessage({
        json: {
          eventType: "USER_PROFILE_UPDATED",
          data: eventPayload,
          eventTimestamp: new Date().toISOString(),
        },
      });

      const updatedDoc = await userDocRef.get();
      const updatedData = updatedDoc.data() as UserDocument;
      return {
        success: true,
        updatedProfile: {
          ...updatedData,
          createdAt: (updatedData.createdAt as Timestamp).toDate()
            .toISOString(),
          lastLoginAt: (
            updatedData.lastLoginAt as Timestamp
          ).toDate().toISOString(),
        },
      } as unknown as UpdateUserProfileResponse;
    } catch (error) {
      logger.error(`[Users] Error updating profile for ${uid}:`, error);
      if (error instanceof HttpsError) {
        throw error;
      }
      throw new HttpsError(
        "internal",
        "Ошибка обновления профиля.",
        (error as Error).message
      );
    }
  }
);

export const updateUserAppSettings = onCall(
  commonRuntimeOpts,
  async (
    request: CallableRequest<UpdateUserAppSettingsPayload>
  ): Promise<UpdateUserAppSettingsResponse> => {
    const uid = assertAuthenticated(request.auth);
    const data = request.data;
    if (Object.keys(data).length === 0) {
      throw new HttpsError("invalid-argument", "Нет данных для обновления.");
    }
    try {
      await db
        .collection(USERS_COLLECTION)
        .doc(uid)
        .set({appSettings: data}, {merge: true});
      logger.log(`[Users] App settings updated for user ${uid}.`);
      const updatedDoc = await db.collection(USERS_COLLECTION).doc(uid).get();
      const newSettings = (updatedDoc.data() as UserDocument).appSettings;
      return {success: true, appSettings: newSettings};
    } catch (error: any) {
      logger.error(`[Users] Error updating app settings for ${uid}:`, error);
      throw new HttpsError(
        "internal",
        "Ошибка обновления настроек.",
        error.message
      );
    }
  }
);

export const updateUserPomodoroSettings = onCall(
  commonRuntimeOpts,
  async (
    request: CallableRequest<UpdateUserPomodoroSettingsPayload>
  ): Promise<UpdateUserPomodoroSettingsResponse> => {
    const uid = assertAuthenticated(request.auth);
    const data = request.data;
    if (Object.keys(data).length === 0) {
      throw new HttpsError("invalid-argument", "Нет данных для обновления.");
    }
    try {
      await db
        .collection(USERS_COLLECTION)
        .doc(uid)
        .set({pomodoroSettings: data}, {merge: true});
      logger.log(`[Users] Pomodoro settings updated for user ${uid}.`);
      const updatedDoc = await db.collection(USERS_COLLECTION).doc(uid).get();
      const newSettings = (updatedDoc.data() as UserDocument).pomodoroSettings;
      return {success: true, pomodoroSettings: newSettings};
    } catch (error: any) {
      logger.error(
        `[Users] Error updating pomodoro settings for ${uid}:`,
        error
      );
      throw new HttpsError(
        "internal",
        "Ошибка обновления настроек.",
        error.message
      );
    }
  }
);

export const updateUserActiveItems = onCall(
  commonRuntimeOpts,
  async (
    request: CallableRequest<UpdateUserActiveItemsPayload>
  ): Promise<UpdateUserActiveItemsResponse> => {
    const uid = assertAuthenticated(request.auth);
    const data = request.data;
    const updates: {[key: string]: any} = {};

    if (data.workspaceId !== undefined) {
      updates["activeItems.workspaceId"] = data.workspaceId;
    }
    if (data.viewId !== undefined) {
      updates["activeItems.viewId"] = data.viewId;
    }

    if (Object.keys(updates).length === 0) {
      throw new HttpsError("invalid-argument", "Нет данных для обновления.");
    }

    try {
      await db.collection(USERS_COLLECTION).doc(uid).update(updates);
      logger.log(`[Users] Active items updated for user ${uid}.`);
      const userDoc = await db.collection(USERS_COLLECTION).doc(uid).get();
      const activeItems = (userDoc.data() as UserDocument)?.activeItems || {
        workspaceId: null,
        viewId: null,
      };
      return {success: true, activeItems: activeItems as ActiveItems};
    } catch (error: any) {
      logger.error(`[Users] Error updating active items for ${uid}:`, error);
      throw new HttpsError(
        "internal",
        "Ошибка обновления активных элементов.",
        error.message
      );
    }
  }
);

// --- Управление Учетными Данными ---

export const sendPasswordResetEmail = onCall(
  commonRuntimeOpts,
  async (
    request: CallableRequest<SendPasswordResetEmailPayload>
  ): Promise<SuccessResponse> => {
    const email = request.data.email;
    if (!email || !/.+@.+\..+/.test(email)) {
      throw new HttpsError(
        "invalid-argument",
        "Предоставлен некорректный email."
      );
    }
    try {
      await authAdmin.getUserByEmail(email);
      logger.log(
        `[Users] Password reset request for existing user: ${email}. ` +
        "NOTE: Actual email sending is not implemented."
      );
      return {
        success: true,
        message: "Если пользователь существует, ему будет отправлено письмо.",
      };
    } catch (error: any) {
      if (error.code === "auth/user-not-found") {
        logger.warn(
          `[Users] Password reset requested for non-existent email: ${email}`
        );
        return {
          success: true,
          message: "Если пользователь существует, ему будет отправлено письмо.",
        };
      }
      logger.error(
        `[Users] Error during password reset request for ${email}:`,
        error
      );
      throw new HttpsError(
        "internal",
        "Произошла ошибка при сбросе пароля.",
        error.message
      );
    }
  }
);

export const registerFcmToken = onCall(
  commonRuntimeOpts,
  async (
    request: CallableRequest<RegisterFcmTokenPayload>
  ): Promise<SuccessResponse> => {
    const uid = assertAuthenticated(request.auth);
    const {token, platform, deviceName} = request.data;
    if (!token) {
      throw new HttpsError("invalid-argument", "FCM токен обязателен.");
    }

    const tokenRef = db
      .collection(USERS_COLLECTION)
      .doc(uid)
      .collection("fcmTokens")
      .doc(token);
    const now = Timestamp.now();
    const tokenDoc: FcmTokenDocument = {
      token,
      platform: platform || "unknown",
      createdAt: now,
      lastUsedAt: now,
      ...(deviceName && {deviceName}),
    };

    try {
      await tokenRef.set(tokenDoc, {merge: true});
      logger.log(`[Users] FCM token registered/updated for UID: ${uid}`);
      return {success: true};
    } catch (error: any) {
      logger.error(`[Users] Error reg FCM token for UID ${uid}:`, error);
      throw new HttpsError(
        "internal",
        "Не удалось зарегистрировать токен.",
        error.message
      );
    }
  }
);

export const unregisterFcmToken = onCall(
  commonRuntimeOpts,
  async (
    request: CallableRequest<UnregisterFcmTokenPayload>
  ): Promise<SuccessResponse> => {
    const uid = assertAuthenticated(request.auth);
    const {token} = request.data;
    if (!token) {
      throw new HttpsError("invalid-argument", "FCM токен обязателен.");
    }

    const tokenRef = db
      .collection(USERS_COLLECTION)
      .doc(uid)
      .collection("fcmTokens")
      .doc(token);

    try {
      await tokenRef.delete();
      logger.log(`[Users] FCM token unregistered for UID: ${uid}`);
      return {success: true};
    } catch (error: any) {
      logger.error(
        `[Users] Error unregistering FCM token for UID ${uid}:`,
        error
      );
      throw new HttpsError(
        "internal",
        "Не удалось удалить регистрацию токена.",
        error.message
      );
    }
  }
);

// --- Специализированные Операции ---

/**
 * Удаляет основные документы пользователя из Firestore.
 * @param {string} uid UID пользователя.
 */
async function deleteUserData(uid: string) {
  logger.info(`[Users:deleteUserData] Deleting core documents for ${uid}`);
  const batch = db.batch();
  batch.delete(db.collection(USERS_COLLECTION).doc(uid));
  batch.delete(db.collection(GAMIFICATION_PROFILES_COLLECTION).doc(uid));
  batch.delete(db.collection(GLOBAL_STATISTICS_COLLECTION).doc(uid));
  await batch.commit();
}

export const requestAccountDeletion = onCall(
  commonRuntimeOpts,
  async (request: CallableRequest): Promise<SuccessResponse> => {
    const uid = assertAuthenticated(request.auth);
    logger.warn(
      `[Users] Account deletion requested by UID: ${uid}. This is irreversible.`
    );
    try {
      await deleteUserData(uid);
      await authAdmin.deleteUser(uid);
      logger.log(
        `[Users] Account for UID: ${uid} has been successfully deleted.`
      );
      return {success: true, message: "Аккаунт успешно удален."};
    } catch (error: any) {
      logger.error(
        `[Users] CRITICAL: Failed during account deletion for UID ${uid}:`,
        error
      );
      if (error instanceof HttpsError) {
        throw error;
      }
      throw new HttpsError(
        "internal",
        "Произошла критическая ошибка при удалении аккаунта.",
        error.message
      );
    }
  }
);

export const migrateGuestData = onCall(
  {...commonRuntimeOpts, timeoutSeconds: 300},
  async (
    request: CallableRequest<MigrateGuestDataPayload>
  ): Promise<MigrateGuestDataResponse> => {
    const uid = assertAuthenticated(request.auth);
    const data = request.data;
    if (!data.workspaces || !Array.isArray(data.workspaces)) {
      throw new HttpsError(
        "invalid-argument",
        "Отсутствует или некорректен массив рабочих пространств."
      );
    }
    logger.log(
      `[Users] Starting guest data migration for UID: ${uid}. ` +
      `Workspaces to migrate: ${data.workspaces.length}`
    );

    const idMappings: {
      workspaces: Record<string, string>;
      tasks: Record<string, string>;
    } = {workspaces: {}, tasks: {}};

    const now = FieldValue.serverTimestamp();
    const batches: WriteBatch[] = [db.batch()];
    let currentBatchIndex = 0;
    let operationCount = 0;

    try {
      for (const ws of data.workspaces) {
        if (operationCount >= FIRESTORE_BATCH_LIMIT - 10) {
          batches.push(db.batch());
          currentBatchIndex++;
          operationCount = 0;
        }

        const newWsRef = db.collection(WORKSPACES_COLLECTION).doc();
        idMappings.workspaces[ws.localId] = newWsRef.id;
        const newWsData: Omit<WorkspaceDocument, "id"> = {
          name: ws.name,
          description: ws.description || null,
          ownerUid: uid,
          isPersonal: true,
          teamId: null,
          createdAt: now,
          updatedAt: now,
          activeApproach: ws.activeApproach || "CALENDAR",
          defaultTags: [],
          settings: {
            allowMembersToCreateTasks: true,
            taskVisibility: "all_visible",
          },
          lastClientSyncTimestamp: null,
          syncStatus: "synced",
        };
        batches[currentBatchIndex].set(newWsRef, newWsData);
        operationCount++;

        for (const task of ws.tasks) {
          if (operationCount >= FIRESTORE_BATCH_LIMIT) {
            batches.push(db.batch());
            currentBatchIndex++;
            operationCount = 0;
          }
          const newTaskRef = db.collection(TASKS_COLLECTION).doc();
          idMappings.tasks[task.localId] = newTaskRef.id;
          const newTaskData: Omit<TaskDocument, "id"> = {
            title: task.title,
            description: task.description || null,
            status: "TODO",
            priority: task.priority || "MEDIUM",
            dueDate: task.dueDate ?
              Timestamp.fromMillis(Number(task.dueDate)) :
              null,
            createdAt: now,
            updatedAt: now,
            completedAt: null,
            creatorUid: uid,
            assigneeUid: uid,
            workspaceId: newWsRef.id,
            tags: task.tags || [],
            pomodoroEstimatedCycles: null,
            pomodoroEstimatedMinutes: task.pomodoroEstimatedMinutes || null,
            approachParams: null,
            orderInList: 0,
            lastSyncClientTimestamp: null,
            localId: task.localId,
          };
          batches[currentBatchIndex].set(newTaskRef, newTaskData);
          operationCount++;
        }
      }

      await Promise.all(batches.map((b) => b.commit()));
      logger.log(`[Users] Guest data migration successful for UID: ${uid}.`);
      return {success: true, idMappings};
    } catch (error: any) {
      logger.error(
        `[Users] Error during guest data migration for UID ${uid}:`,
        error
      );
      throw new HttpsError(
        "internal",
        "Ошибка миграции данных.",
        error.message
      );
    }
  }
);


// ----- FILE: A:\Progects\Progress Quest Universal\progressquest-backend\functions\src\http\views.ts -----



// ----- FILE: A:\Progects\Progress Quest Universal\progressquest-backend\functions\src\http\workspaces.ts -----
import {HttpsError, onCall} from "firebase-functions/v2/https";
import {
  getFirestore,
  FieldValue,
  Timestamp,
} from "firebase-admin/firestore";
import {
  commonRuntimeOpts,
  WORKSPACES_COLLECTION,
  USERS_COLLECTION,
  GLOBAL_STATISTICS_COLLECTION,
  WORKSPACE_EVENTS_TOPIC,
} from "../config";
import {
  assertAuthenticated,
  assertTeamRole,
  assertWorkspaceRole,
} from "../utils";
import {
  WorkspaceDocument,
  UserDocument,
  WorkspaceMemberDocument,
} from "../types/firestore.types";
import {
  CreateWorkspacePayload,
  WorkspaceClientDto,
  GetUserWorkspacesResponse,
  GetWorkspaceDetailsPayload,
  GetWorkspaceDetailsResponse,
  UpdateWorkspacePayload,
  UpdateWorkspaceResponse,
  DeleteWorkspacePayload,
  SuccessResponse,
  CreateWorkspaceResponse,
} from "../types/api.types";
import {
  WorkspaceCreatedEventData,
  WorkspaceUpdatedEventData,
  WorkspaceDeletedEventData,
} from "../types/events.types";
import {PubSub} from "@google-cloud/pubsub";

const db = getFirestore();
const pubsub = new PubSub();

export const createWorkspace = onCall(
  commonRuntimeOpts,
  async (request) => {
    const uid = assertAuthenticated(request.auth);
    const data = request.data as CreateWorkspacePayload;

    if (!data.name || data.name.trim().length === 0) {
      throw new HttpsError(
        "invalid-argument",
        "Название пространства обязательно."
      );
    }
    if (!data.isPersonal && !data.teamId) {
      throw new HttpsError(
        "invalid-argument",
        "Для командного пространства необходим ID команды."
      );
    }

    const now = FieldValue.serverTimestamp();
    const newWorkspaceRef = db.collection(WORKSPACES_COLLECTION).doc();

    const newWorkspaceData: Omit<WorkspaceDocument, "id"> = {
      name: data.name.trim(),
      description: data.description?.trim() || null,
      ownerUid: uid,
      isPersonal: data.isPersonal,
      teamId: data.isPersonal ? null : data.teamId || null,
      createdAt: now,
      updatedAt: now,
      activeApproach: data.activeApproach || "CALENDAR",
      defaultTags: data.defaultTags || [],
      settings: data.settings || {},
      lastClientSyncTimestamp: null,
      syncStatus: data.isPersonal ? "pending_upload" : null,
    };

    try {
      if (!data.isPersonal && data.teamId) {
        await assertTeamRole(data.teamId, uid, ["owner", "admin"]);
      }

      await newWorkspaceRef.set(newWorkspaceData);

      const userStatsUpdate: {[key: string]: any} = {};
      if (data.isPersonal) {
        userStatsUpdate.totalPersonalWorkspacesCreated =
          FieldValue.increment(1);
      }

      if (data.isPersonal && Object.keys(userStatsUpdate).length > 0) {
        const userGlobalStatsRef = db
          .collection(GLOBAL_STATISTICS_COLLECTION)
          .doc(uid);
        await userGlobalStatsRef.set(userStatsUpdate, {merge: true});
      }

      const eventPayload: WorkspaceCreatedEventData = {
        workspaceId: newWorkspaceRef.id,
        ownerUid: uid,
        teamId: newWorkspaceData.teamId,
        isPersonal: newWorkspaceData.isPersonal,
        workspaceName: newWorkspaceData.name,
      };
      await pubsub.topic(WORKSPACE_EVENTS_TOPIC).publishMessage({
        json: {
          eventType: "WORKSPACE_CREATED",
          data: eventPayload,
          eventTimestamp: new Date().toISOString(),
        },
      });

      console.log(
        `[WS] Workspace created: ${newWorkspaceRef.id} by user ${uid}`
      );
      const createdDoc = await newWorkspaceRef.get();
      const createdData = createdDoc.data() as WorkspaceDocument;

      return {
        workspace: {
          id: newWorkspaceRef.id,
          ...createdData,
          createdAt: (
            createdData.createdAt as Timestamp
          ).toDate().toISOString(),
          updatedAt: (
            createdData.updatedAt as Timestamp
          ).toDate().toISOString(),
          lastClientSyncTimestamp: null,
          syncStatus: createdData.syncStatus,
        },
      } as CreateWorkspaceResponse;
    } catch (error: any) {
      console.error(
        `[WS] Error creating workspace for user ${uid}:`,
        error
      );
      if (error instanceof HttpsError) {
        throw error;
      }
      throw new HttpsError(
        "internal",
        "Не удалось создать пространство.",
        error.message
      );
    }
  }
);

export const getUserWorkspaces = onCall(
  commonRuntimeOpts,
  async (request) => {
    const userUID = assertAuthenticated(request.auth);
    const clientWorkspaces: WorkspaceClientDto[] = [];

    try {
      // --- ИЗМЕНЕНИЕ НАЧАЛО: Оптимизированная логика запросов ---

      // 1. Запрос личных рабочих пространств
      const personalSnapshot = await db
        .collection(WORKSPACES_COLLECTION)
        .where("ownerUid", "==", userUID)
        .where("isPersonal", "==", true)
        .orderBy("createdAt", "desc")
        .get();

      personalSnapshot.docs.forEach((doc) => {
        const data = doc.data() as WorkspaceDocument;
        clientWorkspaces.push({
          id: doc.id,
          name: data.name,
          description: data.description,
          ownerUid: data.ownerUid,
          isPersonal: data.isPersonal,
          teamId: data.teamId,
          createdAt: (data.createdAt as Timestamp).toDate().toISOString(),
          updatedAt: (data.updatedAt as Timestamp).toDate().toISOString(),
          activeApproach: data.activeApproach,
          defaultTags: data.defaultTags,
          settings: data.settings,
          currentUserWorkspaceRole: "owner", // Владелец личного пространства
        });
      });

      // 2. Запрос командных рабочих пространств
      const userDocSnap = await db
        .collection(USERS_COLLECTION)
        .doc(userUID)
        .get();
      const userDocData = userDocSnap.data() as UserDocument | undefined;
      const teamMemberships = userDocData?.teamMemberships || [];

      if (teamMemberships.length > 0) {
        const teamIds = teamMemberships.map((m) => m.teamId);

        // Один запрос для всех командных рабочих пространств
        const teamWsSnap = await db
          .collection(WORKSPACES_COLLECTION)
          .where("teamId", "in", teamIds)
          .orderBy("name", "asc")
          .get();

        const teamRoleMap = teamMemberships.reduce((acc, m) => {
          acc[m.teamId] = m.userTeamRole;
          return acc;
        }, {} as Record<string, string>);

        teamWsSnap.docs.forEach((wsDoc) => {
          const wsData = wsDoc.data() as WorkspaceDocument;
          const userTeamRole = teamRoleMap[wsData.teamId as string] || null;

          // ВАЖНО: 로직은
          if (userTeamRole) {
            clientWorkspaces.push({
              id: wsDoc.id,
              name: wsData.name,
              description: wsData.description,
              ownerUid: wsData.ownerUid,
              isPersonal: wsData.isPersonal,
              teamId: wsData.teamId,
              createdAt: (wsData.createdAt as Timestamp).toDate().toISOString(),
              updatedAt: (wsData.updatedAt as Timestamp).toDate().toISOString(),
              activeApproach: wsData.activeApproach,
              defaultTags: wsData.defaultTags,
              settings: wsData.settings,
              currentUserWorkspaceRole:
                userTeamRole as WorkspaceMemberDocument["workspaceRole"],
            });
          }
        });
      }

      // Финальная сортировка (личные обычно новее и должны быть вверху)
      clientWorkspaces.sort((a, b) => b.createdAt.localeCompare(a.createdAt));

      return {workspaces: clientWorkspaces} as GetUserWorkspacesResponse;
    } catch (e: any) {
      console.error(`[WS] Err fetch workspaces for ${userUID}:`, e.message);
      if (e instanceof HttpsError) {
        throw e;
      }
      throw new HttpsError(
        "internal",
        "Fetch workspaces failed.",
        e.message
      );
    }
  }
);

export const getWorkspaceDetails = onCall(
  commonRuntimeOpts,
  async (request) => {
    const uid = assertAuthenticated(request.auth);
    const {workspaceId} = request.data as GetWorkspaceDetailsPayload;

    if (!workspaceId) {
      throw new HttpsError("invalid-argument", "WorkspaceId is required.");
    }
    try {
      const workspaceRef = db
        .collection(WORKSPACES_COLLECTION)
        .doc(workspaceId);
      const workspaceDoc = await workspaceRef.get();

      if (!workspaceDoc.exists) {
        throw new HttpsError(
          "not-found",
          "Рабочее пространство не найдено."
        );
      }
      const wsData = workspaceDoc.data() as WorkspaceDocument;
      let currentUserRole:
        | WorkspaceMemberDocument["workspaceRole"]
        | null = null;

      if (wsData.isPersonal) {
        if (wsData.ownerUid !== uid) {
          throw new HttpsError("permission-denied", "Доступ запрещен.");
        }
        currentUserRole = "owner";
      } else {
        const memberRef = workspaceRef.collection("members").doc(uid);
        const memberDoc = await memberRef.get();
        if (!memberDoc.exists) {
          throw new HttpsError(
            "permission-denied",
            "Вы не являетесь участником этого пространства."
          );
        }
        currentUserRole = (
          memberDoc.data() as WorkspaceMemberDocument
        ).workspaceRole;
      }

      const responseWorkspace: WorkspaceClientDto = {
        id: workspaceDoc.id,
        ...wsData,
        createdAt: (wsData.createdAt as Timestamp).toDate().toISOString(),
        updatedAt: (wsData.updatedAt as Timestamp).toDate().toISOString(),
        currentUserWorkspaceRole: currentUserRole,
      };
      return {workspace: responseWorkspace} as GetWorkspaceDetailsResponse;
    } catch (e: any) {
      console.error(`[WS] Error details for ws ${workspaceId}:`, e.message);
      if (e instanceof HttpsError) {
        throw e;
      }
      throw new HttpsError(
        "internal",
        "Failed to get details.",
        e.message
      );
    }
  }
);

export const updateWorkspace = onCall(
  commonRuntimeOpts,
  async (request) => {
    const uid = assertAuthenticated(request.auth);
    const data = request.data as UpdateWorkspacePayload;

    if (!data.workspaceId) {
      throw new HttpsError("invalid-argument", "WorkspaceId is required.");
    }

    const workspaceRef = db
      .collection(WORKSPACES_COLLECTION)
      .doc(data.workspaceId);
    const updates: Partial<
      Omit<
        WorkspaceDocument,
        "id" | "createdAt" | "ownerUid" | "isPersonal" | "teamId"
      >
    > & {updatedAt: FieldValue} = {
      updatedAt: FieldValue.serverTimestamp(),
    };

    if (data.name !== undefined) {
      updates.name = data.name;
    }
    if (data.description !== undefined) {
      updates.description = data.description;
    }
    if (data.activeApproach !== undefined) {
      updates.activeApproach = data.activeApproach;
    }
    if (data.defaultTags !== undefined) {
      updates.defaultTags = data.defaultTags;
    }
    if (data.settings !== undefined) {
      updates.settings = data.settings;
    }

    if (Object.keys(updates).length === 1 && "updatedAt" in updates) {
      throw new HttpsError("invalid-argument", "Нет данных для обновления.");
    }

    try {
      const wsDoc = await workspaceRef.get();
      if (!wsDoc.exists) {
        throw new HttpsError("not-found", "Workspace not found.");
      }
      const wsData = wsDoc.data() as WorkspaceDocument;

      if (wsData.isPersonal && wsData.ownerUid !== uid) {
        throw new HttpsError("permission-denied", "Permission denied.");
      }
      if (!wsData.isPersonal) {
        await assertWorkspaceRole(data.workspaceId, uid, [
          "owner",
          "admin",
          "manager",
        ]);
      }

      await workspaceRef.update(updates);

      const eventPayload: WorkspaceUpdatedEventData = {
        workspaceId: data.workspaceId,
        updatedFields: Object.keys(updates).filter(
          (k) => k !== "updatedAt"
        ) as Array<keyof WorkspaceDocument>,
        updatedByUid: uid,
      };
      await pubsub.topic(WORKSPACE_EVENTS_TOPIC).publishMessage({
        json: {
          eventType: "WORKSPACE_UPDATED",
          data: eventPayload,
          eventTimestamp: new Date().toISOString(),
        },
      });

      const updatedDoc = await workspaceRef.get();
      const updatedWsData = updatedDoc.data() as WorkspaceDocument;
      return {
        success: true,
        updatedWorkspace: {
          id: updatedDoc.id,
          ...updatedWsData,
          createdAt: (
            updatedWsData.createdAt as Timestamp
          ).toDate().toISOString(),
          updatedAt: (
            updatedWsData.updatedAt as Timestamp
          ).toDate().toISOString(),
        },
      } as UpdateWorkspaceResponse;
    } catch (e: any) {
      console.error(`[WS] Error updating ws ${data.workspaceId}:`, e.message);
      if (e instanceof HttpsError) {
        throw e;
      }
      throw new HttpsError(
        "internal",
        "Failed to update workspace.",
        e.message
      );
    }
  }
);

export const deleteWorkspace = onCall(
  commonRuntimeOpts,
  async (request) => {
    const uid = assertAuthenticated(request.auth);
    const {workspaceId} = request.data as DeleteWorkspacePayload;

    if (!workspaceId) {
      throw new HttpsError("invalid-argument", "WorkspaceId is required.");
    }
    const workspaceRef = db.collection(WORKSPACES_COLLECTION).doc(workspaceId);
    try {
      const wsDoc = await workspaceRef.get();
      if (!wsDoc.exists) {
        throw new HttpsError("not-found", "Workspace not found.");
      }
      const wsData = wsDoc.data() as WorkspaceDocument;

      if (wsData.ownerUid !== uid) {
        throw new HttpsError(
          "permission-denied",
          "Only owner can delete workspace."
        );
      }
      await workspaceRef.delete();

      const eventPayload: WorkspaceDeletedEventData = {
        workspaceId,
        teamId: wsData.teamId,
        deletedByUid: uid,
      };
      await pubsub.topic(WORKSPACE_EVENTS_TOPIC).publishMessage({
        json: {
          eventType: "WORKSPACE_DELETED",
          data: eventPayload,
          eventTimestamp: new Date().toISOString(),
        },
      });

      console.log(`[WS] Workspace ${workspaceId} deleted by user ${uid}`);
      return {
        success: true,
        message: "Рабочее пространство удалено.",
      } as SuccessResponse;
    } catch (e: any) {
      console.error(`[WS] Error deleting ws ${workspaceId}:`, e.message);
      if (e instanceof HttpsError) {
        throw e;
      }
      throw new HttpsError(
        "internal",
        "Failed to delete workspace.",
        e.message
      );
    }
  }
);


// ----- FILE: A:\Progects\Progress Quest Universal\progressquest-backend\functions\src\pubsub\index.ts -----
export * from "./pomodoroEventHandlers";
export * from "./taskEventHandlers";
export * from "./userEventHandlers";


// ----- FILE: A:\Progects\Progress Quest Universal\progressquest-backend\functions\src\pubsub\pomodoroEventHandlers.ts -----
import {onMessagePublished} from "firebase-functions/v2/pubsub";
import {getFirestore, FieldValue, Timestamp} from "firebase-admin/firestore";
import {
  POMODORO_EVENTS_TOPIC,
  TASK_STATISTICS_COLLECTION,
  GAMIFICATION_PROFILES_COLLECTION,
  GLOBAL_STATISTICS_COLLECTION,
  GAMIFICATION_HISTORY_COLLECTION,
  commonRuntimeOpts,
  XP_PER_POMODORO_FOCUS_MINUTE,
  COINS_PER_XP_BATCH_POMODORO,
  XP_BATCH_FOR_COIN_POMODORO,
  MIN_FOCUS_DURATION_FOR_REWARD_SECONDS,
} from "../config";
import {
  GamificationHistoryEntryDocument,
} from "../types/firestore.types";
import {PomodoroPhaseCompletedEventData} from "../types/events.types";

const db = getFirestore();

export const onPomodoroPhaseCompletedUpdateGamificationAndStats =
  onMessagePublished(
    {topic: POMODORO_EVENTS_TOPIC, ...commonRuntimeOpts},
    async (event) => {
      if (!event.data.message?.json) {
        console.warn(
          "[PomoEventHandler] PubSub message for topic " + // quotes
            POMODORO_EVENTS_TOPIC +
            " missing JSON payload. Event ID:",
          event.id
        );
        return;
      }

      const phaseEventData = event.data.message
        .json as PomodoroPhaseCompletedEventData;
      const eventTimestamp = event.time;

      // Для строки 28, если ошибка quotes все еще там:
      console.log(
        "[PomoEventHandler] Processing POMODORO_PHASE_COMPLETED event " +
          "for session: " + // quotes
          phaseEventData.sessionId
      );

      const {
        userId,
        taskId,
        phaseType,
        actualDurationSeconds,
        completed,
      } = phaseEventData;

      if (
        phaseType !== "FOCUS" ||
        !completed ||
        actualDurationSeconds < MIN_FOCUS_DURATION_FOR_REWARD_SECONDS
      ) {
        // Для строки 40, если ошибка quotes все еще там:
        console.log(
          "[PomoEventHandler] Skipping gamification/stats update for " +
            "session " + // quotes
            phaseEventData.sessionId +
            ": Not a qualifying focus phase. Type: " +
            phaseType +
            ", Completed: " + // quotes
            completed +
            ", Duration: " + // quotes
            actualDurationSeconds +
            "s."
        );
        return;
      }

      const batch = db.batch();
      const serverTimestamp = FieldValue.serverTimestamp();

      const taskStatsRef = db
        .collection(TASK_STATISTICS_COLLECTION)
        .doc(taskId);
      batch.set(
        taskStatsRef,
        {
          totalPomodoroFocusSeconds: FieldValue.increment(
            actualDurationSeconds
          ),
          completedPomodoroFocusSessions: FieldValue.increment(1),
          updatedAt: serverTimestamp,
        },
        {merge: true}
      );

      const gamificationProfileRef = db
        .collection(GAMIFICATION_PROFILES_COLLECTION)
        .doc(userId);

      const minutesInFocus = Math.floor(actualDurationSeconds / 60);
      const xpAwarded = minutesInFocus * XP_PER_POMODORO_FOCUS_MINUTE;
      const coinsAwarded =
        Math.floor(xpAwarded / XP_BATCH_FOR_COIN_POMODORO) *
        COINS_PER_XP_BATCH_POMODORO;

      if (xpAwarded > 0 || coinsAwarded > 0) {
        batch.update(gamificationProfileRef, {
          experience: FieldValue.increment(xpAwarded),
          coins: FieldValue.increment(coinsAwarded),
          lastPomodoroCompletionTime: Timestamp.fromDate(
            new Date(eventTimestamp)
          ),
        });
      }

      const globalStatsRef = db
        .collection(GLOBAL_STATISTICS_COLLECTION)
        .doc(userId);
      batch.update(globalStatsRef, {
        totalPomodoroFocusMinutes: FieldValue.increment(minutesInFocus),
        lastActive: serverTimestamp,
      });

      if (xpAwarded > 0 || coinsAwarded > 0) {
        const historyRef = db.collection(GAMIFICATION_HISTORY_COLLECTION).doc();
        const historyEntry: GamificationHistoryEntryDocument = {
          userId,
          timestamp: serverTimestamp,
          eventType: "POMODORO_FOCUS_PHASE",
          xpChange: xpAwarded,
          coinsChange: coinsAwarded,
          relatedEntityId: taskId,
          relatedEntityType: "task",
          description:
            "Завершена фокус-сессия Pomodoro (" +
            minutesInFocus + // quotes
            " мин) для задачи ID: " +
            taskId.substring(0, 5) + // quotes
            "...",
        };
        batch.set(historyRef, historyEntry);
      }

      console.log(
        "[PomoEventHandler] TODO: Implement challenge checks for Pomodoro " +
          "event."
      );

      console.log(
        "[PomoEventHandler] TODO: Implement plant growth for Pomodoro event."
      );

      try {
        await batch.commit();
        console.log(
          "[PomoEventHandler] Gamification & stats updated successfully for " +
            "pomodoro session: " + // quotes
            phaseEventData.sessionId
        );
      } catch (error) {
        console.error(
          "[PomoEventHandler] Error committing batch for pomodoro session " +
            phaseEventData.sessionId + // quotes
            ":",
          error
        );
        throw error;
      }
    }
  );


// ----- FILE: A:\Progects\Progress Quest Universal\progressquest-backend\functions\src\pubsub\taskEventHandlers.ts -----
import {onMessagePublished} from "firebase-functions/v2/pubsub";
import {
  getFirestore,
  FieldValue,
  Timestamp,
  PartialWithFieldValue,
} from "firebase-admin/firestore";
import {
  TASK_EVENTS_TOPIC,
  TASK_STATISTICS_COLLECTION,
  GAMIFICATION_PROFILES_COLLECTION,
  GLOBAL_STATISTICS_COLLECTION,
  GAMIFICATION_HISTORY_COLLECTION,
  commonRuntimeOpts,
  XP_FOR_TASK_COMPLETION,
  COINS_FOR_TASK_COMPLETION,
  TASKS_COLLECTION,
  SUBTASKS_COLLECTION,
  WORKSPACES_COLLECTION,
  DELETED_ENTITIES_COLLECTION,
} from "../config";
import {
  TaskStatisticsDocument,
  GamificationHistoryEntryDocument,
  DeletedEntityDocument,
  TaskDocument,
  WorkspaceDocument,
} from "../types/firestore.types";
import {TaskStatusUpdatedEventData} from "../types/events.types";
import {updateChallengeProgress} from "../gamification/challengeProcessor";
import {
  onDocumentDeleted,
  onDocumentWritten,
} from "firebase-functions/firestore";

const db = getFirestore();

export const onTaskStatusUpdatedProcessGamification = onMessagePublished(
  {topic: TASK_EVENTS_TOPIC, ...commonRuntimeOpts},
  async (event) => {
    if (!event.data.message?.json) {
      console.warn(
        "[TaskEventHandler] PubSub message missing JSON payload.",
        {eventId: event.id}
      );
      return;
    }

    const taskEvent = event.data.message.json as {
      eventType: string;
      data: any;
    };
    if (taskEvent.eventType !== "TASK_STATUS_UPDATED") {
      return;
    }

    const taskEventData = taskEvent.data as TaskStatusUpdatedEventData;
    const {
      taskId,
      userId,
      newStatus,
      oldStatus,
      completedAt,
      taskData,
    } = taskEventData;

    console.log(
      `[TaskEventHandler] Processing event for task: ${taskId}, ` +
      `newStatus: ${newStatus}`
    );

    if (newStatus !== "DONE" || oldStatus === "DONE") {
      console.log(
        `[TaskEventHandler] Task ${taskId} status not 'DONE' or ` +
        "was already 'DONE'. Skipping."
      );
      return;
    }

    const serverWriteTimestamp = FieldValue.serverTimestamp();
    const completionTimestampForWrite = completedAt ?
      Timestamp.fromDate(new Date(completedAt)) :
      serverWriteTimestamp;

    try {
      await db.runTransaction(async (t) => {
        const gamificationProfileRef = db
          .collection(GAMIFICATION_PROFILES_COLLECTION)
          .doc(userId);
        const globalStatsRef = db
          .collection(GLOBAL_STATISTICS_COLLECTION)
          .doc(userId);
        const taskStatsRef = db
          .collection(TASK_STATISTICS_COLLECTION)
          .doc(taskId);
        const historyRef = db
          .collection(GAMIFICATION_HISTORY_COLLECTION)
          .doc();

        const statDoc = await t.get(taskStatsRef);
        const updateData: PartialWithFieldValue<TaskStatisticsDocument> = {
          completionTime: completionTimestampForWrite,
          wasCompletedOnce: true,
          updatedAt: serverWriteTimestamp,
        };
        if (!statDoc.exists || !statDoc.data()?.wasCompletedOnce) {
          updateData.firstCompletionTime = completionTimestampForWrite;
        }
        t.set(taskStatsRef, updateData, {merge: true});

        t.update(gamificationProfileRef, {
          experience: FieldValue.increment(XP_FOR_TASK_COMPLETION),
          coins: FieldValue.increment(COINS_FOR_TASK_COMPLETION),
          lastTaskCompletionTime: Timestamp.fromDate(new Date(event.time)),
        });

        t.update(globalStatsRef, {
          totalTasksCompleted: FieldValue.increment(1),
          lastActive: serverWriteTimestamp,
        });

        const taskTitleSubstring = (
          taskData?.title ?? "Без названия"
        ).substring(0, 30);
        const historyEntry: GamificationHistoryEntryDocument = {
          userId,
          timestamp: serverWriteTimestamp,
          eventType: "TASK_COMPLETED",
          xpChange: XP_FOR_TASK_COMPLETION,
          coinsChange: COINS_FOR_TASK_COMPLETION,
          relatedEntityId: taskId,
          relatedEntityType: "task",
          description: `Задача '${taskTitleSubstring}...' выполнена.`,
        };
        t.set(historyRef, historyEntry);

        await updateChallengeProgress({
          transaction: t,
          userId,
          eventType: "TASK_COMPLETION_COUNT",
          eventValue: 1,
          eventTimestamp: new Date(event.time),
        });
      });
      console.log(
        "[TaskEventHandler] Gamification & stats updated " +
        `successfully for task completion: ${taskId}`
      );
    } catch (error) {
      console.error(
        `[TaskEventHandler] Transaction failed for task completion ${taskId}:`,
        error
      );
      throw error;
    }
  }
);

/**
 * Триггер для "мягкого удаления". Срабатывает, когда физически удаляется.
 * Создает запись в коллекции deletedEntities.
 */
export const onTaskDocumentDeleted = onDocumentDeleted(
  {...commonRuntimeOpts, document: `${TASKS_COLLECTION}/{taskId}`},
  async (event) => {
    const deletedTaskData = event.data?.data() as TaskDocument | undefined;
    const taskId = event.params.taskId;

    if (!deletedTaskData) {
      console.warn(
        `[onTaskDelete] No data for deleted task ID: ${taskId}. Skipping.`
      );
      return;
    }

    try {
      let parentTeamId: string | null = null;
      if (deletedTaskData.workspaceId) {
        const workspaceDoc = await db
          .collection(WORKSPACES_COLLECTION)
          .doc(deletedTaskData.workspaceId)
          .get();
        if (workspaceDoc.exists) {
          const workspaceData = workspaceDoc.data() as WorkspaceDocument;
          if (!workspaceData.isPersonal) {
            parentTeamId = workspaceData.teamId;
          }
        }
      }

      const softDeleteEntry: DeletedEntityDocument = {
        entityType: "task",
        deletedAt: FieldValue.serverTimestamp(),
        userId: deletedTaskData.creatorUid,
        workspaceId: deletedTaskData.workspaceId,
        teamId: parentTeamId,
      };

      await db
        .collection(DELETED_ENTITIES_COLLECTION)
        .doc(taskId)
        .set(softDeleteEntry);
      console.info(
        `[onTaskDelete] Soft delete entry created for task: ${taskId} ` +
        `with teamId: ${parentTeamId}`
      );
    } catch (error) {
      console.error(
        `[onTaskDelete] Failed to create soft delete entry for task ${taskId}:`,
        error
      );
    }
  }
);

/**
 * Триггер, который обновляет `updatedAt` у родительской задачи
 * при любом изменении (создании, обновлении, удалении) ее подзадачи.
 */
export const onSubtaskChangeUpdateParentTask = onDocumentWritten(
  {
    ...commonRuntimeOpts,
    document: `${TASKS_COLLECTION}/{taskId}/${SUBTASKS_COLLECTION}/{subtaskId}`,
  },
  async (event) => {
    const parentTaskId = event.params.taskId;
    if (!parentTaskId) {
      return;
    }

    console.debug(
      `[onSubtaskChange] Subtask changed for task ${parentTaskId}. ` +
      "Updating parent timestamp."
    );

    const parentTaskRef = db.collection(TASKS_COLLECTION).doc(parentTaskId);
    try {
      await parentTaskRef.update({updatedAt: FieldValue.serverTimestamp()});
      console.info(
        `[onSubtaskChange] Parent task ${parentTaskId} timestamp updated.`
      );
    } catch (error) {
      console.error(
        `[onSubtaskChange] Failed to update parent task ${parentTaskId} ` +
        "timestamp:",
        error
      );
    }
  }
);


// ----- FILE: A:\Progects\Progress Quest Universal\progressquest-backend\functions\src\pubsub\userEventHandlers.ts -----
import {onMessagePublished} from "firebase-functions/v2/pubsub";
import {
  USER_EVENTS_TOPIC,
  commonRuntimeOpts,
} from "../config";
import {
  UserCreatedEventData,
} from "../types/events.types";

export const onUserCreatedProcessWelcome = onMessagePublished(
  {topic: USER_EVENTS_TOPIC, ...commonRuntimeOpts},
  async (event) => {
    if (!event.data.message?.json) {
      console.warn( // 6 пробелов от начала строки функции
        "[UserEventHandler] PubSub message for topic " +
        USER_EVENTS_TOPIC +
        " missing JSON payload. Event ID:",
        event.id
      );
      return; // 6 пробелов
    }

    const genericEventData = event.data.message.json as {eventType: string};

    switch (genericEventData.eventType) { // 4 пробела
    case "USER_CREATED": { // 6 пробелов для case, { на той же строке
      const userEventData = event.data.message // 8 пробелов
        .json as UserCreatedEventData;
      console.log( // 8 пробелов
        "[UserEventHandler] Processing USER_CREATED event for userId: " +
            userEventData.userId
      );

      console.log( // 8 пробелов
        "[UserEventHandler] Finished processing USER_CREATED for " +
            userEventData.userId +
            ". No additional actions configured for MVP."
      );
      break; // 8 пробелов
    } // 6 пробелов для закрывающей скобки case
    default: // 6 пробелов
      console.warn( // 8 пробелов
        "[UserEventHandler] Received unhandled eventType: " +
            genericEventData.eventType +
            " in topic " +
            USER_EVENTS_TOPIC +
            "."
      );
        // break; // Необязательно для default, если он последний
    }
  }
);


// ----- FILE: A:\Progects\Progress Quest Universal\progressquest-backend\functions\src\types\api.types.ts -----
import {
  UserDocument,
  AppSettings,
  PomodoroSettings,
  TaskStatusType,
  TaskPriorityType,
  CalendarApproachParams,
  GtdApproachParams,
  EisenhowerApproachParams,
  FrogApproachParams,
  PomodoroSessionType,
  ChallengeScopeType,
  ChallengeRewardType,
  ChallengePeriodType,
  ChallengeEventType,
} from "./firestore.types";

// --- Общие Типы Ответов ---
export interface SuccessResponse {
  success: boolean;
  message?: string;
  id?: string;
}

// --- 7.1. Аутентификация, Сессия и Учетные данные ---
export interface SendPasswordResetEmailPayload {
  email: string;
}

export interface RegisterFcmTokenPayload {
    token: string;
    platform: "android" | "web";
    deviceName?: string;
}

export interface UnregisterFcmTokenPayload {
    token: string;
}

// --- 7.2. Управление Профилем Пользователя ---
export interface GetUserProfileResponse {
  userProfile: UserDocument;
}

export interface UpdateUserProfilePayload {
  displayName?: string;
  avatarUrl?: string | null;
}

export interface UpdateUserProfileResponse extends SuccessResponse {
  updatedProfile: UserDocument;
}

// Используем Partial для частичных обновлений
export type UpdateUserAppSettingsPayload = Partial<AppSettings>;

export interface UpdateUserAppSettingsResponse extends SuccessResponse {
  appSettings: AppSettings;
}

export type UpdateUserPomodoroSettingsPayload = Partial<PomodoroSettings>;

export interface UpdateUserPomodoroSettingsResponse extends SuccessResponse {
  pomodoroSettings: PomodoroSettings;
}

export interface UpdateUserActiveItemsPayload {
  workspaceId?: string | null;
  viewId?: string | null;
}

export interface UpdateUserActiveItemsResponse extends SuccessResponse {
  activeItems: {
    workspaceId?: string | null;
    viewId?: string | null;
  };
}

// --- 7.3. Управление Командами ---
export interface CreateTeamPayload {
  name: string;
  description?: string | null;
  logoUrl?: string | null;
  defaultMemberRole?: "admin" | "editor" | "member" | "viewer";
}
export interface TeamClientDto {
  id: string;
  name: string;
  description: string | null;
  ownerUid: string;
  logoUrl: string | null;
  createdAt: string; // ISO Timestamp
  updatedAt: string; // ISO Timestamp
  settings: {[key: string]: any} | null;
  defaultMemberRole: "admin" | "editor" | "member" | "viewer";
}
export interface CreateTeamResponse {
  team: TeamClientDto;
}
export interface GetUserTeamsResponse {
  teams: {
    teamId: string;
    teamName: string;
    userTeamRole: "owner" | "admin" | "editor" | "member" | "viewer";
  }[];
}
export interface GetTeamDetailsPayload {
  teamId: string;
}
export interface TeamMemberClientDto {
  uid: string;
  displayName: string;
  avatarUrl: string | null;
  role: "owner" | "admin" | "editor" | "member" | "viewer";
  joinedAt: string; // ISO Timestamp
}
export interface GetTeamDetailsResponse {
  team: TeamClientDto;
  members?: TeamMemberClientDto[];
}
export interface UpdateTeamPayload {
  teamId: string;
  name?: string;
  description?: string | null;
  logoUrl?: string | null;
  settings?: {[key: string]: any} | null;
  defaultMemberRole?: string;
}
export interface UpdateTeamResponse extends SuccessResponse {
  updatedTeam: TeamClientDto;
}
export interface DeleteTeamPayload {
  teamId: string;
}
export interface AddTeamMemberPayload {
  teamId: string;
  userEmailOrUid: string;
  role: "admin" | "editor" | "member" | "viewer";
}
export interface AddTeamMemberResponse extends SuccessResponse {
  member: TeamMemberClientDto;
}
export interface UpdateTeamMemberRolePayload {
  teamId: string;
  memberUid: string;
  newRole: "admin" | "editor" | "member" | "viewer";
}
export interface UpdateTeamMemberRoleResponse extends SuccessResponse {
  updatedMember: TeamMemberClientDto;
}
export interface RemoveTeamMemberPayload {
  teamId: string;
  memberUid: string;
}

// --- 7.4. Управление Рабочими Пространствами ---
export interface CreateWorkspacePayload {
  name: string;
  description?: string | null;
  isPersonal: boolean;
  teamId?: string | null;
  activeApproach?: string;
  defaultTags?: string[];
  settings?: {[key: string]: any};
}
export interface WorkspaceClientDto {
  id: string;
  name: string;
  description: string | null;
  ownerUid: string;
  isPersonal: boolean;
  teamId: string | null;
  createdAt: string; // ISO Timestamp
  updatedAt: string; // ISO Timestamp
  activeApproach: string;
  defaultTags: string[];
  settings: {[key: string]: any};
  currentUserWorkspaceRole?:
    | "owner"
    | "admin"
    | "manager"
    | "editor"
    | "member"
    | "viewer"
    | null;
}
export interface CreateWorkspaceResponse {
  workspace: WorkspaceClientDto;
}
export interface GetUserWorkspacesResponse {
  workspaces: WorkspaceClientDto[];
}
export interface GetWorkspaceDetailsPayload {
  workspaceId: string;
}
export interface WorkspaceMemberClientDto {
  uid: string;
  displayName: string;
  avatarUrl: string | null;
  workspaceRole:
    | "owner"
    | "admin"
    | "manager"
    | "editor"
    | "member"
    | "viewer";
  addedAt: string; // ISO Timestamp
}
export interface GetWorkspaceDetailsResponse {
  workspace: WorkspaceClientDto;
  members?: WorkspaceMemberClientDto[];
}
export interface UpdateWorkspacePayload {
  workspaceId: string;
  name?: string;
  description?: string | null;
  activeApproach?: string;
  defaultTags?: string[];
  settings?: {[key: string]: any};
}
export interface UpdateWorkspaceResponse extends SuccessResponse {
  updatedWorkspace: WorkspaceClientDto;
}
export interface DeleteWorkspacePayload {
  workspaceId: string;
}

// --- 7.5. Управление Задачами ---
export interface TaskApproachParamsClientDto {
  calendar?: CalendarApproachParams;
  gtd?: GtdApproachParams;
  eisenhower?: EisenhowerApproachParams;
  frog?: FrogApproachParams;
}
export interface CreateTaskPayload {
  workspaceId: string;
  title: string;
  description?: string | null;
  dueDate?: string | number | null;
  priority?: TaskPriorityType;
  assigneeUid?: string | null;
  tags?: string[];
  approachParams?: TaskApproachParamsClientDto | null;
  pomodoroEstimatedMinutes?: number | null;
}
export interface TaskClientDto {
  id: string;
  title: string;
  description: string | null;
  status: TaskStatusType;
  priority: TaskPriorityType;
  dueDate: string | null; // ISO Timestamp
  createdAt: string; // ISO Timestamp
  updatedAt: string; // ISO Timestamp
  completedAt: string | null; // ISO Timestamp
  creatorUid: string;
  assigneeUid: string | null;
  workspaceId: string;
  tags: string[];
  pomodoroEstimatedCycles: number | null;
  pomodoroEstimatedMinutes: number | null;
  approachParams: TaskApproachParamsClientDto | null;
  orderInList: number;
}
export interface CreateTaskResponse {
  task: TaskClientDto;
}
export interface GetTasksPayload {
  viewId?: string | null;
  workspaceId?: string;
  filters?: ViewFiltersClientDto | null;
  sortBy?: string;
  sortDirection?: "asc" | "desc";
}
export interface GetTasksResponse {
  tasks: TaskClientDto[];
}
export interface GetTaskDetailsPayload {
  taskId: string;
}
export interface SubtaskClientDto {
  id: string;
  title: string;
  completed: boolean;
  order: number;
  createdAt: string; // ISO Timestamp
}
export interface CommentClientDto {
  id: string;
  authorUid: string;
  authorName: string;
  authorAvatarUrl: string | null;
  text: string;
  createdAt: string; // ISO
  updatedAt: string | null; // ISO
}
export interface GetTaskDetailsResponse {
  task: TaskClientDto;
  subtasks?: SubtaskClientDto[];
  comments?: CommentClientDto[];
}
export interface UpdateTaskPayload {
  taskId: string;
  title?: string;
  description?: string | null;
  status?: TaskStatusType;
  priority?: TaskPriorityType;
  dueDate?: string | number | null;
  assigneeUid?: string | null;
  tags?: string[];
  approachParams?: TaskApproachParamsClientDto | null;
  pomodoroEstimatedMinutes?: number | null;
}
export interface UpdateTaskResponse extends SuccessResponse {
  updatedTask: TaskClientDto;
}
export interface DeleteTaskPayload {
  taskId: string;
}
export interface CreateCommentPayload {
  taskId: string;
  text: string;
}
export interface CreateCommentResponse {
  comment: CommentClientDto;
}

// --- 7.6. Управление Pomodoro-сессиями ---
export interface StartPomodoroPhasePayload {
  taskId: string;
  workspaceId: string;
  sessionType: PomodoroSessionType;
  plannedDurationSeconds: number;
  phaseNumberInCycle?: number;
  totalFocusSessionIndex?: number;
}
export interface StartPomodoroPhaseResponse {
  sessionId: string;
}
export interface CompletePomodoroPhasePayload {
  sessionId: string;
  actualDurationSeconds: number;
  interruptions: number;
  completed: boolean;
}

// --- 7.7. Геймификация и Статистика ---
export interface GamificationProfileClientDto {
  level: number;
  experience: number;
  coins: number;
  maxExperienceForLevel: number;
  currentStreak: number;
  lastClaimedDate: string;
  maxStreak: number;
  selectedPlantId: string | null;
  lastPomodoroCompletionTime: string | null;
  lastTaskCompletionTime: string | null;
}
export interface GetGamificationProfileResponse {
  profile: GamificationProfileClientDto;
}

export interface RewardClientDto {
  type: ChallengeRewardType;
  value: string;
  badgeName?: string | null;
  badgeImageUrl?: string | null;
}

// --- Значки ---
export interface BadgeDefinitionClientDto {
    id: string;
    name: string;
    description: string;
    imageUrl: string;
    criteria: string;
    rewardXp?: number;
    rewardCoins?: number;
    isHidden?: boolean;
}

export interface GetAllBadgeDefinitionsResponseDto {
    badges: BadgeDefinitionClientDto[];
}

export interface EarnedBadgeClientDto {
  badgeDefinitionId: string;
  earnedAt: string; // ISO
  name: string;
  imageUrl: string;
  criteria: string;
}
export interface GetBadgesResponse {
  badges: EarnedBadgeClientDto[];
}

export interface CreateCustomChallengePayload {
  name: string;
  description: string;
  period: ChallengePeriodType;
  type: ChallengeEventType;
  targetValue: number;
  reward: {
    type: ChallengeRewardType;
    value: string;
    badgeName?: string | null;
    badgeImageUrl?: string | null;
  };
  conditionJson?: string | null;
}
export interface ChallengeDefinitionClientDto {
  id: string;
  name: string;
  description: string;
  creatorUid: string | "system";
  scope: ChallengeScopeType;
  targetEntityId: string | null;
  isPublicTemplate: boolean;
  reward: {
    type: ChallengeRewardType;
    value: string;
    badgeName?: string | null;
    badgeImageUrl?: string | null;
  };
  period: ChallengePeriodType;
  type: ChallengeEventType;
  targetValue: number;
  conditionJson: string | null;
  isActiveSystemChallenge?: boolean;
  createdAt: string;
  updatedAt: string;
  currentUserProgress?: {
    progress: {[key: string]: number} | number;
    isCompleted: boolean;
  };
}

export interface CreateChallengeResponse {
  challenge: ChallengeDefinitionClientDto;
}

export interface GetChallengesResponse {
  challenges: ChallengeDefinitionClientDto[];
}

export interface UpdateCustomChallengePayload
  extends Partial<Omit<CreateCustomChallengePayload, "type">> {
  challengeDefId: string;
}

export interface DeleteChallengePayload {
  challengeDefId: string;
}

// Новые DTO для сада и ежедневной награды
export interface ClaimDailyRewardResponseDto extends SuccessResponse {
  rewardReceived: RewardClientDto;
  newStreak: number;
  newXp: number;
  newCoins: number;
}

// --- Виртуальный сад ---
export interface VirtualPlantClientDto {
    id: string;
    plantType: string;
    growthStage: number;
    growthPoints: number;
    lastWateredAt: string; // ISO
    createdAt: string; // ISO
}

export interface GetVirtualGardenResponse {
    plants: VirtualPlantClientDto[];
    selectedPlantId: string | null;
}

export interface SelectPlantRequestPayload {
    plantInstanceId: string;
}

export interface WaterPlantRequestPayload {
  plantInstanceId?: string | null;
}

export interface WaterPlantResponseDto extends SuccessResponse {
  updatedPlants: VirtualPlantClientDto[];
  growthPointsAdded?: { [plantInstanceId: string]: number };
}

// --- Магазин ---
export interface StoreItemClientDto {
    id: string;
    name: string;
    description: string;
    costInCoins: number;
    category: string;
    itemValue: string;
    imageUrl: string;
    isAvailable: boolean;
}

export interface GetStoreItemsResponse {
    items: StoreItemClientDto[];
}

export interface PurchaseStoreItemPayload {
    itemId: string;
}

export interface PurchaseStoreItemResponse extends SuccessResponse {
  remainingCoins: number;
  itemReceived: StoreItemClientDto;
}

// --- 7.8. Управление "Представлениями" ---
export interface DateRangeFilterClientDto {
  start?: string | number | null;
  end?: string | number | null;
  type: "due" | "created" | "completed";
}
export interface ViewFiltersClientDto {
  status?: TaskStatusType[];
  priority?: TaskPriorityType[];
  tagsInclude?: string[];
  tagsExclude?: string[];
  dateRange?: DateRangeFilterClientDto | null;
  assignee?: "me" | "unassigned" | string | null;
}
export interface CreateUserViewPayload {
  name: string;
  workspaceIds: string[];
  filters?: ViewFiltersClientDto | null;
  sortBy?: string;
  sortDirection?: "asc" | "desc";
  isDefault?: boolean;
}
export interface UserViewClientDto {
  id: string;
  uid: string;
  name: string;
  workspaceIds: string[];
  filters: ViewFiltersClientDto | null;
  sortBy: string | null;
  sortDirection: "asc" | "desc" | null;
  isDefault: boolean;
  createdAt: string; // ISO
  updatedAt: string; // ISO
}
export interface CreateUserViewResponse {
  view: UserViewClientDto;
}
export interface GetUserViewsResponse {
  views: UserViewClientDto[];
}
export interface GetUserViewDetailsPayload {
  viewId: string;
}
export interface GetUserViewDetailsResponse {
  view: UserViewClientDto;
}
export interface UpdateUserViewPayload extends Partial<CreateUserViewPayload> {
  viewId: string;
}
export interface UpdateUserViewResponse extends SuccessResponse {
  updatedView: UserViewClientDto;
}
export interface DeleteUserViewPayload {
  viewId: string;
}
export interface SetDefaultViewPayload {
  viewId: string;
}
export interface GetAggregatedTasksFromViewPayload {
  viewId: string;
  dateFilter?: "today" | "this_week" | "this_month" | null;
}

export interface UpdateTaskStatusPayload {
  taskId: string;
  newStatus: TaskStatusType;
  workspaceId: string;
}


// --- Специализированные Операции ---
interface GuestTaskDto {
  localId: string;
  title: string;
  description?: string | null;
  priority: TaskPriorityType;
  dueDate?: string | number | null;
  pomodoroEstimatedMinutes?: number | null;
  tags?: string[];
}

interface GuestWorkspaceDto {
  localId: string;
  name: string;
  description?: string | null;
  activeApproach: string;
  tasks: GuestTaskDto[];
}

export interface MigrateGuestDataPayload {
  workspaces: GuestWorkspaceDto[];
}

export interface MigrateGuestDataResponse extends SuccessResponse {
  idMappings: {
    workspaces: Record<string, string>;
    tasks: Record<string, string>;
  };
}


// --- Статистика ---
export interface GetTaskStatisticsPayload {
  taskId: string;
}

export interface TaskStatisticsClientDto {
  completionTime: string | null; // ISO 8601
  timeSpentSeconds: number;
  totalPomodoroFocusSeconds: number;
  completedPomodoroFocusSessions: number;
  totalPomodoroInterrupts: number;
  wasCompletedOnce: boolean;
  firstCompletionTime: string | null;
  updatedAt: string; // ISO 8601
}

export interface GetTaskStatisticsResponse {
  statistics: TaskStatisticsClientDto;
}

export interface GetGamificationHistoryPayload {
  limit?: number;
  startAfterEntryId?: string | null;
}

export interface GamificationHistoryEntryClientDto {
  id: string;
  timestamp: string; // ISO 8601
  eventType: string;
  xpChange: number;
  coinsChange: number;
  relatedEntityCloudId: string | null;
  relatedEntityType: "task" | "challenge" | "badge" | "plant" | null;
  description: string | null;
}

export interface GetGamificationHistoryResponse {
  history: GamificationHistoryEntryClientDto[];
  nextPageToken: string | null;
}

export interface StatsTrendRequestPayload {
  startDate: string;
  endDate: string;
}


export interface DateValuePointClientDto {
  date: string; // YYYY-MM-DD
  value: number;
}

export interface DayOfWeekValuePointClientDto {
  dayOfWeek: number; // 1 (Пн) - 7 (Вс)
  value: number;
}

export interface StatsPeriodSummaryClientDto {
  startDate: string; // YYYY-MM-DD
  endDate: string; // YYYY-MM-DD
  taskCompletionTrend?: DateValuePointClientDto[];
  pomodoroFocusTrend?: DateValuePointClientDto[];
  xpGainTrend?: DateValuePointClientDto[];
  coinGainTrend?: DateValuePointClientDto[];
  tasksCompletedByDayOfWeek?: DayOfWeekValuePointClientDto[];
  totalTasksCompletedInPeriod?: number;
  totalPomodoroMinutesInPeriod?: number;
  averageDailyPomodoroMinutes?: number;
  totalXpGainedInPeriod?: number;
  totalCoinsGainedInPeriod?: number;
  mostProductiveDayInPeriod?: string | null;
  averageTasksPerDayInPeriod?: number;
}

export interface GetGlobalStatisticsResponse {
    statistics: {
        userId: string;
        totalPersonalWorkspacesCreated: number;
        totalTeamWorkspacesMemberOf: number;
        totalTasksCreated: number;
        totalTasksCompleted: number;
        totalPomodoroFocusMinutes: number;
        totalTimeSpentMinutesOverall: number;
        lastActive: string; // ISO
        registrationDate: string; // ISO
    };
}

/**
 * Payload для создания новой подзадачи.
 */
export interface CreateSubtaskPayload {
  parentTaskId: string;
  title: string;
  order?: number;
}

/**
 * Payload для обновления подзадачи.
 */
export interface UpdateSubtaskPayload {
  parentTaskId: string;
  subtaskId: string;
  title?: string;
  completed?: boolean;
  order?: number;
}

/**
 * Payload для удаления подзадачи.
 */
export interface DeleteSubtaskPayload {
  parentTaskId: string;
  subtaskId: string;
}


// === DTO для Дельта-Синхронизации Задач ===

/**
 * Payload для запроса изменений по задачам.
 */
export interface GetTaskChangesPayload {
  since: string;
  workspaceIds: string[];
}

/**
 * DTO ответа с изменениями по задачам.
 */
export interface GetTaskChangesResponse {
  updatedTasks: TaskClientDto[];
  deletedTaskCloudIds: string[];
  serverTimestamp: string;
}


// ----- FILE: A:\Progects\Progress Quest Universal\progressquest-backend\functions\src\types\events.types.ts -----
import {
  TaskDocument,
  TaskStatusType,
  PomodoroSessionType,
  ChallengeScopeType,
  ChallengeRewardType,
  TeamMemberDocument,
  WorkspaceMemberDocument,
  GamificationHistoryEventType,
  WorkspaceDocument,
  TeamDocument,
  UserDocument,
} from "./firestore.types";

export interface BaseEvent {
  eventType: string;
  eventTimestamp: string;
  traceId?: string; // Опционально, для сквозной трассировки
}

// --- 1. User Events (Топик: user-events) ---
export interface UserCreatedEventData {
  userId: string;
  email?: string | null;
  displayName?: string | null;
}
export interface UserCreatedEvent extends BaseEvent {
  eventType: "USER_CREATED";
  data: UserCreatedEventData;
}

export interface UserProfileUpdatedEventData {
  userId: string;
  updatedFields: Array<keyof UserDocument>;
}
export interface UserProfileUpdatedEvent extends BaseEvent {
  eventType: "USER_PROFILE_UPDATED";
  data: UserProfileUpdatedEventData;
}

export interface UserDeletedEventData {
  userId: string;
}
export interface UserDeletedEvent extends BaseEvent {
  eventType: "USER_DELETED";
  data: UserDeletedEventData;
}

// --- 2. Team Events (Топик: team-events) ---
export interface TeamEventBaseData {
  teamId: string;
}

export interface TeamCreatedEventData extends TeamEventBaseData {
  ownerUid: string;
  teamName: string;
}
export interface TeamCreatedEvent extends BaseEvent {
  eventType: "TEAM_CREATED";
  data: TeamCreatedEventData;
}

export interface TeamUpdatedEventData extends TeamEventBaseData {
  updatedFields: Array<keyof TeamDocument>;
}
export interface TeamUpdatedEvent extends BaseEvent {
  eventType: "TEAM_UPDATED";
  data: TeamUpdatedEventData;
}

export type TeamDeletedEventData = TeamEventBaseData;
export interface TeamDeletedEvent extends BaseEvent {
  eventType: "TEAM_DELETED";
  data: TeamDeletedEventData;
}

export interface TeamMemberAddedEventData extends TeamEventBaseData {
  userId: string;
  userTeamRole: TeamMemberDocument["role"];
  addedByUid: string;
}
export interface TeamMemberAddedEvent extends BaseEvent {
  eventType: "TEAM_MEMBER_ADDED";
  data: TeamMemberAddedEventData;
}

export interface TeamMemberRemovedEventData extends TeamEventBaseData {
  userId: string;
  removedByUid: string;
}
export interface TeamMemberRemovedEvent extends BaseEvent {
  eventType: "TEAM_MEMBER_REMOVED";
  data: TeamMemberRemovedEventData;
}

export interface TeamMemberRoleUpdatedEventData extends TeamEventBaseData {
  userId: string;
  newTeamRole: TeamMemberDocument["role"];
  oldTeamRole: TeamMemberDocument["role"];
  updatedByUid: string;
}
export interface TeamMemberRoleUpdatedEvent extends BaseEvent {
  eventType: "TEAM_MEMBER_ROLE_UPDATED";
  data: TeamMemberRoleUpdatedEventData;
}

// --- 3. Workspace Events (Топик: workspace-events) ---
export interface WorkspaceEventBaseData {
  workspaceId: string;
}

export interface WorkspaceCreatedEventData extends WorkspaceEventBaseData {
  ownerUid: string;
  teamId: string | null;
  isPersonal: boolean;
  workspaceName: string;
}
export interface WorkspaceCreatedEvent extends BaseEvent {
  eventType: "WORKSPACE_CREATED";
  data: WorkspaceCreatedEventData;
}

export interface WorkspaceUpdatedEventData extends WorkspaceEventBaseData {
  updatedFields: Array<keyof WorkspaceDocument>;
  updatedByUid: string;
}
export interface WorkspaceUpdatedEvent extends BaseEvent {
  eventType: "WORKSPACE_UPDATED";
  data: WorkspaceUpdatedEventData;
}

export interface WorkspaceDeletedEventData extends WorkspaceEventBaseData {
  teamId: string | null;
  deletedByUid: string;
}
export interface WorkspaceDeletedEvent extends BaseEvent {
  eventType: "WORKSPACE_DELETED";
  data: WorkspaceDeletedEventData;
}

export interface WorkspaceMemberAddedEventData extends WorkspaceEventBaseData {
  userId: string;
  workspaceRole: WorkspaceMemberDocument["workspaceRole"];
  teamId: string | null;
  addedByUid: string;
}
export interface WorkspaceMemberAddedEvent extends BaseEvent {
  eventType: "WORKSPACE_MEMBER_ADDED";
  data: WorkspaceMemberAddedEventData;
}

// --- 4. Task Events (Топик: task-events) ---
export interface TaskEventBaseData {
  taskId: string;
  workspaceId: string;
}

export interface TaskCreatedEventData extends TaskEventBaseData {
  creatorUid: string;
  assigneeUid: string | null;
  title: string;
}
export interface TaskCreatedEvent extends BaseEvent {
  eventType: "TASK_CREATED";
  data: TaskCreatedEventData;
}

export interface TaskUpdatedEventData extends TaskEventBaseData {
  updaterUid: string;
  changedFields: Partial<TaskDocument>;
  previousValues?: Partial<TaskDocument>;
}
export interface TaskUpdatedEvent extends BaseEvent {
  eventType: "TASK_UPDATED";
  data: TaskUpdatedEventData;
}

export interface TaskStatusUpdatedEventData {
  taskId: string;
  workspaceId: string;
  userId: string;
  newStatus: TaskStatusType;
  oldStatus?: TaskStatusType;
  completedAt?: string;
  taskData?: Partial<
    Pick<TaskDocument, "title" | "assigneeUid" | "creatorUid">
  >;
}
export interface TaskStatusUpdatedEventMessage extends BaseEvent {
  eventType: "TASK_STATUS_UPDATED";
  data: TaskStatusUpdatedEventData;
}

export interface TaskDeletedEventData extends TaskEventBaseData {
  deleterUid: string;
}
export interface TaskDeletedEvent extends BaseEvent {
  eventType: "TASK_DELETED";
  data: TaskDeletedEventData;
}

export interface TaskAssignedEventData extends TaskEventBaseData {
  newAssigneeUid: string | null;
  oldAssigneeUid: string | null;
  assignerUid: string;
}
export interface TaskAssignedEvent extends BaseEvent {
  eventType: "TASK_ASSIGNED";
  data: TaskAssignedEventData;
}

export interface TaskCommentAddedEventData extends TaskEventBaseData {
  commentId: string;
  authorUid: string;
  text: string;
}
export interface TaskCommentAddedEvent extends BaseEvent {
  eventType: "TASK_COMMENT_ADDED";
  data: TaskCommentAddedEventData;
}

// --- 5. Pomodoro Events (Топик: pomodoro-events) ---
export interface PomodoroPhaseStartedEventData {
  sessionId: string;
  userId: string;
  taskId: string;
  workspaceId: string;
  phaseType: PomodoroSessionType;
  plannedDurationSeconds: number;
  phaseNumberInCycle: number;
  totalFocusSessionIndex: number;
  startTime: string;
}
export interface PomodoroPhaseStartedEvent extends BaseEvent {
  eventType: "POMODORO_PHASE_STARTED";
  data: PomodoroPhaseStartedEventData;
}

export interface PomodoroPhaseCompletedEventData {
  sessionId: string;
  userId: string;
  taskId: string;
  workspaceId: string;
  phaseType: PomodoroSessionType;
  plannedDurationSeconds: number;
  actualDurationSeconds: number;
  interruptions: number;
  completed: boolean;
  phaseStartTime: string;
  completionTime: string;
}
export interface PomodoroPhaseCompletedEventMessage extends BaseEvent {
  eventType: "POMODORO_PHASE_COMPLETED";
  data: PomodoroPhaseCompletedEventData;
}

// --- 6. Gamification Events (Топик: gamification-events, если нужен) ---
export interface PointsAwardedEventData {
  userId: string;
  xpAmount?: number;
  coinsAmount?: number;
  reason: GamificationHistoryEventType;
  relatedEntityId?: string | null;
  relatedEntityType?: string | null;
}
export interface PointsAwardedEvent extends BaseEvent {
  eventType: "POINTS_AWARDED";
  data: PointsAwardedEventData;
}

export interface LevelUpEventData {
  userId: string;
  newLevel: number;
  oldLevel: number;
}
export interface LevelUpEvent extends BaseEvent {
  eventType: "LEVEL_UP";
  data: LevelUpEventData;
}

export interface BadgeEarnedEventData {
  userId: string;
  badgeDefinitionId: string;
  badgeName: string;
}
export interface BadgeEarnedEvent extends BaseEvent {
  eventType: "BADGE_EARNED";
  data: BadgeEarnedEventData;
}

export interface ChallengeProgressUpdateData {
  challengeDefinitionId: string;
  progress: {[key: string]: number} | number;
  isCompleted: boolean;
}
export interface ChallengeProgressUpdatedEventData {
  userId: string;
  challenge: ChallengeProgressUpdateData;
  scope: ChallengeScopeType;
  targetEntityId?: string | null;
}
export interface ChallengeProgressUpdatedEvent extends BaseEvent {
  eventType: "CHALLENGE_PROGRESS_UPDATED";
  data: ChallengeProgressUpdatedEventData;
}

export interface ChallengeCompletedEventData {
  userId: string;
  challengeDefinitionId: string;
  challengeName: string;
  scope: ChallengeScopeType;
  targetEntityId?: string | null;
  rewardApplied?: {type: ChallengeRewardType; value: string};
}
export interface ChallengeCompletedEvent extends BaseEvent {
  eventType: "CHALLENGE_COMPLETED";
  data: ChallengeCompletedEventData;
}

export interface PlantGrownStageUpEventData {
  userId: string;
  plantInstanceId: string;
  newStage: number;
  plantType: string;
}
export interface PlantGrownStageUpEvent extends BaseEvent {
  eventType: "PLANT_GROWN_STAGE_UP";
  data: PlantGrownStageUpEventData;
}


// ----- FILE: A:\Progects\Progress Quest Universal\progressquest-backend\functions\src\types\firestore.types.ts -----
import {FieldValue, Timestamp} from "firebase-admin/firestore";

export interface AppSettings {
  theme: "SYSTEM" | "LIGHT" | "DARK";
  dynamicColorEnabled: boolean;
  notificationsEnabled: boolean;
  taskNotifications?: boolean;
  pomodoroNotifications?: boolean;
  gamificationNotifications?: boolean;
}

export interface PomodoroSettings {
  focusDurationMinutes: number;
  shortBreakMinutes: number;
  longBreakMinutes: number;
  intervalBeforeLongBreak: number;
  autoStartFocus?: boolean;
  autoStartBreak?: boolean;
  focusSoundUri: string | null;
  breakSoundUri: string | null;
  vibrationEnabled: boolean;
}

export interface TeamMembershipEntry {
  teamId: string;
  teamName: string;
  userTeamRole: "owner" | "admin" | "editor" | "member" | "viewer";
}

export interface UserDocument {
  uid: string;
  email: string;
  displayName: string;
  avatarUrl: string | null;
  createdAt: Timestamp | FieldValue;
  lastLoginAt: Timestamp | FieldValue;
  personalWorkspaceId: string;
  activeItems: {
    workspaceId?: string | null;
    viewId?: string | null;
  };
  defaultViewId: string | null;
  appSettings: AppSettings;
  pomodoroSettings: PomodoroSettings;
  teamMemberships?: TeamMembershipEntry[];
}

export interface TeamDocument {
  name: string;
  description: string | null;
  ownerUid: string;
  logoUrl: string | null;
  createdAt: Timestamp | FieldValue;
  updatedAt: Timestamp | FieldValue;
  settings: {[key: string]: any} | null;
  defaultMemberRole: "admin" | "editor" | "member" | "viewer";
}

export interface TeamMemberDocument {
  uid: string;
  displayName: string;
  avatarUrl: string | null;
  role: "owner" | "admin" | "editor" | "member" | "viewer";
  joinedAt: Timestamp | FieldValue;
}

export interface WorkspaceDocument {
  name: string;
  description: string | null;
  ownerUid: string;
  isPersonal: boolean;
  teamId: string | null;
  createdAt: Timestamp | FieldValue;
  updatedAt: Timestamp | FieldValue;
  activeApproach: string;
  defaultTags: string[];
  settings: {
    allowMembersToCreateTasks?: boolean;
    taskVisibility?: "all_visible" | "assigned_only";
    pomodoroOverrides?: PomodoroSettings | null;
    [key: string]: any;
  };
  lastClientSyncTimestamp: Timestamp | null;
  syncStatus: "synced" | "pending_upload" | "pending_download" |
              "error" | null;
}

export interface WorkspaceMemberDocument {
  uid: string;
  displayName: string;
  avatarUrl: string | null;
  workspaceRole: "owner" | "admin" | "manager" | "editor" |
                 "member" | "viewer";
  addedAt: Timestamp | FieldValue;
}

export type TaskStatusType = "TODO" | "IN_PROGRESS" | "DONE";
export type TaskPriorityType = "LOW" | "MEDIUM" | "HIGH" | "CRITICAL";
export type FrogDifficultyType = "EASY" | "MEDIUM" | "HARD";

export interface CalendarApproachParams {
  eventId: string | null;
  isAllDay: boolean;
  recurrenceRule: string | null;
}
export interface GtdApproachParams {
  context: string | null;
  nextAction: boolean;
  projectLink: string | null;
  waitingFor: string | null;
}
export interface EisenhowerApproachParams {
  urgency: number;
  importance: number;
}
export interface FrogApproachParams {
  isFrog: boolean;
  difficulty: FrogDifficultyType;
}

export interface TaskDocument {
  title: string;
  description: string | null;
  status: TaskStatusType;
  priority: TaskPriorityType;
  dueDate: Timestamp | null;
  createdAt: Timestamp | FieldValue;
  updatedAt: Timestamp | FieldValue;
  completedAt: Timestamp | null;
  creatorUid: string;
  assigneeUid: string | null;
  workspaceId: string;
  tags: string[];
  pomodoroEstimatedCycles: number | null;
  pomodoroEstimatedMinutes: number | null;
  approachParams: {
    calendar?: CalendarApproachParams;
    gtd?: GtdApproachParams;
    eisenhower?: EisenhowerApproachParams;
    frog?: FrogApproachParams;
  } | null;
  orderInList: number;
  lastSyncClientTimestamp: Timestamp | null;
  localId: string | null;
}

export interface SubtaskDocument {
  title: string;
  completed: boolean;
  order: number;
  createdAt: Timestamp | FieldValue;
}

export interface CommentDocument {
  authorUid: string;
  authorName: string;
  authorAvatarUrl: string | null;
  text: string;
  createdAt: Timestamp | FieldValue;
  updatedAt: Timestamp | FieldValue | null;
}

export type PomodoroSessionType = "FOCUS" | "SHORT_BREAK" | "LONG_BREAK";

export interface PomodoroSessionDocument {
  userId: string;
  taskId: string;
  workspaceId: string;
  startTime: Timestamp | FieldValue;
  sessionType: PomodoroSessionType;
  plannedDurationSeconds: number;
  actualDurationSeconds: number;
  interruptions: number;
  completed: boolean;
  phaseNumberInCycle: number;
  totalFocusSessionIndex: number;
  updatedAt: Timestamp | FieldValue;
}

/**
 * Основной профиль геймификации пользователя.
 * Путь: /gamificationProfiles/{userUID}
 */
export interface GamificationProfileDocument {
  level: number;
  experience: number;
  coins: number;
  maxExperienceForLevel: number;
  currentStreak: number;
  lastClaimedDate: Timestamp;
  maxStreak: number;
  selectedPlantInstanceId: string | null; // Комментарий изменен
  lastPomodoroCompletionTime: Timestamp | null;
  lastTaskCompletionTime: Timestamp | null;
}

/**
 * Определение значка.
 * Путь: /badgeDefinitions/{badgeDefId}
 */
export interface BadgeDefinitionDocument {
    name: string;
    description: string;
    imageUrl: string;
    criteriaText: string;
    rewardXp: number;
    rewardCoins: number;
    isHidden: boolean;
}

/**
 * Документ о получении значка пользователем.
 * Путь: /gamificationProfiles/{userUID}/earnedBadges/{badgeDefId}
 */
export interface EarnedBadgeDocument {
  badgeDefinitionId: string;
  earnedAt: Timestamp;
  name: string;
  imageUrl: string;
  criteria: string;
}

// Первое определение ChallengeDefinitionDocument удалено

/**
 * Прогресс пользователя по челленджу.
 * Путь: /gamificationProfiles/{userUID}/challengeProgress/{challengeDefId}
 */
export interface ChallengeProgressDocument {
  challengeDefinitionId: string;
  progress: {[key: string]: number} | number;
  isCompleted: boolean;
  lastUpdated: Timestamp | FieldValue;
  completedAt: Timestamp | null;
}

/**
 * Документ экземпляра растения в саду пользователя.
 * Путь: /gamificationProfiles/{userUID}/virtualGarden/{plantInstanceId}
 */
export interface VirtualPlantDocument {
  plantType: string;
  growthStage: number;
  growthPoints: number;
  lastWateredAt: Timestamp;
  createdAt: Timestamp | FieldValue;
}

/**
 * Определение предмета в магазине.
 * Путь: /storeItems/{itemId}
 */
export interface StoreItemDocument {
    name: string;
    description: string;
    costInCoins: number;
    category: "PLANT_SEED" | "PLANT_FOOD" | "COSMETIC";
    itemValue: string;
    imageUrl: string;
    isAvailable: boolean;
}
export interface TaskStatisticsDocument {
  completionTime: Timestamp | null;
  timeSpentSeconds: number;
  totalPomodoroFocusSeconds: number;
  completedPomodoroFocusSessions: number;
  totalPomodoroInterrupts: number;
  wasCompletedOnce: boolean;
  firstCompletionTime: Timestamp | null;
  updatedAt: Timestamp | FieldValue;
}

export interface GlobalStatisticsDocument {
  userId: string;
  totalPersonalWorkspacesCreated: number;
  totalTeamWorkspacesMemberOf: number;
  totalTasksCreated: number;
  totalTasksCompleted: number;
  totalPomodoroFocusMinutes: number;
  totalTimeSpentMinutesOverall: number;
  lastActive: Timestamp | FieldValue;
  registrationDate: Timestamp;
}

export type GamificationHistoryEventType =
  | "TASK_COMPLETED" | "POMODORO_FOCUS_PHASE" | "DAILY_REWARD_CLAIMED"
  | "CHALLENGE_COMPLETED" | "BADGE_EARNED" | "PLANT_WATERED" | "LEVEL_UP"
  | "CUSTOM_CHALLENGE_COMPLETED";

export interface GamificationHistoryEntryDocument {
  userId: string;
  timestamp: Timestamp | FieldValue;
  eventType: GamificationHistoryEventType;
  xpChange: number;
  coinsChange: number;
  relatedEntityId: string | null;
  relatedEntityType: "task" | "challenge" | "badge" | "plant" | null;
  description: string | null;
}

export interface DateRangeFilter {
  start: Timestamp | null;
  end: Timestamp | null;
  type: "due" | "created" | "completed";
}

export interface UserViewDocument {
  uid: string;
  name: string;
  workspaceIds: string[];
  filters: {
    status?: TaskStatusType[];
    priority?: TaskPriorityType[];
    tagsInclude?: string[];
    tagsExclude?: string[];
    dateRange?: DateRangeFilter | null;
    assignee?: "me" | "unassigned" | string | null;
  } | null;
  sortBy: string;
  sortDirection: "asc" | "desc";
  isDefault: boolean;
  createdAt: Timestamp | FieldValue;
  updatedAt: Timestamp | FieldValue;
}

export type ChallengeScopeType = "personal" | "team" | "workspace";
export type ChallengeRewardType = "XP" | "COINS" | "BADGE_ID" | "TEXT";
export type ChallengePeriodType = "ONCE" | "DAILY" | "WEEKLY" | "MONTHLY";
export type ChallengeEventType =
  | "TASK_COMPLETION_COUNT" | "POMODORO_FOCUS_MINUTES" | "LOGIN_STREAK"
  | "POMODORO_SESSION_COUNT"
  | "CUSTOM_EVENT" | "BADGE_COUNT" | "PLANT_MAX_STAGE"
  | "LEVEL_REACHED" | "RESOURCE_ACCUMULATED";

/**
 * Определение челленджа.
 * Путь: /challengeDefinitions/{challengeDefId}
 */
export interface ChallengeDefinitionDocument { // Это определение остается
  name: string;
  description: string;
  creatorUid: string | "system";
  scope: ChallengeScopeType;
  targetEntityId: string | null;
  isPublicTemplate: boolean;
  reward: {
    type: ChallengeRewardType;
    value: string;
    badgeName?: string | null;
    badgeImageUrl?: string | null;
  };
  period: ChallengePeriodType;
  type: ChallengeEventType;
  targetValue: number;
  conditionJson: string | null;
  isActiveSystemChallenge?: boolean;
  createdAt: Timestamp | FieldValue;
  updatedAt: Timestamp | FieldValue;
}

export interface ActiveItems {
  workspaceId?: string | null;
  viewId?: string | null;
}

// Новая сущность для хранения FCM токенов
export interface FcmTokenDocument {
    token: string;
    platform: "android" | "web" | "unknown";
    createdAt: Timestamp;
    lastUsedAt: Timestamp;
}


export interface DeletedEntityDocument {
  entityType: "task" | "subtask" | "workspace" | "view" | "team";
  deletedAt: Timestamp | FieldValue;
  userId?: string | null;
  workspaceId?: string | null;
  teamId?: string | null;
}


// ----- FILE: A:\Progects\Progress Quest Universal\progressquest-backend\functions\src\types\index.ts -----
export * from "./firestore.types";
export * from "./api.types";
export * from "./events.types";


// ----- FILE: A:\Progects\Progress Quest Universal\progressquest-backend\functions\src\utils\index.ts -----
import {HttpsError, CallableRequest} from "firebase-functions/v2/https";
import {
  getFirestore,
  DocumentReference,
  Firestore,
} from "firebase-admin/firestore";
import {
  WORKSPACES_COLLECTION,
  TEAMS_COLLECTION,
} from "../config";
import {
  WorkspaceDocument,
  WorkspaceMemberDocument,
  TeamMemberDocument,
} from "../types/firestore.types";

const db: Firestore = getFirestore();

/**
 * Проверяет, аутентифицирован ли пользователь в CallableFunction.
 * @param {object|undefined} auth - Объект auth из запроса Firebase Functions.
 * @return {string} UID аутентифицированного пользователя.
 * @throws {HttpsError} Код "unauthenticated", если не аутентифицирован.
 */
export function assertAuthenticated(
  auth: CallableRequest["auth"] | undefined
): string {
  if (!auth || !auth.uid) {
    console.warn(
      "[AuthUtil] Authentication check failed: No auth context or UID."
    );
    throw new HttpsError(
      "unauthenticated",
      "Запрос требует аутентификации пользователя."
    );
  }
  return auth.uid;
}

/**
 * Получает роль пользователя в указанном рабочем пространстве.
 * @param {string} workspaceId - ID рабочего пространства.
 * @param {string} userId - ID пользователя.
 * @return {Promise<string | null>} Роль пользователя или null.
 */
export async function getUserRoleInWorkspace(
  workspaceId: string,
  userId: string
): Promise<WorkspaceMemberDocument["workspaceRole"] | null> {
  if (!workspaceId || !userId) {
    console.warn(
      "[AuthUtil] getUserRoleInWorkspace: workspaceId or userId is empty."
    );
    return null;
  }
  try {
    const memberRef = db
      .collection(WORKSPACES_COLLECTION)
      .doc(workspaceId)
      .collection("members")
      .doc(userId) as DocumentReference<WorkspaceMemberDocument>;
    const memberDoc = await memberRef.get();
    if (memberDoc.exists) {
      return memberDoc.data()?.workspaceRole || null;
    }
    console.log(
      "[AuthUtil] User " + // Исправлено на двойные кавычки
        userId +
        " not found in members of workspace " +
        workspaceId +
        "."
    );
    return null;
  } catch (error) {
    console.error(
      "[AuthUtil] Error fetching role for user " + // Исправлено
        userId +
        " in ws " +
        workspaceId +
        ":",
      error
    );
    return null;
  }
}

/**
 * Проверяет роль пользователя в рабочем пространстве.
 * @param {string} workspaceId - ID рабочего пространства.
 * @param {string} userId - ID пользователя.
 * @param {Array<string>} requiredRoles - Массив допустимых ролей.
 * @return {Promise<string>} Роль пользователя, если проверка пройдена.
 * @throws {HttpsError} Если права отсутствуют.
 */
export async function assertWorkspaceRole(
  workspaceId: string,
  userId: string,
  requiredRoles: Array<WorkspaceMemberDocument["workspaceRole"]>
): Promise<WorkspaceMemberDocument["workspaceRole"]> {
  const userRole = await getUserRoleInWorkspace(workspaceId, userId);
  if (!userRole || !requiredRoles.includes(userRole)) {
    console.warn(
      "[AuthUtil] Permission denied for user " + // Исправлено
        userId +
        " in ws " +
        workspaceId +
        ". Required: " +
        requiredRoles.join("|") +
        ", Has: " +
        (userRole || "none") +
        "."
    );
    throw new HttpsError(
      "permission-denied",
      "У вас недостаточно прав для выполнения этого действия " +
        "в данном рабочем пространстве."
    );
  }
  return userRole;
}

/**
 * Проверяет, является ли пользователь владельцем личного рабочего пространства.
 * @param {string} workspaceId - ID рабочего пространства.
 * @param {string} userId - ID текущего аутентифицированного пользователя.
 * @return {Promise<void>} Завершается успешно, если проверка пройдена.
 * @throws {HttpsError} Если Workspace не найден или доступ запрещен.
 */
export async function assertPersonalWorkspaceOwner(
  workspaceId: string,
  userId: string
): Promise<void> {
  if (!workspaceId || !userId) {
    throw new HttpsError(
      "invalid-argument",
      "WorkspaceId и UserId обязательны."
    );
  }
  const workspaceRef = db
    .collection(WORKSPACES_COLLECTION)
    .doc(workspaceId) as DocumentReference<WorkspaceDocument>;
  try {
    const workspaceDoc = await workspaceRef.get();
    if (!workspaceDoc.exists) {
      console.warn(
        "[AuthUtil] Workspace " + workspaceId + " not found." // Исправлено
      );
      throw new HttpsError(
        "not-found",
        "Рабочее пространство не найдено."
      );
    }
    const wsData = workspaceDoc.data();
    if (!wsData || !wsData.isPersonal || wsData.ownerUid !== userId) {
      console.warn(
        "[AuthUtil] Permission denied for user " + // Исправлено
          userId +
          " on personal ws " +
          workspaceId +
          ". IsPersonal: " +
          wsData?.isPersonal +
          ", Owner: " +
          wsData?.ownerUid +
          "."
      );
      throw new HttpsError(
        "permission-denied",
        "Действие запрещено для этого рабочего пространства."
      );
    }
  } catch (error) {
    console.error(
      "[AuthUtil] Error in assertPersonalWorkspaceOwner for ws " + // Исправлено
        workspaceId +
        ":",
      error
    );
    if (error instanceof HttpsError) {
      throw error;
    }
    throw new HttpsError(
      "internal",
      "Ошибка проверки прав на пространство."
    );
  }
}

/**
 * Получает роль пользователя в указанной команде.
 * @param {string} teamId - ID команды.
 * @param {string} userId - ID пользователя.
 * @return {Promise<string | null>} Роль пользователя или null.
 */
export async function getUserRoleInTeam(
  teamId: string,
  userId: string
): Promise<TeamMemberDocument["role"] | null> {
  if (!teamId || !userId) {
    console.warn("[AuthUtil] getUserRoleInTeam: teamId or userId is empty.");
    return null;
  }
  try {
    const memberRef = db
      .collection(TEAMS_COLLECTION)
      .doc(teamId)
      .collection("members")
      .doc(userId) as DocumentReference<TeamMemberDocument>;
    const memberDoc = await memberRef.get();
    if (memberDoc.exists) {
      return memberDoc.data()?.role || null;
    }
    console.log(
      "[AuthUtil] User " + // Исправлено
        userId +
        " not found in members of team " +
        teamId +
        "."
    );
    return null;
  } catch (error) {
    console.error(
      "[AuthUtil] Error fetching role for user " + // Исправлено
        userId +
        " in team " +
        teamId +
        ":",
      error
    );
    return null;
  }
}

/**
 * Проверяет роль пользователя в команде.
 * @param {string} teamId - ID команды.
 * @param {string} userId - ID пользователя.
 * @param {Array<string>} requiredRoles - Массив допустимых ролей.
 * @return {Promise<string>} Роль пользователя, если проверка пройдена.
 * @throws {HttpsError} Если права отсутствуют.
 */
export async function assertTeamRole(
  teamId: string,
  userId: string,
  requiredRoles: Array<TeamMemberDocument["role"]>
): Promise<TeamMemberDocument["role"]> {
  const userRole = await getUserRoleInTeam(teamId, userId);
  if (!userRole || !requiredRoles.includes(userRole)) {
    // ИСПРАВЛЕНИЕ ЗДЕСЬ (строка, которая была примерно 153-й)
    console.warn(
      "[AuthUtil] Permission denied for user " +
        userId +
        " in team " +
        teamId +
        ". Required: " +
        requiredRoles.join("|") +
        ", Has: " +
        (userRole || "none") +
        "."
    );
    throw new HttpsError(
      "permission-denied",
      "У вас недостаточно прав для выполнения этого действия в команде."
    );
  }
  return userRole;
}




--- package.json ---

{
  "name": "progressquest-web",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "description": "ProgressQuest Universal - Web App",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "lint": "eslint src --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "lint:fix": "eslint src --ext ts,tsx --fix",
    "type-check": "tsc --noEmit",
    "serve": "firebase serve --only hosting",
    "deploy": "npm run build && firebase deploy --only hosting",
    "emulators": "firebase emulators:start",
    "emulators:ui": "firebase emulators:start --only functions,firestore,auth,storage",
    "dev:emulator": "concurrently \"firebase emulators:start\" \"npm run dev\""
  },
  "dependencies": {
    "@hookform/resolvers": "^3.3.2",
    "@radix-ui/react-avatar": "^1.0.4",
    "@radix-ui/react-checkbox": "^1.0.4",
    "@radix-ui/react-dialog": "^1.1.14",
    "@radix-ui/react-dropdown-menu": "^2.0.6",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-popover": "^1.0.7",
    "@radix-ui/react-progress": "^1.0.3",
    "@radix-ui/react-select": "^2.2.5",
    "@radix-ui/react-separator": "^1.0.3",
    "@radix-ui/react-slider": "^1.1.2",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-switch": "^1.0.3",
    "@radix-ui/react-tabs": "^1.0.4",
    "@radix-ui/react-tooltip": "^1.0.7",
    "@tailwindcss/container-queries": "^0.1.1",
    "@tanstack/react-query": "^5.12.2",
    "@tanstack/react-query-devtools": "^5.13.3",
    "@types/react-beautiful-dnd": "^13.1.8",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^0.2.0",
    "date-fns": "^2.30.0",
    "firebase": "^10.7.1",
    "framer-motion": "^10.16.16",
    "immer": "^10.0.3",
    "lucide-react": "^0.294.0",
    "react": "^18.2.0",
    "react-beautiful-dnd": "^13.1.1",
    "react-day-picker": "^8.9.1",
    "react-dom": "^18.2.0",
    "react-hook-form": "^7.48.2",
    "react-router-dom": "^6.20.1",
    "recharts": "^2.8.0",
    "sonner": "^1.2.4",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7",
    "vaul": "^0.7.9",
    "zod": "^3.22.4",
    "zustand": "^4.4.7"
  },
  "devDependencies": {
    "@tailwindcss/aspect-ratio": "^0.4.2",
    "@tailwindcss/forms": "^0.5.7",
    "@tailwindcss/typography": "^0.5.10",
    "@types/react": "^18.2.37",
    "@types/react-dom": "^18.2.15",
    "@typescript-eslint/eslint-plugin": "^6.10.0",
    "@typescript-eslint/parser": "^6.10.0",
    "@vitejs/plugin-react-swc": "^3.5.0",
    "autoprefixer": "^10.4.16",
    "eslint": "^8.53.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.4",
    "firebase-tools": "^12.9.1",
    "postcss": "^8.4.32",
    "tailwindcss": "^3.3.5",
    "typescript": "^5.2.2",
    "vite": "^5.0.0"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}


--- postcss.config.js ---

export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}


--- README.md ---

# ProgressQuest Universal - Web Application

Полнофункциональное веб-приложение для повышения продуктивности с элементами геймификации.

## 🌟 Особенности

- **Управление задачами** - Создание, редактирование и отслеживание задач
- **Система проектов** - Организация задач по проектам
- **Pomodoro таймер** - Техника Pomodoro для фокусировки
- **Геймификация** - XP, уровни, достижения и стрики
- **Виртуальный сад** - Выращивание растений за выполнение задач
- **Аналитика** - Подробная статистика продуктивности
- **Темная/светлая тема** - Переключение тем
- **Реальное время** - Синхронизация данных в реальном времени
- **Адаптивный дизайн** - Работает на всех устройствах

## 🛠 Технологический стек

### Frontend
- **React 18** - UI библиотека
- **TypeScript** - Типизированный JavaScript
- **Vite** - Сборщик и инструмент разработки
- **Tailwind CSS** - CSS фреймворк
- **Radix UI** - Компоненты интерфейса

### State Management
- **Zustand** - Управление состоянием
- **React Query** - Кэширование и синхронизация данных
- **Immer** - Иммутабельные обновления

### Backend & Database
- **Firebase** - Backend-as-a-Service
  - Authentication - Аутентификация пользователей
  - Firestore - NoSQL база данных
  - Cloud Functions - Серверная логика
  - Storage - Хранение файлов
  - Hosting - Хостинг приложения

### Development Tools
- **ESLint** - Линтер JavaScript/TypeScript
- **Prettier** - Форматтер кода
- **Husky** - Git hooks

## 🚀 Быстрый старт

### Предварительные требования

- Node.js 18.0.0 или выше
- npm или yarn
- Firebase аккаунт

### Установка

1. **Клонирование репозитория**
```bash
git clone https://github.com/your-username/progressquest-universal.git
cd progressquest-universal
```

2. **Установка зависимостей**
```bash
npm install
```

3. **Настройка Firebase**

   a. Создайте новый проект в [Firebase Console](https://console.firebase.google.com/)
   
   b. Включите следующие сервисы:
   - Authentication (Email/Password, Google)
   - Firestore Database
   - Storage
   - Hosting

   c. Скопируйте конфигурацию Firebase из настроек проекта

4. **Настройка переменных окружения**

Создайте файл `.env.local` в корне проекта:

```env
VITE_FIREBASE_API_KEY=your_api_key_here
VITE_FIREBASE_AUTH_DOMAIN=your_project.firebaseapp.com
VITE_FIREBASE_PROJECT_ID=your_project_id
VITE_FIREBASE_STORAGE_BUCKET=your_project.appspot.com
VITE_FIREBASE_MESSAGING_SENDER_ID=123456789
VITE_FIREBASE_APP_ID=1:123456789:web:abcdefghijklmnop

VITE_APP_NAME=ProgressQuest Universal
VITE_APP_VERSION=1.0.0
VITE_APP_ENVIRONMENT=development

VITE_ENABLE_ANALYTICS=true
VITE_ENABLE_NOTIFICATIONS=true
VITE_ENABLE_GARDEN=true
VITE_ENABLE_COLLABORATION=true
```

5. **Настройка Firestore правил безопасности**

Скопируйте содержимое `firestore.rules` в Firebase Console > Firestore Database > Rules

6. **Настройка индексов Firestore**

Импортируйте `firestore.indexes.json` в Firebase Console или создайте индексы автоматически при первых запросах

### Запуск проекта

```bash
# Режим разработки
npm run dev

# Сборка для продакшена
npm run build

# Предварительный просмотр продакшен сборки
npm run preview

# Линтинг
npm run lint

# Проверка типов
npm run type-check
```

## 📁 Структура проекта

```
src/
├── components/          # React компоненты
│   ├── ui/             # Базовые UI компоненты
│   ├── Layout.tsx      # Основной макет
│   └── ProtectedRoute.tsx
├── pages/              # Страницы приложения
│   ├── LandingPage.tsx
│   ├── DashboardPage.tsx
│   ├── TasksPage.tsx
│   └── ...
├── contexts/           # React контексты
│   ├── AuthContext.tsx
│   └── ThemeContext.tsx
├── stores/             # Zustand стейт менеджеры
│   ├── appStore.ts
│   └── pomodoroStore.ts
├── hooks/              # Кастомные React хуки
│   ├── useTasks.ts
│   └── ...
├── services/           # API сервисы
│   ├── firebase.ts
│   ├── userService.ts
│   ├── taskService.ts
│   └── ...
├── utils/              # Утилиты
│   ├── helpers.ts
│   └── dateTime.ts
├── types/              # TypeScript типы
│   └── index.ts
├── constants/          # Константы приложения
│   └── index.ts
└── lib/                # Конфигурация библиотек
    └── firebase.ts
```

## 🔧 Конфигурация

### Firebase

1. **Authentication Providers**
   - Email/Password
   - Google Sign-in

2. **Firestore Collections**
   - `users` - Пользователи
   - `workspaces` - Рабочие пространства
   - `projects` - Проекты
   - `tasks` - Задачи
   - `pomodoroSessions` - Pomodoro сессии
   - `userAchievements` - Достижения пользователей
   - `gardenPlants` - Растения сада
   - `notifications` - Уведомления

3. **Storage Structure**
   ```
   /users/{userId}/
   ├── avatar.jpg
   └── attachments/
       └── {taskId}/
   ```

### Environment Variables

| Переменная | Описание | Обязательная |
|------------|----------|--------------|
| `VITE_FIREBASE_API_KEY` | Firebase API ключ | ✅ |
| `VITE_FIREBASE_AUTH_DOMAIN` | Firebase Auth домен | ✅ |
| `VITE_FIREBASE_PROJECT_ID` | Firebase Project ID | ✅ |
| `VITE_FIREBASE_STORAGE_BUCKET` | Firebase Storage bucket | ✅ |
| `VITE_FIREBASE_MESSAGING_SENDER_ID` | Firebase Messaging ID | ✅ |
| `VITE_FIREBASE_APP_ID` | Firebase App ID | ✅ |
| `VITE_ENABLE_ANALYTICS` | Включить аналитику | ❌ |
| `VITE_ENABLE_GARDEN` | Включить виртуальный сад | ❌ |

## 🚀 Развертывание

### Firebase Hosting

1. **Установка Firebase CLI**
```bash
npm install -g firebase-tools
```

2. **Авторизация**
```bash
firebase login
```

3. **Инициализация проекта**
```bash
firebase init
```

4. **Сборка и развертывание**
```bash
npm run build
firebase deploy
```

### Альтернативные платформы

- **Vercel**: Подключите GitHub репозиторий
- **Netlify**: Drag & drop папки `dist`
- **GitHub Pages**: Используйте GitHub Actions

## 🧪 Тестирование

```bash
# Запуск тестов
npm run test

# Покрытие тестами
npm run test:coverage

# E2E тесты
npm run test:e2e
```

## 📊 Производительность

- **Lighthouse Score**: 90+
- **Bundle Size**: ~500KB gzipped
- **First Contentful Paint**: <1.5s
- **Time to Interactive**: <3s

## 🔐 Безопасность

- HTTPS Only
- Firebase Security Rules
- Input Sanitization
- XSS Protection
- CSRF Protection

## 🤝 Вклад в проект

1. Fork проекта
2. Создайте feature ветку (`git checkout -b feature/amazing-feature`)
3. Commit изменения (`git commit -m 'Add amazing feature'`)
4. Push в ветку (`git push origin feature/amazing-feature`)
5. Создайте Pull Request

## 📝 Лицензия

Этот проект лицензирован под MIT License - см. файл [LICENSE](LICENSE) для деталей.

## 🆘 Поддержка

- 📧 Email: support@progressquest.com
- 💬 Discord: [ProgressQuest Community](https://discord.gg/progressquest)
- 📖 Wiki: [Project Wiki](https://github.com/your-username/progressquest-universal/wiki)

## 🗺 Roadmap

### v1.1.0
- [ ] Мобильное приложение (React Native)
- [ ] Командная работа в реальном времени
- [ ] Интеграции с внешними сервисами

### v1.2.0
- [ ] AI-помощник для планирования
- [ ] Расширенная аналитика
- [ ] Темплейты проектов

### v2.0.0
- [ ] Белые лейблы
- [ ] Enterprise функции
- [ ] API для интеграций

## 🙏 Благодарности

- [React](https://reactjs.org/) - UI библиотека
- [Firebase](https://firebase.google.com/) - Backend платформа
- [Tailwind CSS](https://tailwindcss.com/) - CSS фреймворк
- [Radix UI](https://www.radix-ui.com/) - UI примитивы


--- tailwind.config.js ---

/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
  ],
  theme: {
  	container: {
  		center: true,
  		padding: '2rem',
  		screens: {
  			'2xl': '1400px'
  		}
  	},
  	extend: {
  		colors: {
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))',
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		},
  		fontFamily: {
  			sans: [
  				'Inter',
  				'-apple-system',
  				'BlinkMacSystemFont',
  				'Segoe UI',
  				'Roboto',
  				'Oxygen',
  				'Ubuntu',
  				'Cantarell',
  				'sans-serif'
  			]
  		},
  		animation: {
  			'accordion-down': 'accordion-down 0.2s ease-out',
  			'accordion-up': 'accordion-up 0.2s ease-out',
  			'fade-in': 'fade-in 0.3s ease-out',
  			'slide-in': 'slide-in 0.3s ease-out',
  			'slide-up': 'slide-up 0.3s ease-out',
  			'bounce-subtle': 'bounce-subtle 2s infinite',
  			'pulse-subtle': 'pulse-subtle 2s infinite',
  			'rotate-slow': 'rotate-slow 3s linear infinite',
  			'shimmer': 'shimmer 2s linear infinite'
  		},
  		keyframes: {
  			'accordion-down': {
  				from: {
  					height: '0'
  				},
  				to: {
  					height: 'var(--radix-accordion-content-height)'
  				}
  			},
  			'accordion-up': {
  				from: {
  					height: 'var(--radix-accordion-content-height)'
  				},
  				to: {
  					height: '0'
  				}
  			},
  			'fade-in': {
  				'0%': {
  					opacity: '0',
  					transform: 'translateY(10px)'
  				},
  				'100%': {
  					opacity: '1',
  					transform: 'translateY(0)'
  				}
  			},
  			'slide-in': {
  				'0%': {
  					transform: 'translateX(-100%)'
  				},
  				'100%': {
  					transform: 'translateX(0)'
  				}
  			},
  			'slide-up': {
  				'0%': {
  					transform: 'translateY(100%)'
  				},
  				'100%': {
  					transform: 'translateY(0)'
  				}
  			},
  			'bounce-subtle': {
  				'0%, 100%': {
  					transform: 'translateY(0)'
  				},
  				'50%': {
  					transform: 'translateY(-5px)'
  				}
  			},
  			'pulse-subtle': {
  				'0%, 100%': {
  					opacity: '1'
  				},
  				'50%': {
  					opacity: '0.8'
  				}
  			},
  			'rotate-slow': {
  				'0%': {
  					transform: 'rotate(0deg)'
  				},
  				'100%': {
  					transform: 'rotate(360deg)'
  				}
  			},
  			'shimmer': {
  				'0%': {
  					transform: 'translateX(-100%)'
  				},
  				'100%': {
  					transform: 'translateX(100%)'
  				}
  			}
  		},
  		spacing: {
  			'18': '4.5rem',
  			'88': '22rem',
  			'120': '30rem'
  		},
  		maxWidth: {
  			'8xl': '88rem',
  			'9xl': '96rem'
  		},
  		backdropBlur: {
  			xs: '2px'
  		},
  		boxShadow: {
  			'inner-lg': 'inset 0 2px 4px 0 rgba(0, 0, 0, 0.1)',
  			glow: '0 0 20px rgba(139, 92, 246, 0.3)',
  			'glow-lg': '0 0 30px rgba(139, 92, 246, 0.4)'
  		},
  		screens: {
  			xs: '475px',
  			'3xl': '1920px'
  		},
  		gridTemplateColumns: {
  			'auto-fit': 'repeat(auto-fit, minmax(0, 1fr))',
  			'auto-fill': 'repeat(auto-fill, minmax(0, 1fr))'
  		},
  		aspectRatio: {
  			'4/3': '4 / 3',
  			'3/2': '3 / 2',
  			'2/3': '2 / 3',
  			'9/16': '9 / 16'
  		}
  	}
  },
  plugins: [
    require("tailwindcss-animate"),
    require("@tailwindcss/typography"),
    require("@tailwindcss/forms"),
    require("@tailwindcss/aspect-ratio"),
    require("@tailwindcss/container-queries"),
  ],
}


--- tsconfig.json ---

{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

    /* Path mapping */
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}


--- tsconfig.node.json ---

{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}


--- vite.config.ts ---

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react-swc'
import path from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  build: {
    outDir: 'dist',
    sourcemap: true,
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom'],
          firebase: ['firebase/app', 'firebase/auth', 'firebase/firestore', 'firebase/functions'],
          ui: ['@radix-ui/react-dialog', '@radix-ui/react-dropdown-menu', '@radix-ui/react-tabs'],
        },
      },
    },
  },
  server: {
    port: 3000,
    open: true,
  },
  preview: {
    port: 3000,
  },
})


--- functions/package.json ---

{
  "name": "functions",
  "scripts": {
    "lint": "eslint --ext .js,.ts .",
    "build": "tsc",
    "build:watch": "tsc --watch",
    "serve": "npm run build && firebase emulators:start --only functions",
    "shell": "npm run build && firebase functions:shell",
    "start": "npm run shell",
    "deploy": "firebase deploy --only functions",
    "logs": "firebase functions:log"
  },
  "engines": {
    "node": "18"
  },
  "main": "lib/index.js",
  "dependencies": {
    "firebase-admin": "^11.8.0",
    "firebase-functions": "^4.3.1"
  },
  "devDependencies": {
    "@typescript-eslint/eslint-plugin": "^5.12.0",
    "@typescript-eslint/parser": "^5.12.0",
    "eslint": "^8.9.0",
    "eslint-config-google": "^0.14.0",
    "eslint-plugin-import": "^2.25.4",
    "typescript": "^4.9.0"
  },
  "private": true
}


--- functions/tsconfig.json ---

{
  "compilerOptions": {
    "module": "commonjs",
    "noImplicitReturns": true,
    "noUnusedLocals": true,
    "outDir": "lib",
    "sourceMap": true,
    "strict": true,
    "target": "es2017"
  },
  "compileOnSave": true,
  "include": [
    "src"
  ]
}


--- src/App.tsx ---

import { BrowserRouter as Router, Routes, Route } from 'react-router-dom'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import { Toaster } from 'sonner'
import { AuthProvider } from '@/contexts/AuthContext'
import { ThemeProvider } from '@/contexts/ThemeContext'
import { ProtectedRoute } from '@/components/ProtectedRoute'
import { Layout } from '@/components/Layout'

import { AuthRedirector } from '@/components/AuthRedirector'
import LandingPage from '@/pages/LandingPage'
import { LoginPage } from '@/pages/LoginPage'
import { RegisterPage } from '@/pages/RegisterPage'
import { DashboardPage } from '@/pages/DashboardPage'
import { TasksPage } from '@/pages/TasksPage'
import { WorkspacesPage } from '@/pages/WorkspacePage'
import { ProjectsPage } from '@/pages/ProjectsPage'
import { GardenPage } from '@/pages/GardenPage'
import { AnalyticsPage } from '@/pages/AnalyticsPage'
import { SettingsPage } from '@/pages/SettingsPage'
import { ProfilePage } from '@/pages/ProfilePage'
import { NotFoundPage } from '@/pages/NotFoundPage'

// Create a client
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes
      retry: (failureCount, error: any) => {
        if (error?.status === 404) return false
        return failureCount < 3
      },
    },
  },
})

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider>
        <AuthProvider>
          <Router future={{
            v7_startTransition: true,
            v7_relativeSplatPath: true
          }}>
            <div className="min-h-screen bg-background text-foreground">
              <Routes>
                {/* Public routes */}
                <Route path="/" element={<LandingPage />} />
                <Route path="/dashboard" element={<AuthRedirector />} />
                <Route path="/login" element={<LoginPage />} />
                <Route path="/register" element={<RegisterPage />} />
                
                {/* Protected routes */}
                <Route
                  path="/app/*"
                  element={
                    <ProtectedRoute>
                      <Layout>
                        <Routes>
                          <Route index element={<DashboardPage />} />
                          <Route path="tasks" element={<TasksPage />} />
                          <Route path="workspaces" element={<WorkspacesPage />} />
                          <Route path="projects" element={<ProjectsPage />} />
                          <Route path="garden" element={<GardenPage />} />
                          <Route path="analytics" element={<AnalyticsPage />} />
                          <Route path="settings" element={<SettingsPage />} />
                          <Route path="profile" element={<ProfilePage />} />
                        </Routes>
                      </Layout>
                    </ProtectedRoute>
                  }
                />
                
                {/* 404 route */}
                <Route path="*" element={<NotFoundPage />} />
              </Routes>
              
              <Toaster 
                position="top-right"
                toastOptions={{
                  className: 'bg-background border-border text-foreground',
                }}
              />
            </div>
          </Router>
        </AuthProvider>
      </ThemeProvider>
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  )
}

export default App


--- src/index.css ---

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --radius: 0.5rem;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
  }

  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

/* Custom scrollbar */
::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

::-webkit-scrollbar-track {
  @apply bg-muted;
}

::-webkit-scrollbar-thumb {
  @apply bg-muted-foreground/30 rounded-full;
}

::-webkit-scrollbar-thumb:hover {
  @apply bg-muted-foreground/50;
}

/* Custom animations */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideIn {
  from {
    transform: translateX(-100%);
  }
  to {
    transform: translateX(0);
  }
}

@keyframes pulse-subtle {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.8;
  }
}

.animate-fadeIn {
  animation: fadeIn 0.3s ease-out;
}

.animate-slideIn {
  animation: slideIn 0.3s ease-out;
}

.animate-pulse-subtle {
  animation: pulse-subtle 2s infinite;
}

/* Glassmorphism effect */
.glass {
  @apply bg-white/10 backdrop-blur-lg border border-white/20;
}

.glass-dark {
  @apply bg-black/10 backdrop-blur-lg border border-black/20;
}

/* Task card hover effects */
.task-card {
  @apply transition-all duration-200 hover:shadow-md hover:scale-[1.02];
}

/* Sidebar transition */
.sidebar-transition {
  @apply transition-all duration-300 ease-in-out;
}

/* Focus ring for accessibility */
.focus-ring {
  @apply focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2;
}

/* Loading spinner */
.spinner {
  @apply animate-spin rounded-full border-2 border-current border-t-transparent;
}

/* Custom button variants */
.btn-gradient {
  @apply bg-gradient-to-r from-primary to-primary/80 hover:from-primary/90 hover:to-primary/70 text-primary-foreground;
}

/* Calendar custom styles */
.rdp {
  --rdp-cell-size: 40px;
  --rdp-accent-color: hsl(var(--primary));
  --rdp-background-color: hsl(var(--muted));
}

/* Drag and drop styles */
.dragging {
  @apply opacity-50 transform rotate-3;
}

.drop-zone {
  @apply bg-primary/10 border-2 border-dashed border-primary;
}

/* Pomodoro timer styles */
.timer-circle {
  transform-origin: center;
  transform: rotate(-90deg);
}

/* Achievement badge styles */
.achievement-badge {
  @apply bg-gradient-to-br from-yellow-400 to-orange-500 text-white shadow-lg;
}

/* Garden plant animations */
.plant-grow {
  animation: plantGrow 2s ease-out;
}

@keyframes plantGrow {
  0% {
    transform: scale(0) rotate(-10deg);
    opacity: 0;
  }
  50% {
    transform: scale(1.1) rotate(5deg);
    opacity: 0.8;
  }
  100% {
    transform: scale(1) rotate(0deg);
    opacity: 1;
  }
}

/* Team collaboration indicators */
.collaboration-indicator {
  animation: pulse 2s infinite;
}

/* Stats dashboard charts */
.chart-container {
  @apply p-4 bg-card rounded-lg border shadow-sm;
}

/* Mobile responsive adjustments */
@media (max-width: 768px) {
  .mobile-optimized {
    @apply text-sm p-2;
  }
  
  .mobile-sidebar {
    @apply fixed inset-0 z-50 bg-background/80 backdrop-blur-sm;
  }
}

/* Line clamp utilities */
.line-clamp-1 {
  overflow: hidden;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 1;
}

.line-clamp-2 {
  overflow: hidden;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 2;
}

.line-clamp-3 {
  overflow: hidden;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 3;
}

/* Print styles */
@media print {
  .no-print {
    display: none !important;
  }
  
  .print-optimize {
    @apply text-black bg-white;
  }
}


--- src/main.tsx ---

import React from 'react'
import ReactDOM from 'react-dom/client'
import { initializeApp } from './services/firebase'
import App from './App'
import './index.css'

// Initialize Firebase
initializeApp()

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
)


--- src/vite-env.d.ts ---

/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_FIREBASE_API_KEY: string
  readonly VITE_FIREBASE_AUTH_DOMAIN: string
  readonly VITE_FIREBASE_PROJECT_ID: string
  readonly VITE_FIREBASE_STORAGE_BUCKET: string
  readonly VITE_FIREBASE_MESSAGING_SENDER_ID: string
  readonly VITE_FIREBASE_APP_ID: string
  readonly VITE_APP_NAME: string
  readonly VITE_APP_VERSION: string
  readonly VITE_APP_ENVIRONMENT: string
  readonly VITE_API_BASE_URL: string
  readonly VITE_API_TIMEOUT: string
  readonly VITE_GOOGLE_ANALYTICS_ID: string
  readonly VITE_ENABLE_ANALYTICS: string
  readonly VITE_ENABLE_NOTIFICATIONS: string
  readonly VITE_ENABLE_GARDEN: string
  readonly VITE_ENABLE_COLLABORATION: string
  readonly VITE_SUPPORT_EMAIL: string
  readonly VITE_FEEDBACK_URL: string
}

interface ImportMeta {
  readonly env: ImportMetaEnv
}


--- src/components/AuthRedirector.tsx ---

import { useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '@/contexts/AuthContext';
import { Loader2 } from 'lucide-react';

export function AuthRedirector() {
  const { isAuthenticated, loading } = useAuth();
  const navigate = useNavigate();

  useEffect(() => {
    if (!loading) {
      if (isAuthenticated) {
        navigate('/app');
      } else {
        navigate('/login');
      }
    }
  }, [isAuthenticated, loading, navigate]);

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="flex flex-col items-center space-y-4">
          <Loader2 className="h-8 w-8 animate-spin text-indigo-600" />
          <p className="text-gray-600">Загрузка...</p>
        </div>
      </div>
    );
  }

  return null;
}


--- src/components/CreateTaskModal.tsx ---

import React, { useState } from 'react';
import { toast } from 'sonner';

interface CreateTaskModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (taskData: TaskData) => void;
}

interface TaskData {
  title: string;
  description: string;
  priority: 'low' | 'medium' | 'high';
  category: string;
  dueDate: string;
  estimatedTime: number;
}

export const CreateTaskModal: React.FC<CreateTaskModalProps> = ({
  isOpen,
  onClose,
  onSubmit,
}) => {
  const [formData, setFormData] = useState<TaskData>({
    title: '',
    description: '',
    priority: 'medium',
    category: '',
    dueDate: '',
    estimatedTime: 25,
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!formData.title.trim()) {
      toast.error('Название задачи обязательно');
      return;
    }

    onSubmit(formData);
    
    // Сброс формы
    setFormData({
      title: '',
      description: '',
      priority: 'medium',
      category: '',
      dueDate: '',
      estimatedTime: 25,
    });
    
    onClose();
    toast.success('Задача создана успешно!');
  };

  const handleChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>
  ) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: name === 'estimatedTime' ? parseInt(value) || 0 : value,
    }));
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 overflow-y-auto">
      <div className="flex items-center justify-center min-h-screen px-4 pt-4 pb-20 text-center sm:block sm:p-0">
        {/* Overlay */}
        <div
          className="fixed inset-0 transition-opacity bg-black bg-opacity-50"
          onClick={onClose}
        />

        {/* Modal */}
        <div className="inline-block w-full max-w-md p-6 my-8 overflow-hidden text-left align-middle transition-all transform bg-white shadow-xl rounded-lg border border-gray-200">
          <div className="flex items-center justify-between mb-4">
            <h3 className="text-lg font-semibold text-slate-800">
              Создать новую задачу
            </h3>
            <button
              onClick={onClose}
              className="text-slate-400 hover:text-slate-600 transition-colors"
            >
              ✕
            </button>
          </div>

          <form onSubmit={handleSubmit} className="space-y-4">
            {/* Название */}
            <div>
              <label className="block text-sm font-medium text-slate-700 mb-1">
                Название задачи *
              </label>
              <input
                type="text"
                name="title"
                value={formData.title}
                onChange={handleChange}
                className="w-full px-3 py-2 border border-slate-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white text-slate-900 placeholder:text-slate-500"
                placeholder="Введите название задачи..."
                required
              />
            </div>

            {/* Описание */}
            <div>
              <label className="block text-sm font-medium text-slate-700 mb-1">
                Описание
              </label>
              <textarea
                name="description"
                value={formData.description}
                onChange={handleChange}
                rows={3}
                className="w-full px-3 py-2 border border-slate-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white text-slate-900 placeholder:text-slate-500"
                placeholder="Добавьте описание задачи..."
              />
            </div>

            {/* Приоритет и Категория */}
            <div className="grid grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium text-slate-700 mb-1">
                  Приоритет
                </label>
                <select
                  name="priority"
                  value={formData.priority}
                  onChange={handleChange}
                  className="w-full px-3 py-2 border border-slate-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white text-slate-900"
                >
                  <option value="low">🟢 Низкий</option>
                  <option value="medium">🟡 Средний</option>
                  <option value="high">🔴 Высокий</option>
                </select>
              </div>

              <div>
                <label className="block text-sm font-medium text-slate-700 mb-1">
                  Время (мин)
                </label>
                <input
                  type="number"
                  name="estimatedTime"
                  value={formData.estimatedTime}
                  onChange={handleChange}
                  min="5"
                  max="480"
                  className="w-full px-3 py-2 border border-slate-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white text-slate-900"
                />
              </div>
            </div>

            {/* Категория и Дата */}
            <div className="grid grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium text-slate-700 mb-1">
                  Категория
                </label>
                <input
                  type="text"
                  name="category"
                  value={formData.category}
                  onChange={handleChange}
                  className="w-full px-3 py-2 border border-slate-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white text-slate-900 placeholder:text-slate-500"
                  placeholder="Работа, Личное..."
                />
              </div>

              <div>
                <label className="block text-sm font-medium text-slate-700 mb-1">
                  Срок выполнения
                </label>
                <input
                  type="date"
                  name="dueDate"
                  value={formData.dueDate}
                  onChange={handleChange}
                  className="w-full px-3 py-2 border border-slate-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white text-slate-900"
                />
              </div>
            </div>

            {/* Кнопки */}
            <div className="flex space-x-3 pt-4">
              <button
                type="button"
                onClick={onClose}
                className="flex-1 px-4 py-2 text-sm font-medium text-slate-700 bg-slate-100 border border-slate-300 rounded-md hover:bg-slate-200 transition-colors"
              >
                Отмена
              </button>
              <button
                type="submit"
                className="flex-1 px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-transparent rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors"
              >
                Создать задачу
              </button>
            </div>
          </form>
        </div>
      </div>
    </div>
  );
};


--- src/components/DemoBanner.tsx ---

import { shouldUseMockServices } from '@/lib/mockFirebase'

export const DemoBanner = () => {
  if (!shouldUseMockServices()) {
    return null
  }

  return (
    <div className="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-4 mb-4">
      <div className="flex items-center">
        <div className="text-yellow-500 mr-3">
          <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
            <path
              fillRule="evenodd"
              d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z"
              clipRule="evenodd"
            />
          </svg>
        </div>
        <div className="flex-1">
          <p className="text-sm font-medium">
            🔥 Демо режим активен
          </p>
          <p className="text-xs mt-1">
            Настройте Firebase в файле .env.local для полной функциональности. 
            Сейчас приложение работает в демо-режиме с ограниченными возможностями.
          </p>
        </div>
      </div>
    </div>
  )
}


--- src/components/Layout.tsx ---

import React, { useState } from 'react'
import { Link, useLocation, useNavigate } from 'react-router-dom'
import { useAuth } from '@/contexts/AuthContext'
import { useAppStore } from '@/stores/appStore'
import { usePomodoroStore } from '@/stores/pomodoroStore'
import { cn } from '@/utils/helpers'
import { ROUTES } from '@/constants'
import { DemoBanner } from './DemoBanner'
import { CreateTaskModal } from './CreateTaskModal'
import { WorkspaceSwitcher } from './WorkspaceSwitcher'

interface LayoutProps {
  children: React.ReactNode
}

const navigation = [
  { name: 'Панель', href: ROUTES.DASHBOARD, icon: '📊' },
  { name: 'Задачи', href: ROUTES.TASKS, icon: '✅' },
  { name: 'Пространства', href: ROUTES.WORKSPACES, icon: '🏢' },
  { name: 'Проекты', href: ROUTES.PROJECTS, icon: '📁' },
  { name: 'Сад', href: ROUTES.GARDEN, icon: '🌱' },
  { name: 'Аналитика', href: ROUTES.ANALYTICS, icon: '📈' },
  { name: 'Настройки', href: ROUTES.SETTINGS, icon: '⚙️' },
]

export const Layout: React.FC<LayoutProps> = ({ children }) => {
  const location = useLocation()
  const navigate = useNavigate()
  const { currentUser, logout } = useAuth()
  const { sidebarOpen, setSidebarOpen } = useAppStore()
  const { status, timeRemaining, sessionType, pauseTimer, resumeTimer, stopTimer } = usePomodoroStore()
  const [isCreateTaskModalOpen, setIsCreateTaskModalOpen] = useState(false)

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60)
    const secs = seconds % 60
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
  }

  const handleLogout = async () => {
    try {
      await logout()
    } catch (error) {
      console.error('Logout error:', error)
    }
  }

  const handleCreateTask = (taskData: any) => {
    // Здесь будет логика сохранения задачи
    console.log('Создаётся задача:', taskData)
    // TODO: Интеграция с backend/Firebase
  }

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Sidebar */}
      <div className={cn(
        'fixed inset-y-0 left-0 z-50 w-64 bg-white shadow-lg transform transition-transform duration-200 ease-in-out',
        sidebarOpen ? 'translate-x-0' : '-translate-x-full'
      )}>
        <div className="flex flex-col h-full">
          {/* Logo */}
          <div className="flex items-center justify-between h-16 px-6 border-b">
            <h1 className="text-xl font-bold text-gray-900">ProgressQuest</h1>
            <button
              onClick={() => setSidebarOpen(false)}
              className="p-2 rounded-md text-gray-400 hover:text-gray-600 hover:bg-gray-100 lg:hidden"
            >
              ✕
            </button>
          </div>

          {/* Pomodoro Timer */}
          {status !== 'idle' && (
            <div className="px-6 py-4 border-b bg-gradient-to-r from-blue-50 to-purple-50">
              <div className="text-center">
                <div className="text-xs font-medium text-gray-600 uppercase tracking-wide mb-1">
                  {sessionType === 'work' ? 'Работа' : sessionType === 'short_break' ? 'Короткий перерыв' : 'Длинный перерыв'}
                </div>
                <div className="text-2xl font-bold text-gray-900 mb-2">
                  {formatTime(timeRemaining)}
                </div>
                <div className="flex justify-center space-x-2">
                  {status === 'running' ? (
                    <button
                      onClick={pauseTimer}
                      className="px-3 py-1 text-xs bg-yellow-500 text-white rounded hover:bg-yellow-600"
                    >
                      Пауза
                    </button>
                  ) : (
                    <button
                      onClick={resumeTimer}
                      className="px-3 py-1 text-xs bg-green-500 text-white rounded hover:bg-green-600"
                    >
                      Продолжить
                    </button>
                  )}
                  <button
                    onClick={stopTimer}
                    className="px-3 py-1 text-xs bg-red-500 text-white rounded hover:bg-red-600"
                  >
                    Стоп
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* Navigation */}
          <nav className="flex-1 px-6 py-4 space-y-2">
            {navigation.map((item) => {
              const isActive = location.pathname === item.href ||
                (item.href !== ROUTES.DASHBOARD && location.pathname.startsWith(item.href))
              
              return (
                <Link
                  key={item.name}
                  to={item.href}
                  className={cn(
                    'flex items-center px-3 py-2 text-sm font-medium rounded-md transition-colors',
                    isActive
                      ? 'bg-blue-100 text-blue-700'
                      : 'text-gray-600 hover:text-gray-900 hover:bg-gray-100'
                  )}
                >
                  <span className="mr-3 text-lg">{item.icon}</span>
                  {item.name}
                </Link>
              )
            })}
          </nav>

          {/* User Menu */}
          <div className="px-6 py-4 border-t">
            <div className="flex items-center">
              <div className="flex-shrink-0">
                {currentUser?.photoURL ? (
                  <img
                    className="h-8 w-8 rounded-full"
                    src={currentUser.photoURL}
                    alt={currentUser.displayName || ''}
                  />
                ) : (
                  <div className="h-8 w-8 rounded-full bg-gray-300 flex items-center justify-center">
                    <span className="text-sm text-gray-600">👤</span>
                  </div>
                )}
              </div>
              <div className="ml-3 flex-1">
                <p className="text-sm font-medium text-gray-900">
                  {currentUser?.displayName || 'Пользователь'}
                </p>
                <div className="flex space-x-2 mt-1">
                  <Link
                    to={ROUTES.PROFILE}
                    className="text-xs text-blue-600 hover:text-blue-800"
                  >
                    Профиль
                  </Link>
                  <button
                    onClick={handleLogout}
                    className="text-xs text-red-600 hover:text-red-800"
                  >
                    Выйти
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Main content */}
      <div className={cn(
        'transition-all duration-200 ease-in-out',
        sidebarOpen ? 'lg:pl-64' : ''
      )}>
        {/* Top bar */}
        <div className="bg-white shadow-sm border-b h-16 flex items-center justify-between px-6">
          <button
            onClick={() => setSidebarOpen(!sidebarOpen)}
            className="p-2 rounded-md text-gray-400 hover:text-gray-600 hover:bg-gray-100"
          >
            ☰
          </button>
          
          <div className="flex items-center space-x-4">
            {/* Workspace Switcher */}
            <WorkspaceSwitcher className="w-64" compact={false} />
            
            {/* Quick actions */}
            <button
              onClick={() => setIsCreateTaskModalOpen(true)}
              className="px-3 py-2 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors"
            >
              + Новая задача
            </button>
          </div>
        </div>

        {/* Page content */}
        <main className="flex-1">
          <div className="p-6">
            <DemoBanner />
            {children}
          </div>
        </main>
      </div>

      {/* Overlay for mobile */}
      {sidebarOpen && (
        <div
          className="fixed inset-0 z-40 bg-black bg-opacity-50 lg:hidden"
          onClick={() => setSidebarOpen(false)}
        />
      )}

      {/* Create Task Modal */}
      <CreateTaskModal
        isOpen={isCreateTaskModalOpen}
        onClose={() => setIsCreateTaskModalOpen(false)}
        onSubmit={handleCreateTask}
      />
    </div>
  )
}


--- src/components/ProtectedRoute.tsx ---

import React from 'react'
import { Navigate, useLocation } from 'react-router-dom'
import { useAuth } from '@/contexts/AuthContext'

interface ProtectedRouteProps {
  children: React.ReactNode
}

export const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {
  const { currentUser, loading } = useAuth()
  const location = useLocation()

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-blue-600"></div>
      </div>
    )
  }

  if (!currentUser) {
    // Redirect them to the home page instead of login page
    return <Navigate to="/" replace />
  }

  return <>{children}</>
}



--- src/components/WorkspaceCard.tsx ---

import React, { useState } from 'react'
import { WorkspaceClientDto } from '@/services/workspaceService'
import { useAppStore } from '@/stores/appStore'
import { formatDistanceToNow } from 'date-fns'
import { ru } from 'date-fns/locale'

interface WorkspaceCardProps {
  workspace: WorkspaceClientDto
  onEdit?: (workspace: WorkspaceClientDto) => void
  onDelete?: (workspaceId: string) => void
  onSelect?: (workspace: WorkspaceClientDto) => void
  isSelected?: boolean
  showActions?: boolean
  variant?: 'default' | 'compact' | 'detailed'
}

export const WorkspaceCard: React.FC<WorkspaceCardProps> = ({
  workspace,
  onEdit,
  onDelete,
  onSelect,
  isSelected = false,
  showActions = true,
  variant = 'default',
}) => {
  const [showDropdown, setShowDropdown] = useState(false)
  const { setCurrentWorkspace } = useAppStore()

  const handleSelect = () => {
    if (onSelect) {
      onSelect(workspace)
    } else {
      setCurrentWorkspace(workspace as any) // TODO: Нужно будет привести типы в соответствие
    }
  }

  const handleEdit = (e: React.MouseEvent) => {
    e.stopPropagation()
    setShowDropdown(false)
    onEdit?.(workspace)
  }

  const handleDelete = (e: React.MouseEvent) => {
    e.stopPropagation()
    setShowDropdown(false)
    if (window.confirm(`Вы уверены, что хотите удалить рабочее пространство "${workspace.name}"?`)) {
      onDelete?.(workspace.id)
    }
  }

  const getApproachIcon = (approach: string) => {
    switch (approach) {
      case 'CALENDAR': return '📅'
      case 'GTD': return '⚡'
      case 'KANBAN': return '📋'
      case 'EISENHOWER': return '🎯'
      default: return '📋'
    }
  }

  const getApproachLabel = (approach: string) => {
    switch (approach) {
      case 'CALENDAR': return 'Календарь'
      case 'GTD': return 'GTD'
      case 'KANBAN': return 'Канбан'
      case 'EISENHOWER': return 'Эйзенхауэр'
      default: return 'Канбан'
    }
  }

  const getRoleLabel = (role?: string) => {
    switch (role) {
      case 'owner': return 'Владелец'
      case 'admin': return 'Администратор'
      case 'manager': return 'Менеджер'
      case 'editor': return 'Редактор'
      case 'member': return 'Участник'
      case 'viewer': return 'Наблюдатель'
      default: return 'Участник'
    }
  }

  const baseClasses = `
    relative bg-white rounded-lg border border-slate-200 shadow-sm hover:shadow-lg 
    transition-all duration-200 cursor-pointer group
    ${isSelected ? 'ring-2 ring-blue-500 border-blue-500' : 'hover:border-slate-300'}
  `

  const compactClasses = 'p-3'
  const defaultClasses = 'p-4'
  const detailedClasses = 'p-6'

  const cardClasses = `
    ${baseClasses} 
    ${variant === 'compact' ? compactClasses : variant === 'detailed' ? detailedClasses : defaultClasses}
  `

  return (
    <div className={cardClasses} onClick={handleSelect}>
      {/* Header */}
      <div className="flex items-start justify-between mb-3">
        <div className="flex items-start space-x-3 flex-1 min-w-0">
          {/* Type Icon */}
          <div className="flex-shrink-0 mt-1">
            <span className="text-lg">
              {workspace.isPersonal ? '👤' : '👥'}
            </span>
          </div>

          {/* Content */}
          <div className="flex-1 min-w-0">
            <h3 className="text-lg font-semibold text-slate-900 truncate">
              {workspace.name}
            </h3>
            
            {workspace.description && variant !== 'compact' && (
              <p className="text-sm text-slate-600 mt-1 line-clamp-2">
                {workspace.description}
              </p>
            )}

            {/* Metadata */}
            <div className="flex items-center space-x-4 mt-2 text-xs text-slate-500">
              <span className="flex items-center">
                {getApproachIcon(workspace.activeApproach)}
                <span className="ml-1">{getApproachLabel(workspace.activeApproach)}</span>
              </span>
              
              {workspace.currentUserWorkspaceRole && (
                <span className="px-2 py-1 bg-slate-100 rounded-full">
                  {getRoleLabel(workspace.currentUserWorkspaceRole)}
                </span>
              )}
              
              {variant === 'detailed' && (
                <span>
                  Обновлено {formatDistanceToNow(new Date(workspace.updatedAt), { 
                    addSuffix: true,
                    locale: ru 
                  })}
                </span>
              )}
            </div>
          </div>
        </div>

        {/* Actions */}
        {showActions && (
          <div className="relative flex-shrink-0">
            <button
              onClick={(e) => {
                e.stopPropagation()
                setShowDropdown(!showDropdown)
              }}
              className="p-1 text-slate-400 hover:text-slate-600 opacity-0 group-hover:opacity-100 transition-opacity"
            >
              <span className="block w-5 h-5 text-center">⋮</span>
            </button>

            {showDropdown && (
              <div className="absolute right-0 top-full mt-1 w-48 bg-white rounded-md shadow-lg border border-slate-200 z-10">
                <div className="py-1">
                  {onEdit && (
                    <button
                      onClick={handleEdit}
                      className="block w-full text-left px-4 py-2 text-sm text-slate-700 hover:bg-slate-50"
                    >
                      ✏️ Редактировать
                    </button>
                  )}
                  
                  <button
                    onClick={handleSelect}
                    className="block w-full text-left px-4 py-2 text-sm text-slate-700 hover:bg-slate-50"
                  >
                    🎯 Выбрать как активное
                  </button>
                  
                  {onDelete && workspace.currentUserWorkspaceRole === 'owner' && (
                    <>
                      <div className="border-t border-slate-200 my-1" />
                      <button
                        onClick={handleDelete}
                        className="block w-full text-left px-4 py-2 text-sm text-red-600 hover:bg-red-50"
                      >
                        🗑️ Удалить
                      </button>
                    </>
                  )}
                </div>
              </div>
            )}
          </div>
        )}
      </div>

      {/* Tags */}
      {workspace.defaultTags && workspace.defaultTags.length > 0 && variant !== 'compact' && (
        <div className="flex flex-wrap gap-1 mt-3">
          {workspace.defaultTags.slice(0, 3).map((tag) => (
            <span
              key={tag}
              className="inline-block px-2 py-1 text-xs bg-blue-100 text-blue-700 rounded-full"
            >
              {tag}
            </span>
          ))}
          {workspace.defaultTags.length > 3 && (
            <span className="inline-block px-2 py-1 text-xs bg-slate-100 text-slate-600 rounded-full">
              +{workspace.defaultTags.length - 3}
            </span>
          )}
        </div>
      )}

      {/* Footer for detailed variant */}
      {variant === 'detailed' && (
        <div className="flex items-center justify-between mt-4 pt-3 border-t border-slate-100">
          <div className="flex items-center space-x-4 text-xs text-slate-500">
            <span>
              Создано {formatDistanceToNow(new Date(workspace.createdAt), { 
                addSuffix: true,
                locale: ru 
              })}
            </span>
          </div>
          
          <div className="flex items-center space-x-2">
            {workspace.isPersonal ? (
              <span className="text-xs text-slate-500">Личное</span>
            ) : (
              <span className="text-xs text-slate-500">Командное</span>
            )}
          </div>
        </div>
      )}

      {/* Click overlay to close dropdown */}
      {showDropdown && (
        <div
          className="fixed inset-0 z-5"
          onClick={(e) => {
            e.stopPropagation()
            setShowDropdown(false)
          }}
        />
      )}
    </div>
  )
}


--- src/components/WorkspaceModal.tsx ---

import React, { useState, useEffect } from 'react'
import { toast } from 'sonner'
import { WorkspaceClientDto, CreateWorkspacePayload } from '@/services/workspaceService'

interface WorkspaceModalProps {
  isOpen: boolean
  onClose: () => void
  onSubmit: (workspaceData: CreateWorkspacePayload) => void
  workspace?: WorkspaceClientDto | null
  mode: 'create' | 'edit'
}

interface WorkspaceFormData {
  name: string
  description: string
  isPersonal: boolean
  activeApproach: string
  defaultTags: string[]
  settings: {
    allowMembersToCreateTasks: boolean
    taskVisibility: string
  }
}

const APPROACH_OPTIONS = [
  { value: 'CALENDAR', label: '📅 Календарь', description: 'Организация по датам' },
  { value: 'GTD', label: '⚡ GTD', description: 'Getting Things Done' },
  { value: 'KANBAN', label: '📋 Канбан', description: 'Доски с колонками' },
  { value: 'EISENHOWER', label: '🎯 Эйзенхауэр', description: 'Матрица приоритетов' },
]

const TASK_VISIBILITY_OPTIONS = [
  { value: 'all_visible', label: 'Все видят все задачи' },
  { value: 'assigned_only', label: 'Только назначенные задачи' },
  { value: 'owner_and_assigned', label: 'Владелец и назначенные' },
]

export const WorkspaceModal: React.FC<WorkspaceModalProps> = ({
  isOpen,
  onClose,
  onSubmit,
  workspace,
  mode,
}) => {
  const [formData, setFormData] = useState<WorkspaceFormData>({
    name: '',
    description: '',
    isPersonal: true,
    activeApproach: 'CALENDAR',
    defaultTags: [],
    settings: {
      allowMembersToCreateTasks: true,
      taskVisibility: 'all_visible',
    },
  })

  const [tagInput, setTagInput] = useState('')
  const [isSubmitting, setIsSubmitting] = useState(false)

  // Заполняем форму данными workspace при редактировании
  useEffect(() => {
    if (mode === 'edit' && workspace) {
      setFormData({
        name: workspace.name,
        description: workspace.description || '',
        isPersonal: workspace.isPersonal,
        activeApproach: workspace.activeApproach,
        defaultTags: workspace.defaultTags || [],
        settings: {
          allowMembersToCreateTasks: workspace.settings?.allowMembersToCreateTasks ?? true,
          taskVisibility: workspace.settings?.taskVisibility || 'all_visible',
        },
      })
    } else if (mode === 'create') {
      // Сброс формы для создания нового workspace
      setFormData({
        name: '',
        description: '',
        isPersonal: true,
        activeApproach: 'CALENDAR',
        defaultTags: [],
        settings: {
          allowMembersToCreateTasks: true,
          taskVisibility: 'all_visible',
        },
      })
    }
  }, [mode, workspace, isOpen])

  const handleInputChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>
  ) => {
    const { name, value, type } = e.target
    
    if (type === 'checkbox') {
      const checked = (e.target as HTMLInputElement).checked
      if (name.startsWith('settings.')) {
        const settingKey = name.replace('settings.', '')
        setFormData(prev => ({
          ...prev,
          settings: {
            ...prev.settings,
            [settingKey]: checked,
          },
        }))
      } else {
        setFormData(prev => ({
          ...prev,
          [name]: checked,
        }))
      }
    } else if (name.startsWith('settings.')) {
      const settingKey = name.replace('settings.', '')
      setFormData(prev => ({
        ...prev,
        settings: {
          ...prev.settings,
          [settingKey]: value,
        },
      }))
    } else {
      setFormData(prev => ({
        ...prev,
        [name]: value,
      }))
    }
  }

  const addTag = () => {
    const tag = tagInput.trim()
    if (tag && !formData.defaultTags.includes(tag)) {
      setFormData(prev => ({
        ...prev,
        defaultTags: [...prev.defaultTags, tag],
      }))
      setTagInput('')
    }
  }

  const removeTag = (tagToRemove: string) => {
    setFormData(prev => ({
      ...prev,
      defaultTags: prev.defaultTags.filter(tag => tag !== tagToRemove),
    }))
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    
    if (!formData.name.trim()) {
      toast.error('Название рабочего пространства обязательно')
      return
    }

    setIsSubmitting(true)

    try {
      const payload: CreateWorkspacePayload = {
        name: formData.name.trim(),
        description: formData.description.trim() || null,
        isPersonal: formData.isPersonal,
        activeApproach: formData.activeApproach,
        defaultTags: formData.defaultTags,
        settings: formData.settings,
      }

      await onSubmit(payload)
      onClose()
      
      toast.success(
        mode === 'create' 
          ? 'Рабочее пространство создано!' 
          : 'Рабочее пространство обновлено!'
      )
    } catch (error) {
      console.error('Ошибка при сохранении рабочего пространства:', error)
      toast.error('Произошла ошибка при сохранении')
    } finally {
      setIsSubmitting(false)
    }
  }

  if (!isOpen) return null

  return (
    <div className="fixed inset-0 z-50 overflow-y-auto">
      <div className="flex items-center justify-center min-h-screen px-4 pt-4 pb-20 text-center sm:block sm:p-0">
        {/* Overlay */}
        <div
          className="fixed inset-0 transition-opacity bg-black bg-opacity-50"
          onClick={onClose}
        />

        {/* Modal */}
        <div className="inline-block w-full max-w-2xl p-6 my-8 overflow-hidden text-left align-middle transition-all transform bg-white shadow-xl rounded-lg border border-gray-200">
          <div className="flex items-center justify-between mb-6">
            <h3 className="text-xl font-semibold text-slate-800">
              {mode === 'create' ? 'Создать рабочее пространство' : 'Редактировать рабочее пространство'}
            </h3>
            <button
              onClick={onClose}
              className="text-slate-400 hover:text-slate-600 transition-colors"
            >
              ✕
            </button>
          </div>

          <form onSubmit={handleSubmit} className="space-y-6">
            {/* Название и описание */}
            <div className="grid grid-cols-1 gap-4">
              <div>
                <label className="block text-sm font-medium text-slate-700 mb-2">
                  Название пространства *
                </label>
                <input
                  type="text"
                  name="name"
                  value={formData.name}
                  onChange={handleInputChange}
                  className="w-full px-3 py-2 border border-slate-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white text-slate-900"
                  placeholder="Мой проект, Работа, Личное..."
                  required
                />
              </div>

              <div>
                <label className="block text-sm font-medium text-slate-700 mb-2">
                  Описание
                </label>
                <textarea
                  name="description"
                  value={formData.description}
                  onChange={handleInputChange}
                  rows={3}
                  className="w-full px-3 py-2 border border-slate-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white text-slate-900"
                  placeholder="Кратко опишите назначение этого пространства..."
                />
              </div>
            </div>

            {/* Тип пространства */}
            <div>
              <label className="block text-sm font-medium text-slate-700 mb-2">
                Тип пространства
              </label>
              <div className="flex space-x-4">
                <label className="flex items-center">
                  <input
                    type="radio"
                    name="isPersonal"
                    checked={formData.isPersonal}
                    onChange={() => setFormData(prev => ({ ...prev, isPersonal: true }))}
                    className="mr-2 text-blue-600"
                  />
                  <span className="text-sm text-slate-700">
                    👤 Личное (только для меня)
                  </span>
                </label>
                <label className="flex items-center">
                  <input
                    type="radio"
                    name="isPersonal"
                    checked={!formData.isPersonal}
                    onChange={() => setFormData(prev => ({ ...prev, isPersonal: false }))}
                    className="mr-2 text-blue-600"
                  />
                  <span className="text-sm text-slate-700">
                    👥 Командное (с участниками)
                  </span>
                </label>
              </div>
            </div>

            {/* Подход к организации */}
            <div>
              <label className="block text-sm font-medium text-slate-700 mb-2">
                Подход к организации задач
              </label>
              <div className="grid grid-cols-2 gap-3">
                {APPROACH_OPTIONS.map((option) => (
                  <label
                    key={option.value}
                    className={`flex items-center p-3 border rounded-lg cursor-pointer transition-colors ${
                      formData.activeApproach === option.value
                        ? 'border-blue-500 bg-blue-50 text-blue-700'
                        : 'border-slate-300 hover:bg-slate-50'
                    }`}
                  >
                    <input
                      type="radio"
                      name="activeApproach"
                      value={option.value}
                      checked={formData.activeApproach === option.value}
                      onChange={handleInputChange}
                      className="sr-only"
                    />
                    <div>
                      <div className="font-medium">{option.label}</div>
                      <div className="text-xs text-slate-500">{option.description}</div>
                    </div>
                  </label>
                ))}
              </div>
            </div>

            {/* Теги по умолчанию */}
            <div>
              <label className="block text-sm font-medium text-slate-700 mb-2">
                Теги по умолчанию
              </label>
              <div className="flex space-x-2 mb-2">
                <input
                  type="text"
                  value={tagInput}
                  onChange={(e) => setTagInput(e.target.value)}
                  onKeyPress={(e) => e.key === 'Enter' && (e.preventDefault(), addTag())}
                  className="flex-1 px-3 py-2 border border-slate-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white text-slate-900"
                  placeholder="Введите тег и нажмите Enter"
                />
                <button
                  type="button"
                  onClick={addTag}
                  className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors"
                >
                  Добавить
                </button>
              </div>
              {formData.defaultTags.length > 0 && (
                <div className="flex flex-wrap gap-2">
                  {formData.defaultTags.map((tag) => (
                    <span
                      key={tag}
                      className="inline-flex items-center px-2 py-1 text-xs bg-blue-100 text-blue-800 rounded-full"
                    >
                      {tag}
                      <button
                        type="button"
                        onClick={() => removeTag(tag)}
                        className="ml-1 text-blue-600 hover:text-blue-800"
                      >
                        ×
                      </button>
                    </span>
                  ))}
                </div>
              )}
            </div>

            {/* Настройки */}
            {!formData.isPersonal && (
              <div>
                <h4 className="text-sm font-medium text-slate-700 mb-3">Настройки команды</h4>
                <div className="space-y-3">
                  <label className="flex items-center">
                    <input
                      type="checkbox"
                      name="settings.allowMembersToCreateTasks"
                      checked={formData.settings.allowMembersToCreateTasks}
                      onChange={handleInputChange}
                      className="mr-2 text-blue-600"
                    />
                    <span className="text-sm text-slate-700">
                      Разрешить участникам создавать задачи
                    </span>
                  </label>

                  <div>
                    <label className="block text-sm font-medium text-slate-700 mb-1">
                      Видимость задач
                    </label>
                    <select
                      name="settings.taskVisibility"
                      value={formData.settings.taskVisibility}
                      onChange={handleInputChange}
                      className="w-full px-3 py-2 border border-slate-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white text-slate-900"
                    >
                      {TASK_VISIBILITY_OPTIONS.map((option) => (
                        <option key={option.value} value={option.value}>
                          {option.label}
                        </option>
                      ))}
                    </select>
                  </div>
                </div>
              </div>
            )}

            {/* Кнопки */}
            <div className="flex space-x-3 pt-4 border-t">
              <button
                type="button"
                onClick={onClose}
                disabled={isSubmitting}
                className="flex-1 px-4 py-2 text-sm font-medium text-slate-700 bg-slate-100 border border-slate-300 rounded-md hover:bg-slate-200 transition-colors disabled:opacity-50"
              >
                Отмена
              </button>
              <button
                type="submit"
                disabled={isSubmitting || !formData.name.trim()}
                className="flex-1 px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-transparent rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {isSubmitting 
                  ? 'Сохранение...' 
                  : mode === 'create' 
                    ? 'Создать пространство'
                    : 'Сохранить изменения'
                }
              </button>
            </div>
          </form>
        </div>
      </div>
    </div>
  )
}


--- src/components/WorkspaceSwitcher.tsx ---

import React, { useState, useRef, useEffect } from 'react'
import { Link } from 'react-router-dom'
import { useWorkspaces } from '@/hooks/useWorkspaces'
import { useWorkspaceStore } from '@/stores/workspaceStore'
import { WorkspaceClientDto } from '@/services/workspaceService'
import { ROUTES } from '@/constants'

interface WorkspaceSwitcherProps {
  className?: string
  compact?: boolean
}

export const WorkspaceSwitcher: React.FC<WorkspaceSwitcherProps> = ({
  className = '',
  compact = false
}) => {
  const [isOpen, setIsOpen] = useState(false)
  const [selectedWorkspaceId, setSelectedWorkspaceId] = useState<string | null>(null)
  const dropdownRef = useRef<HTMLDivElement>(null)

  const { currentWorkspace, setCurrentWorkspace } = useWorkspaceStore()
  const { data: workspacesData, isLoading } = useWorkspaces()

  const workspaces = workspacesData?.workspaces || []
  const activeWorkspace = currentWorkspace || workspaces.find(ws => ws.isPersonal)

  // Закрываем дропдаун при клике вне его
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false)
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [])

  const handleWorkspaceSelect = (workspace: WorkspaceClientDto) => {
    setCurrentWorkspace(workspace as any) // TODO: привести типы в соответствие
    setSelectedWorkspaceId(workspace.id)
    setIsOpen(false)
  }

  const getWorkspaceIcon = (workspace: WorkspaceClientDto) => {
    return workspace.isPersonal ? '👤' : '👥'
  }

  const getApproachIcon = (approach: string) => {
    switch (approach) {
      case 'CALENDAR': return '📅'
      case 'GTD': return '⚡'
      case 'KANBAN': return '📋'
      case 'EISENHOWER': return '🎯'
      default: return '📋'
    }
  }

  if (isLoading) {
    return (
      <div className={`${className} animate-pulse`}>
        <div className="h-10 bg-slate-200 rounded"></div>
      </div>
    )
  }

  if (workspaces.length === 0) {
    return (
      <div className={className}>
        <Link
          to={ROUTES.WORKSPACES}
          className="flex items-center w-full px-3 py-2 text-sm bg-blue-50 text-blue-700 rounded-lg hover:bg-blue-100 transition-colors"
        >
          <span className="mr-2">➕</span>
          {compact ? 'Создать' : 'Создать пространство'}
        </Link>
      </div>
    )
  }

  return (
    <div className={`relative ${className}`} ref={dropdownRef}>
      {/* Current Workspace Button */}
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center justify-between w-full px-3 py-2 text-left bg-white border border-slate-200 rounded-lg hover:bg-slate-50 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
      >
        <div className="flex items-center min-w-0 flex-1">
          <span className="mr-2 text-lg flex-shrink-0">
            {activeWorkspace ? getWorkspaceIcon(activeWorkspace) : '🏢'}
          </span>
          <div className="min-w-0 flex-1">
            <div className="font-medium text-slate-900 truncate">
              {activeWorkspace?.name || 'Выберите пространство'}
            </div>
            {!compact && activeWorkspace && (
              <div className="text-xs text-slate-500 truncate">
                {getApproachIcon(activeWorkspace.activeApproach)} 
                {activeWorkspace.isPersonal ? ' Личное' : ' Командное'}
              </div>
            )}
          </div>
        </div>
        <span className={`ml-2 transition-transform ${isOpen ? 'rotate-180' : ''}`}>
          ▼
        </span>
      </button>

      {/* Dropdown */}
      {isOpen && (
        <div className="absolute z-50 w-full mt-1 bg-white border border-slate-200 rounded-lg shadow-lg max-h-80 overflow-y-auto">
          {/* Personal Workspaces */}
          <div className="p-2">
            <div className="text-xs font-medium text-slate-500 uppercase tracking-wide px-2 py-1">
              Личные пространства
            </div>
            {workspaces
              .filter(ws => ws.isPersonal)
              .map((workspace) => (
                <button
                  key={workspace.id}
                  onClick={() => handleWorkspaceSelect(workspace)}
                  className={`flex items-center w-full px-2 py-2 text-sm rounded-md transition-colors ${
                    workspace.id === activeWorkspace?.id
                      ? 'bg-blue-100 text-blue-700'
                      : 'text-slate-700 hover:bg-slate-100'
                  }`}
                >
                  <span className="mr-2">{getWorkspaceIcon(workspace)}</span>
                  <div className="flex-1 min-w-0">
                    <div className="font-medium truncate">{workspace.name}</div>
                    {!compact && (
                      <div className="text-xs text-slate-500 truncate">
                        {getApproachIcon(workspace.activeApproach)} {workspace.activeApproach}
                      </div>
                    )}
                  </div>
                  {workspace.id === activeWorkspace?.id && (
                    <span className="ml-2 text-blue-600">✓</span>
                  )}
                </button>
              ))}
          </div>

          {/* Team Workspaces */}
          {workspaces.some(ws => !ws.isPersonal) && (
            <div className="border-t border-slate-200 p-2">
              <div className="text-xs font-medium text-slate-500 uppercase tracking-wide px-2 py-1">
                Командные пространства
              </div>
              {workspaces
                .filter(ws => !ws.isPersonal)
                .map((workspace) => (
                  <button
                    key={workspace.id}
                    onClick={() => handleWorkspaceSelect(workspace)}
                    className={`flex items-center w-full px-2 py-2 text-sm rounded-md transition-colors ${
                      workspace.id === activeWorkspace?.id
                        ? 'bg-blue-100 text-blue-700'
                        : 'text-slate-700 hover:bg-slate-100'
                    }`}
                  >
                    <span className="mr-2">{getWorkspaceIcon(workspace)}</span>
                    <div className="flex-1 min-w-0">
                      <div className="font-medium truncate">{workspace.name}</div>
                      {!compact && (
                        <div className="text-xs text-slate-500 truncate">
                          {getApproachIcon(workspace.activeApproach)} {workspace.activeApproach}
                          {workspace.currentUserWorkspaceRole && (
                            <span className="ml-1">
                              ({workspace.currentUserWorkspaceRole === 'owner' ? 'Владелец' : 'Участник'})
                            </span>
                          )}
                        </div>
                      )}
                    </div>
                    {workspace.id === activeWorkspace?.id && (
                      <span className="ml-2 text-blue-600">✓</span>
                    )}
                  </button>
                ))}
            </div>
          )}

          {/* Actions */}
          <div className="border-t border-slate-200 p-2">
            <Link
              to={ROUTES.WORKSPACES}
              onClick={() => setIsOpen(false)}
              className="flex items-center w-full px-2 py-2 text-sm text-blue-600 hover:bg-blue-50 rounded-md transition-colors"
            >
              <span className="mr-2">⚙️</span>
              Управление пространствами
            </Link>
            <Link
              to={`${ROUTES.WORKSPACES}?create=true`}
              onClick={() => setIsOpen(false)}
              className="flex items-center w-full px-2 py-2 text-sm text-green-600 hover:bg-green-50 rounded-md transition-colors"
            >
              <span className="mr-2">➕</span>
              Создать новое
            </Link>
          </div>
        </div>
      )}
    </div>
  )
}


--- src/components/ui/button.tsx ---

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }


--- src/components/ui/card.tsx ---

import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }


--- src/components/ui/dialog.tsx ---

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}


--- src/components/ui/input.tsx ---

import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }


--- src/components/ui/label.tsx ---

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }


--- src/components/ui/select.tsx ---

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-[--radix-select-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-select-content-transform-origin]",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}


--- src/constants/index.ts ---

// Application constants
export const APP_NAME = 'ProgressQuest Universal'
export const APP_VERSION = '1.0.0'

// Routes
export const ROUTES = {
  HOME: '/',
  LOGIN: '/login',
  REGISTER: '/register',
  DASHBOARD: '/app',
  TASKS: '/app/tasks',
  WORKSPACES: '/app/workspaces',
  PROJECTS: '/app/projects',
  GARDEN: '/app/garden',
  ANALYTICS: '/app/analytics',
  SETTINGS: '/app/settings',
  PROFILE: '/app/profile',
} as const

// Local Storage Keys
export const STORAGE_KEYS = {
  THEME: 'theme',
  USER_PREFERENCES: 'user_preferences',
  POMODORO_SETTINGS: 'pomodoro_settings',
  LAST_WORKSPACE: 'last_workspace',
} as const

// API Configuration
export const API_CONFIG = {
  TIMEOUT: 30000,
  RETRY_ATTEMPTS: 3,
  RETRY_DELAY: 1000,
} as const

// Pagination
export const PAGINATION = {
  DEFAULT_PAGE_SIZE: 20,
  MAX_PAGE_SIZE: 100,
} as const

// Validation
export const VALIDATION = {
  MIN_PASSWORD_LENGTH: 6,
  MAX_TASK_TITLE_LENGTH: 100,
  MAX_TASK_DESCRIPTION_LENGTH: 1000,
  MAX_PROJECT_NAME_LENGTH: 50,
  MAX_WORKSPACE_NAME_LENGTH: 50,
} as const

// Pomodoro Timer
export const POMODORO = {
  DEFAULT_WORK_DURATION: 25 * 60, // 25 minutes in seconds
  DEFAULT_SHORT_BREAK: 5 * 60,   // 5 minutes in seconds
  DEFAULT_LONG_BREAK: 15 * 60,   // 15 minutes in seconds
  DEFAULT_LONG_BREAK_INTERVAL: 4, // Every 4 pomodoros
} as const

// XP and Levels
export const GAMIFICATION = {
  XP_PER_TASK: 10,
  XP_PER_POMODORO: 5,
  XP_BONUS_STREAK: 5,
  BASE_XP_FOR_LEVEL: 100,
  XP_MULTIPLIER: 1.5,
} as const

// Theme Colors
export const THEME_COLORS = {
  LIGHT: 'light',
  DARK: 'dark',
  SYSTEM: 'system',
} as const

// Task Status Colors
export const STATUS_COLORS = {
  todo: 'bg-gray-100 text-gray-800',
  in_progress: 'bg-blue-100 text-blue-800',
  review: 'bg-purple-100 text-purple-800',
  done: 'bg-green-100 text-green-800',
  cancelled: 'bg-red-100 text-red-800',
} as const

// Priority Colors
export const PRIORITY_COLORS = {
  low: 'bg-green-100 text-green-800',
  medium: 'bg-yellow-100 text-yellow-800',
  high: 'bg-orange-100 text-orange-800',
  urgent: 'bg-red-100 text-red-800',
} as const

// Garden Plant Categories
export const PLANT_CATEGORIES = {
  FLOWERS: 'flowers',
  TREES: 'trees',
  HERBS: 'herbs',
  MUSHROOMS: 'mushrooms',
} as const

// Achievement Categories
export const ACHIEVEMENT_CATEGORIES = {
  TASKS: 'tasks',
  POMODORO: 'pomodoro',
  STREAK: 'streak',
  SOCIAL: 'social',
  GARDEN: 'garden',
} as const

// Notification Types
export const NOTIFICATION_TYPES = {
  TASK_REMINDER: 'task_reminder',
  POMODORO_BREAK: 'pomodoro_break',
  ACHIEVEMENT: 'achievement',
  INVITATION: 'invitation',
  MENTION: 'mention',
  SYSTEM: 'system',
} as const

// Error Messages
export const ERROR_MESSAGES = {
  NETWORK_ERROR: 'Ошибка сети. Проверьте подключение к интернету.',
  UNAUTHORIZED: 'Недостаточно прав доступа.',
  NOT_FOUND: 'Запрашиваемый ресурс не найден.',
  VALIDATION_ERROR: 'Ошибка валидации данных.',
  UNKNOWN_ERROR: 'Произошла неизвестная ошибка.',
} as const

// Success Messages
export const SUCCESS_MESSAGES = {
  TASK_CREATED: 'Задача успешно создана',
  TASK_UPDATED: 'Задача обновлена',
  TASK_DELETED: 'Задача удалена',
  PROJECT_CREATED: 'Проект создан',
  PROJECT_UPDATED: 'Проект обновлен',
  SETTINGS_SAVED: 'Настройки сохранены',
  PROFILE_UPDATED: 'Профиль обновлен',
} as const


--- src/contexts/AuthContext.tsx ---

import { createContext, useContext, useEffect, useState, ReactNode } from 'react'
import {
  User,
  signInWithEmailAndPassword,
  createUserWithEmailAndPassword,
  signOut,
  onAuthStateChanged,
  updateProfile,
  sendEmailVerification,
  sendPasswordResetEmail,
  signInWithPopup,
  updatePassword,
  EmailAuthProvider,
  reauthenticateWithCredential,
} from 'firebase/auth'
import { auth, googleProvider } from '@/lib/firebase' // Import googleProvider
import { toast } from 'sonner'

interface AuthContextType {
  currentUser: User | null
  login: (email: string, password: string) => Promise<void>
  register: (email: string, password: string, displayName: string) => Promise<void>
  logout: () => Promise<void>
  loginWithGoogle: () => Promise<void>
  resetPassword: (email: string) => Promise<void>
  updateUserProfile: (displayName: string) => Promise<void>
  changePassword: (currentPassword: string, newPassword: string) => Promise<void>
  loading: boolean
  isAuthenticated: boolean
}

const AuthContext = createContext<AuthContextType | undefined>(undefined)

export function useAuth() {
  const context = useContext(AuthContext)
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider')
  }
  return context
}

interface AuthProviderProps {
  children: ReactNode
}

export function AuthProvider({ children }: AuthProviderProps) {
  const [currentUser, setCurrentUser] = useState<User | null>(null)
  const [loading, setLoading] = useState(true)

  const login = async (email: string, password: string) => {
    try {
      await signInWithEmailAndPassword(auth, email, password)
      toast.success('Успешный вход в систему!')
    } catch (error: any) {
      console.error('Login error:', error)
      switch (error.code) {
        case 'auth/user-not-found':
          toast.error('Пользователь с таким email не найден')
          break
        case 'auth/wrong-password':
          toast.error('Неверный пароль')
          break
        case 'auth/invalid-email':
          toast.error('Неверный формат email')
          break
        case 'auth/too-many-requests':
          toast.error('Слишком много неудачных попыток. Попробуйте позже')
          break
        case 'auth/network-request-failed':
          toast.error('Ошибка подключения к серверу. Проверьте интернет соединение')
          break
        default:
          toast.error('Ошибка входа: ' + error.message)
      }
      throw error
    }
  }

  const register = async (email: string, password: string, displayName: string) => {
    try {
      const result = await createUserWithEmailAndPassword(auth, email, password)
      await updateProfile(result.user, { displayName })
      await sendEmailVerification(result.user)
      toast.success('Регистрация успешна! Проверьте email для подтверждения.')
    } catch (error: any) {
      console.error('Registration error:', error)
      switch (error.code) {
        case 'auth/email-already-in-use':
          toast.error('Пользователь с таким email уже существует')
          break
        case 'auth/weak-password':
          toast.error('Пароль должен содержать минимум 6 символов')
          break
        case 'auth/invalid-email':
          toast.error('Неверный формат email')
          break
        case 'auth/network-request-failed':
          toast.error('Ошибка подключения к серверу. Проверьте интернет соединение')
          break
        default:
          toast.error('Ошибка регистрации: ' + error.message)
      }
      throw error
    }
  }

  const logout = async () => {
    try {
      await signOut(auth)
      toast.success('Вы успешно вышли из системы')
    } catch (error: any) {
      console.error('Logout error:', error)
      toast.error('Ошибка выхода из системы')
      throw error
    }
  }

  const loginWithGoogle = async () => {
    try {
      await signInWithPopup(auth, googleProvider) // Use imported googleProvider
      toast.success('Успешный вход через Google!')
    } catch (error: any) {
      console.error('Google login error:', error)
      if (error.code === 'auth/popup-closed-by-user' || error.code === 'auth/cancelled-popup-request') {
        // Пользователь закрыл окно - не показываем ошибку
        return
      } else if (error.code === 'auth/network-request-failed') {
        toast.error('Ошибка подключения к серверу. Проверьте интернет соединение')
      } else {
        toast.error('Ошибка входа через Google: ' + error.message)
      }
      throw error
    }
  }

  const resetPassword = async (email: string) => {
    try {
      await sendPasswordResetEmail(auth, email)
      toast.success('Инструкции по сбросу пароля отправлены на email')
    } catch (error: any) {
      console.error('Password reset error:', error)
      switch (error.code) {
        case 'auth/user-not-found':
          toast.error('Пользователь с таким email не найден')
          break
        case 'auth/invalid-email':
          toast.error('Неверный формат email')
          break
        case 'auth/network-request-failed':
          toast.error('Ошибка подключения к серверу. Проверьте интернет соединение')
          break
        default:
          toast.error('Ошибка сброса пароля: ' + error.message)
      }
      throw error
    }
  }

  const updateUserProfile = async (displayName: string) => {
    try {
      if (currentUser) {
        await updateProfile(currentUser, { displayName })
        toast.success('Профиль обновлен')
      }
    } catch (error: any) {
      console.error('Profile update error:', error)
      if (error.code === 'auth/network-request-failed') {
        toast.error('Ошибка подключения к серверу. Проверьте интернет соединение')
      } else {
        toast.error('Ошибка обновления профиля: ' + error.message)
      }
      throw error
    }
  }

  const changePassword = async (currentPassword: string, newPassword: string) => {
    try {
      if (currentUser && currentUser.email) {
        const credential = EmailAuthProvider.credential(currentUser.email, currentPassword)
        await reauthenticateWithCredential(currentUser, credential)
        await updatePassword(currentUser, newPassword)
        toast.success('Пароль успешно изменен')
      }
    } catch (error: any) {
      console.error('Password change error:', error)
      switch (error.code) {
        case 'auth/wrong-password':
          toast.error('Неверный текущий пароль')
          break
        case 'auth/weak-password':
          toast.error('Новый пароль должен содержать минимум 6 символов')
          break
        case 'auth/network-request-failed':
          toast.error('Ошибка подключения к серверу. Проверьте интернет соединение')
          break
        default:
          toast.error('Ошибка изменения пароля: ' + error.message)
      }
      throw error
    }
  }

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, (user) => {
      setCurrentUser(user)
      setLoading(false)
    })

    return unsubscribe
  }, [])

  const value: AuthContextType = {
    currentUser,
    login,
    register,
    logout,
    loginWithGoogle,
    resetPassword,
    updateUserProfile,
    changePassword,
    loading,
    isAuthenticated: !!currentUser,
  }

  return (
    <AuthContext.Provider value={value}>
      {!loading && children}
    </AuthContext.Provider>
  )
}



--- src/contexts/ThemeContext.tsx ---

import { createContext, useContext, useEffect, useState, ReactNode } from 'react'

type Theme = 'light' | 'dark' | 'system'

interface ThemeContextType {
  theme: Theme
  setTheme: (theme: Theme) => void
  resolvedTheme: 'light' | 'dark'
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined)

export function useTheme() {
  const context = useContext(ThemeContext)
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider')
  }
  return context
}

interface ThemeProviderProps {
  children: ReactNode
  defaultTheme?: Theme
}

export function ThemeProvider({ children, defaultTheme = 'system' }: ThemeProviderProps) {
  const [theme, setTheme] = useState<Theme>(() => {
    if (typeof window !== 'undefined') {
      return (localStorage.getItem('theme') as Theme) || defaultTheme
    }
    return defaultTheme
  })

  const [resolvedTheme, setResolvedTheme] = useState<'light' | 'dark'>(() => {
    if (typeof window !== 'undefined') {
      if (theme === 'system') {
        return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'
      }
      return theme === 'dark' ? 'dark' : 'light'
    }
    return 'light'
  })

  useEffect(() => {
    const root = window.document.documentElement

    if (theme === 'system') {
      const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'
      setResolvedTheme(systemTheme)
      root.classList.remove('light', 'dark')
      root.classList.add(systemTheme)
    } else {
      setResolvedTheme(theme === 'dark' ? 'dark' : 'light')
      root.classList.remove('light', 'dark')
      root.classList.add(theme)
    }
  }, [theme])

  useEffect(() => {
    localStorage.setItem('theme', theme)
  }, [theme])

  useEffect(() => {
    if (theme === 'system') {
      const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)')
      
      const handleChange = (e: MediaQueryListEvent) => {
        const systemTheme = e.matches ? 'dark' : 'light'
        setResolvedTheme(systemTheme)
        const root = window.document.documentElement
        root.classList.remove('light', 'dark')
        root.classList.add(systemTheme)
      }

      mediaQuery.addEventListener('change', handleChange)
      return () => mediaQuery.removeEventListener('change', handleChange)
    }
  }, [theme])

  const value: ThemeContextType = {
    theme,
    setTheme,
    resolvedTheme,
  }

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  )
}


--- src/hooks/useTasks.ts ---

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { TaskService, TaskFilters, TaskCreateData } from '@/services/taskService'
import { UserService } from '@/services/userService'
import { Task, TaskStatus } from '@/types'
import { toast } from 'sonner'
import { SUCCESS_MESSAGES, GAMIFICATION } from '@/constants'

// Query keys
export const TASK_KEYS = {
  all: ['tasks'] as const,
  lists: () => [...TASK_KEYS.all, 'list'] as const,
  list: (filters: TaskFilters) => [...TASK_KEYS.lists(), filters] as const,
  details: () => [...TASK_KEYS.all, 'detail'] as const,
  detail: (id: string) => [...TASK_KEYS.details(), id] as const,
  stats: (userId: string) => [...TASK_KEYS.all, 'stats', userId] as const,
}

// Get tasks with filters
export function useTasks(filters: TaskFilters = {}, pageSize: number = 20) {
  return useQuery({
    queryKey: TASK_KEYS.list(filters),
    queryFn: () => TaskService.getTasks(filters, pageSize),
    staleTime: 5 * 60 * 1000, // 5 minutes
  })
}

// Get single task
export function useTask(taskId: string) {
  return useQuery({
    queryKey: TASK_KEYS.detail(taskId),
    queryFn: () => TaskService.getTask(taskId),
    enabled: !!taskId,
  })
}

// Get task statistics
export function useTaskStats(userId: string, workspaceId?: string) {
  return useQuery({
    queryKey: TASK_KEYS.stats(userId),
    queryFn: () => TaskService.getTasksStats(userId, workspaceId),
    enabled: !!userId,
    staleTime: 2 * 60 * 1000, // 2 minutes
  })
}

// Create task mutation
export function useCreateTask() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: ({ userId, taskData }: { userId: string; taskData: TaskCreateData }) =>
      TaskService.createTask(userId, taskData),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: TASK_KEYS.lists() })
      queryClient.invalidateQueries({ queryKey: TASK_KEYS.all })
      toast.success(SUCCESS_MESSAGES.TASK_CREATED)
    },
    onError: (error: Error) => {
      toast.error(error.message)
    },
  })
}

// Update task mutation
export function useUpdateTask() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: ({ taskId, updates }: { taskId: string; updates: Partial<Task> }) =>
      TaskService.updateTask(taskId, updates),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: TASK_KEYS.detail(variables.taskId) })
      queryClient.invalidateQueries({ queryKey: TASK_KEYS.lists() })
      toast.success(SUCCESS_MESSAGES.TASK_UPDATED)
    },
    onError: (error: Error) => {
      toast.error(error.message)
    },
  })
}

// Update task status with XP reward
export function useUpdateTaskStatus() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ 
      taskId, 
      status, 
      userId 
    }: { 
      taskId: string; 
      status: TaskStatus; 
      userId: string 
    }) => {
      await TaskService.updateTaskStatus(taskId, status)
      
      // Award XP for completing tasks
      if (status === 'done') {
        await UserService.addXP(userId, GAMIFICATION.XP_PER_TASK)
        await UserService.incrementTaskCount(userId)
      }
    },
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: TASK_KEYS.detail(variables.taskId) })
      queryClient.invalidateQueries({ queryKey: TASK_KEYS.lists() })
      queryClient.invalidateQueries({ queryKey: TASK_KEYS.stats(variables.userId) })
      
      if (variables.status === 'done') {
        toast.success('Задача выполнена! +' + GAMIFICATION.XP_PER_TASK + ' XP')
      } else {
        toast.success(SUCCESS_MESSAGES.TASK_UPDATED)
      }
    },
    onError: (error: Error) => {
      toast.error(error.message)
    },
  })
}

// Delete task mutation
export function useDeleteTask() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: TaskService.deleteTask,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: TASK_KEYS.lists() })
      toast.success(SUCCESS_MESSAGES.TASK_DELETED)
    },
    onError: (error: Error) => {
      toast.error(error.message)
    },
  })
}

// Archive task mutation
export function useArchiveTask() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: ({ taskId, isArchived }: { taskId: string; isArchived: boolean }) =>
      TaskService.archiveTask(taskId, isArchived),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: TASK_KEYS.detail(variables.taskId) })
      queryClient.invalidateQueries({ queryKey: TASK_KEYS.lists() })
      toast.success(variables.isArchived ? 'Задача архивирована' : 'Задача восстановлена')
    },
    onError: (error: Error) => {
      toast.error(error.message)
    },
  })
}

// Add comment mutation
export function useAddComment() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: ({ 
      taskId, 
      userId, 
      content 
    }: { 
      taskId: string; 
      userId: string; 
      content: string 
    }) => TaskService.addComment(taskId, userId, content),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: TASK_KEYS.detail(variables.taskId) })
      toast.success('Комментарий добавлен')
    },
    onError: (error: Error) => {
      toast.error(error.message)
    },
  })
}

// Increment pomodoro count mutation
export function useIncrementPomodoro() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: ({ 
      taskId, 
      userId 
    }: { 
      taskId: string; 
      userId: string 
    }) => {
      return Promise.all([
        TaskService.incrementPomodoroCount(taskId),
        UserService.addXP(userId, GAMIFICATION.XP_PER_POMODORO),
        UserService.incrementPomodoroCount(userId)
      ])
    },
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: TASK_KEYS.detail(variables.taskId) })
      queryClient.invalidateQueries({ queryKey: TASK_KEYS.lists() })
      toast.success('Pomodoro завершён! +' + GAMIFICATION.XP_PER_POMODORO + ' XP')
    },
    onError: (error: Error) => {
      toast.error(error.message)
    },
  })
}

// Bulk update tasks mutation
export function useBulkUpdateTasks() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: TaskService.bulkUpdateTasks,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: TASK_KEYS.lists() })
      toast.success('Задачи обновлены')
    },
    onError: (error: Error) => {
      toast.error(error.message)
    },
  })
}


--- src/hooks/useWorkspaces.ts ---

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { toast } from 'sonner'
import workspaceService, {
  CreateWorkspacePayload,
  UpdateWorkspacePayload,
  WorkspaceClientDto
} from '@/services/workspaceService'

// Query keys для кэширования
export const workspaceKeys = {
  all: ['workspaces'] as const,
  lists: () => [...workspaceKeys.all, 'list'] as const,
  list: (filters: Record<string, any>) => [...workspaceKeys.lists(), { filters }] as const,
  details: () => [...workspaceKeys.all, 'detail'] as const,
  detail: (id: string) => [...workspaceKeys.details(), id] as const,
}

/**
 * Хук для получения списка рабочих пространств пользователя
 */
export function useWorkspaces() {
  return useQuery({
    queryKey: workspaceKeys.lists(),
    queryFn: () => workspaceService.getUserWorkspaces(),
    staleTime: 5 * 60 * 1000, // 5 минут
    retry: (failureCount, error: any) => {
      // Не повторяем запрос при ошибках авторизации
      if (error?.message?.includes('не авторизован')) return false
      return failureCount < 2
    },
  })
}

/**
 * Хук для получения деталей конкретного рабочего пространства
 */
export function useWorkspaceDetails(workspaceId: string, enabled = true) {
  return useQuery({
    queryKey: workspaceKeys.detail(workspaceId),
    queryFn: () => workspaceService.getWorkspaceDetails(workspaceId),
    enabled: !!workspaceId && enabled,
    staleTime: 2 * 60 * 1000, // 2 минуты
    retry: (failureCount, error: any) => {
      if (error?.message?.includes('не авторизован')) return false
      if (error?.message?.includes('не найден')) return false
      return failureCount < 2
    },
  })
}

/**
 * Хук для создания нового рабочего пространства
 */
export function useCreateWorkspace() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (payload: CreateWorkspacePayload) =>
      workspaceService.createWorkspace(payload),
    onSuccess: (data) => {
      // Обновляем список рабочих пространств
      queryClient.invalidateQueries({ queryKey: workspaceKeys.lists() })
      
      // Добавляем новое рабочее пространство в кэш деталей
      queryClient.setQueryData(
        workspaceKeys.detail(data.workspace.id),
        { workspace: data.workspace }
      )

      // Показываем уведомление об успехе
      toast.success('Рабочее пространство успешно создано!', {
        description: `"${data.workspace.name}" готово к использованию`,
      })
    },
    onError: (error: Error) => {
      console.error('Ошибка создания рабочего пространства:', error)
      toast.error('Не удалось создать рабочее пространство', {
        description: error.message,
      })
    },
  })
}

/**
 * Хук для обновления рабочего пространства
 */
export function useUpdateWorkspace() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (payload: UpdateWorkspacePayload) =>
      workspaceService.updateWorkspace(payload),
    onSuccess: (data, variables) => {
      // Обновляем кэш деталей рабочего пространства
      queryClient.setQueryData(
        workspaceKeys.detail(variables.workspaceId),
        { workspace: data.updatedWorkspace }
      )

      // Обновляем список рабочих пространств
      queryClient.setQueryData(
        workspaceKeys.lists(),
        (oldData: any) => {
          if (!oldData?.workspaces) return oldData
          
          return {
            ...oldData,
            workspaces: oldData.workspaces.map((workspace: WorkspaceClientDto) =>
              workspace.id === variables.workspaceId
                ? data.updatedWorkspace
                : workspace
            ),
          }
        }
      )

      // Показываем уведомление об успехе
      toast.success('Рабочее пространство обновлено!', {
        description: `"${data.updatedWorkspace.name}" сохранено`,
      })
    },
    onError: (error: Error) => {
      console.error('Ошибка обновления рабочего пространства:', error)
      toast.error('Не удалось обновить рабочее пространство', {
        description: error.message,
      })
    },
  })
}

/**
 * Хук для удаления рабочего пространства
 */
export function useDeleteWorkspace() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (workspaceId: string) =>
      workspaceService.deleteWorkspace(workspaceId),
    onSuccess: (data, workspaceId) => {
      // Удаляем из кэша деталей
      queryClient.removeQueries({
        queryKey: workspaceKeys.detail(workspaceId),
      })

      // Обновляем список рабочих пространств
      queryClient.setQueryData(
        workspaceKeys.lists(),
        (oldData: any) => {
          if (!oldData?.workspaces) return oldData
          
          return {
            ...oldData,
            workspaces: oldData.workspaces.filter(
              (workspace: WorkspaceClientDto) => workspace.id !== workspaceId
            ),
          }
        }
      )

      // Показываем уведомление об успехе
      toast.success('Рабочее пространство удалено', {
        description: data.message,
      })
    },
    onError: (error: Error) => {
      console.error('Ошибка удаления рабочего пространства:', error)
      toast.error('Не удалось удалить рабочее пространство', {
        description: error.message,
      })
    },
  })
}

/**
 * Хук для предзагрузки деталей рабочего пространства
 */
export function usePrefetchWorkspaceDetails() {
  const queryClient = useQueryClient()

  return (workspaceId: string) => {
    queryClient.prefetchQuery({
      queryKey: workspaceKeys.detail(workspaceId),
      queryFn: () => workspaceService.getWorkspaceDetails(workspaceId),
      staleTime: 2 * 60 * 1000,
    })
  }
}

/**
 * Вспомогательный хук для работы с активным рабочим пространством
 */
export function useActiveWorkspace(workspaceId?: string | null) {
  const { data: workspacesData } = useWorkspaces()
  const { data: workspaceDetails } = useWorkspaceDetails(
    workspaceId || '',
    !!workspaceId
  )

  // Если передан ID, возвращаем детали конкретного пространства
  if (workspaceId && workspaceDetails) {
    return {
      workspace: workspaceDetails.workspace,
      isLoading: false,
      error: null,
    }
  }

  // Иначе возвращаем первое личное пространство из списка
  const personalWorkspace = workspacesData?.workspaces?.find(
    (ws) => ws.isPersonal
  )

  return {
    workspace: personalWorkspace || null,
    isLoading: !workspacesData,
    error: null,
  }
}


--- src/lib/firebase.ts ---

// /ProgressQuestWeb/src/lib/firebase.ts

import { initializeApp, getApps, getApp } from "firebase/app";
import { getAuth, GoogleAuthProvider, connectAuthEmulator } from "firebase/auth";
import { getFirestore, connectFirestoreEmulator } from "firebase/firestore";
import { getFunctions, connectFunctionsEmulator } from "firebase/functions";
import { getStorage, connectStorageEmulator } from "firebase/storage";

// Конфигурация Firebase, считываемая из переменных окружения Vite
const firebaseConfig = {
  apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
  storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,
  appId: import.meta.env.VITE_FIREBASE_APP_ID,
};

// Инициализация Firebase приложения (синглтон)
// Проверка `getApps().length` предотвращает повторную инициализацию при Hot Reloading в Vite
const app = !getApps().length ? initializeApp(firebaseConfig) : getApp();

// Получение инстансов сервисов
const auth = getAuth(app);
const db = getFirestore(app);
const functions = getFunctions(app, import.meta.env.VITE_FIREBASE_FUNCTIONS_REGION || "europe-west1");
const storage = getStorage(app);
const googleProvider = new GoogleAuthProvider();

// --- Эмуляторы (для локальной разработки) ---
// Подключаемся к эмуляторам только если явно указано в переменных окружения
if (import.meta.env.DEV && import.meta.env.VITE_USE_FIREBASE_EMULATORS === 'true') {
  try {
    console.log("DEV mode detected. Connecting to Firebase emulators...");
    
    // Firebase по умолчанию использует localhost, но для некоторых систем
    // (например, Docker или WSL2) может потребоваться явное указание IP.
    const host = 'localhost';
    
    connectAuthEmulator(auth, `http://${host}:9099`, { disableWarnings: true });
    connectFirestoreEmulator(db, host, 8080);
    connectFunctionsEmulator(functions, host, 5001);
    connectStorageEmulator(storage, host, 9199);
    
    console.log("Successfully connected to Firebase emulators.");
  } catch (error) {
    console.error("Error connecting to Firebase emulators:", error);
  }
} else if (import.meta.env.DEV) {
  console.log("DEV mode detected, but using production Firebase services.");
}

// Экспорт готовых к использованию инстансов
export { app, auth, db, functions, storage, googleProvider };

--- src/lib/mockFirebase.ts ---

// Mock Firebase services for development when no real Firebase is configured

export const mockAuth = {
  currentUser: null,
  onAuthStateChanged: (callback: (user: any) => void) => {
    // Simulate no user logged in
    setTimeout(() => callback(null), 100);
    return () => {}; // Unsubscribe function
  },
  signInWithEmailAndPassword: async () => {
    throw new Error('Demo mode: Please configure Firebase to enable authentication');
  },
  createUserWithEmailAndPassword: async () => {
    throw new Error('Demo mode: Please configure Firebase to enable authentication');
  },
  signOut: async () => {
    throw new Error('Demo mode: Please configure Firebase to enable authentication');
  },
  signInWithPopup: async () => {
    throw new Error('Demo mode: Please configure Firebase to enable authentication');
  },
  sendPasswordResetEmail: async () => {
    throw new Error('Demo mode: Please configure Firebase to enable authentication');
  },
  updateProfile: async () => {
    throw new Error('Demo mode: Please configure Firebase to enable authentication');
  },
  sendEmailVerification: async () => {
    throw new Error('Demo mode: Please configure Firebase to enable authentication');
  },
  updatePassword: async () => {
    throw new Error('Demo mode: Please configure Firebase to enable authentication');
  },
  reauthenticateWithCredential: async () => {
    throw new Error('Demo mode: Please configure Firebase to enable authentication');
  }
};

export const mockDb = {
  collection: () => ({
    doc: () => ({
      set: async () => {
        throw new Error('Demo mode: Please configure Firebase to enable database operations');
      },
      get: async () => {
        throw new Error('Demo mode: Please configure Firebase to enable database operations');
      },
      update: async () => {
        throw new Error('Demo mode: Please configure Firebase to enable database operations');
      },
      delete: async () => {
        throw new Error('Demo mode: Please configure Firebase to enable database operations');
      }
    }),
    add: async () => {
      throw new Error('Demo mode: Please configure Firebase to enable database operations');
    },
    get: async () => {
      throw new Error('Demo mode: Please configure Firebase to enable database operations');
    }
  }),
  doc: () => ({
    set: async () => {
      throw new Error('Demo mode: Please configure Firebase to enable database operations');
    },
    get: async () => {
      throw new Error('Demo mode: Please configure Firebase to enable database operations');
    },
    update: async () => {
      throw new Error('Demo mode: Please configure Firebase to enable database operations');
    },
    delete: async () => {
      throw new Error('Demo mode: Please configure Firebase to enable database operations');
    }
  })
};

// Check if we should use mock services
export const shouldUseMockServices = () => {
  const apiKey = import.meta.env.VITE_FIREBASE_API_KEY;
  return !apiKey || apiKey === 'demo_api_key';
};


--- src/lib/utils.ts ---

import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}


--- src/pages/AnalyticsPage.tsx ---


export const AnalyticsPage = () => {
  return (
    <div className="p-6">
      <div className="mb-6">
        <h1 className="text-3xl font-bold text-gray-900 mb-2">Аналитика</h1>
        <p className="text-gray-600">Отслеживайте свою продуктивность и прогресс</p>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
        <div className="bg-white p-6 rounded-lg shadow-md">
          <h3 className="text-sm font-medium text-gray-500 mb-2">Задачи за неделю</h3>
          <p className="text-2xl font-bold text-blue-600">0</p>
          <p className="text-sm text-gray-500 mt-1">+0% к прошлой неделе</p>
        </div>
        <div className="bg-white p-6 rounded-lg shadow-md">
          <h3 className="text-sm font-medium text-gray-500 mb-2">Pomodoro сессии</h3>
          <p className="text-2xl font-bold text-green-600">0</p>
          <p className="text-sm text-gray-500 mt-1">+0% к прошлой неделе</p>
        </div>
        <div className="bg-white p-6 rounded-lg shadow-md">
          <h3 className="text-sm font-medium text-gray-500 mb-2">Продуктивность</h3>
          <p className="text-2xl font-bold text-purple-600">0%</p>
          <p className="text-sm text-gray-500 mt-1">+0% к прошлой неделе</p>
        </div>
        <div className="bg-white p-6 rounded-lg shadow-md">
          <h3 className="text-sm font-medium text-gray-500 mb-2">Streak дней</h3>
          <p className="text-2xl font-bold text-orange-600">0</p>
          <p className="text-sm text-gray-500 mt-1">Дней подряд</p>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <div className="bg-white p-6 rounded-lg shadow-md">
          <h3 className="text-lg font-semibold mb-4">Активность по дням</h3>
          <div className="h-64 bg-gray-50 rounded-lg flex items-center justify-center">
            <p className="text-gray-500">График активности</p>
          </div>
        </div>
        <div className="bg-white p-6 rounded-lg shadow-md">
          <h3 className="text-lg font-semibold mb-4">Распределение по категориям</h3>
          <div className="h-64 bg-gray-50 rounded-lg flex items-center justify-center">
            <p className="text-gray-500">Круговая диаграмма</p>
          </div>
        </div>
      </div>
    </div>
  );
};


--- src/pages/DashboardPage.tsx ---


export const DashboardPage = () => {
  return (
    <div className="p-6 bg-gradient-to-br from-slate-50 to-blue-50 min-h-screen">
      <div className="mb-8">
        <h1 className="text-3xl font-bold text-slate-800 mb-2 drop-shadow-sm">Панель управления</h1>
        <p className="text-slate-600 font-medium">Добро пожаловать в ProgressQuest Universal</p>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
        <div className="bg-white/90 backdrop-blur-sm p-6 rounded-lg shadow-lg border border-white/50 hover:shadow-xl transition-all duration-300">
          <h3 className="text-lg font-semibold mb-2 text-slate-700">Всего задач</h3>
          <p className="text-3xl font-bold text-blue-600 drop-shadow-sm">0</p>
        </div>
        <div className="bg-white/90 backdrop-blur-sm p-6 rounded-lg shadow-lg border border-white/50 hover:shadow-xl transition-all duration-300">
          <h3 className="text-lg font-semibold mb-2 text-slate-700">Выполнено</h3>
          <p className="text-3xl font-bold text-emerald-600 drop-shadow-sm">0</p>
        </div>
        <div className="bg-white/90 backdrop-blur-sm p-6 rounded-lg shadow-lg border border-white/50 hover:shadow-xl transition-all duration-300">
          <h3 className="text-lg font-semibold mb-2 text-slate-700">Уровень</h3>
          <p className="text-3xl font-bold text-purple-600 drop-shadow-sm">1</p>
        </div>
        <div className="bg-white/90 backdrop-blur-sm p-6 rounded-lg shadow-lg border border-white/50 hover:shadow-xl transition-all duration-300">
          <h3 className="text-lg font-semibold mb-2 text-slate-700">Опыт</h3>
          <p className="text-3xl font-bold text-orange-600 drop-shadow-sm">0</p>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <div className="bg-white/90 backdrop-blur-sm p-6 rounded-lg shadow-lg border border-white/50 hover:shadow-xl transition-all duration-300">
          <h3 className="text-xl font-semibold mb-4 text-slate-700">Последние задачи</h3>
          <p className="text-slate-500 font-medium">Задач пока нет</p>
        </div>
        <div className="bg-white/90 backdrop-blur-sm p-6 rounded-lg shadow-lg border border-white/50 hover:shadow-xl transition-all duration-300">
          <h3 className="text-xl font-semibold mb-4 text-slate-700">Активность</h3>
          <p className="text-slate-500 font-medium">График активности</p>
        </div>
      </div>
    </div>
  );
};


--- src/pages/GardenPage.tsx ---


export const GardenPage = () => {
  return (
    <div className="p-6 bg-gradient-to-br from-slate-50 to-green-50 min-h-screen">
      <div className="mb-6">
        <h1 className="text-3xl font-bold text-slate-800 mb-2 drop-shadow-sm">Виртуальный сад</h1>
        <p className="text-slate-600 font-medium">Выращивайте растения за выполненные задачи</p>
      </div>

      <div className="bg-gradient-to-br from-green-100 to-blue-100 rounded-lg p-8 min-h-[400px] shadow-lg border border-white/50">
        <div className="text-center">
          <div className="text-6xl mb-4">🌱</div>
          <h3 className="text-xl font-semibold text-slate-700 mb-2 drop-shadow-sm">Ваш сад пуст</h3>
          <p className="text-slate-600 mb-6 font-medium">
            Выполняйте задачи, чтобы получать семена и выращивать растения
          </p>
          <div className="bg-white/90 backdrop-blur-sm p-4 rounded-lg shadow-md inline-block border border-white/50">
            <p className="text-sm text-slate-700 font-medium">Семена: <span className="font-bold">0</span></p>
          </div>
        </div>
      </div>

      <div className="mt-6 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        <div className="bg-white/90 backdrop-blur-sm p-4 rounded-lg shadow-lg text-center border border-white/50 hover:shadow-xl transition-all duration-300">
          <div className="text-2xl mb-2">🌸</div>
          <h4 className="font-semibold text-slate-700 drop-shadow-sm">Цветы</h4>
          <p className="text-sm text-slate-600 font-medium">0 растений</p>
        </div>
        <div className="bg-white/90 backdrop-blur-sm p-4 rounded-lg shadow-lg text-center border border-white/50 hover:shadow-xl transition-all duration-300">
          <div className="text-2xl mb-2">🌳</div>
          <h4 className="font-semibold text-slate-700 drop-shadow-sm">Деревья</h4>
          <p className="text-sm text-slate-600 font-medium">0 растений</p>
        </div>
        <div className="bg-white/90 backdrop-blur-sm p-4 rounded-lg shadow-lg text-center border border-white/50 hover:shadow-xl transition-all duration-300">
          <div className="text-2xl mb-2">🌿</div>
          <h4 className="font-semibold text-slate-700 drop-shadow-sm">Травы</h4>
          <p className="text-sm text-slate-600 font-medium">0 растений</p>
        </div>
        <div className="bg-white/90 backdrop-blur-sm p-4 rounded-lg shadow-lg text-center border border-white/50 hover:shadow-xl transition-all duration-300">
          <div className="text-2xl mb-2">🍄</div>
          <h4 className="font-semibold text-slate-700 drop-shadow-sm">Грибы</h4>
          <p className="text-sm text-slate-600 font-medium">0 растений</p>
        </div>
      </div>
    </div>
  );
};


--- src/pages/LandingPage.tsx ---

import { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { CheckCircle, Clock, Target, Trophy, Users, Star, ChevronDown, Play, Pause, Plus } from "lucide-react";
import { useAuth } from "@/contexts/AuthContext";
import { toast } from 'sonner';

export default function LandingPage() {
  const navigate = useNavigate();
  const { currentUser } = useAuth();
  const [timerTime, setTimerTime] = useState(25 * 60);
  const [isTimerRunning, setIsTimerRunning] = useState(false);
  const [taskName, setTaskName] = useState('');
  const [openFAQ, setOpenFAQ] = useState<number | null>(null);
  const [isMonthly, setIsMonthly] = useState(true);

  // Redirect if already authenticated
  useEffect(() => {
    if (currentUser) {
      navigate('/app');
    }
  }, [currentUser, navigate]);

  // Timer logic
  useEffect(() => {
    let interval: NodeJS.Timeout | null = null;
    if (isTimerRunning && timerTime > 0) {
      interval = setInterval(() => {
        setTimerTime(time => time - 1);
      }, 1000);
    } else if (timerTime === 0) {
      setIsTimerRunning(false);
      toast.success('🎉 Pomodoro завершен! +25 XP');
      setTimerTime(25 * 60);
    }
    return () => {
      if (interval) clearInterval(interval);
    };
  }, [isTimerRunning, timerTime]);

  const startTimer = () => {
    if (!taskName.trim()) {
      toast.error('Введите название задачи');
      return;
    }
    setIsTimerRunning(true);
    toast.success('Таймер запущен! Удачи! 🍅');
  };

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  const toggleFAQ = (index: number) => {
    setOpenFAQ(openFAQ === index ? null : index);
  };

  const faqData = [
    {
      question: 'Могу ли я использовать приложение бесплатно?',
      answer: 'Да! ProgressQuest предлагает полнофункциональный бесплатный план "Искатель" с неограниченными личными задачами, Pomodoro-таймером и базовой геймификацией.'
    },
    {
      question: 'Чем это отличается от других таск-менеджеров?',
      answer: 'ProgressQuest объединяет продуктивность с игровыми элементами. У вас есть виртуальный сад, система уровней, достижения и челленджи, которые мотивируют выполнять задачи.'
    },
    {
      question: 'На каких платформах доступен ProgressQuest?',
      answer: 'ProgressQuest работает в любом современном браузере и имеет адаптивный дизайн для смартфонов и планшетов. Мобильные приложения находятся в разработке.'
    },
    {
      question: 'Как работает командная геймификация?',
      answer: 'В командном режиме вы можете создавать общие проекты, распределять задачи, участвовать в групповых челленджах и отслеживать коллективную статистику продуктивности.'
    },
    {
      question: 'Безопасны ли мои данные?',
      answer: 'Да, мы используем Firebase для безопасного хранения данных с шифрованием и соблюдаем все стандарты защиты персональной информации.'
    }
  ];

  return (
    <div className="min-h-screen bg-white">
      {/* Navigation Panel */}
      <header className="sticky top-0 bg-white/95 backdrop-blur-sm border-b border-gray-200 z-50">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex justify-between items-center py-4">
            <div className="flex justify-start lg:w-0 lg:flex-1">
              <span className="text-2xl font-bold text-indigo-600">ProgressQuest</span>
            </div>
            <nav className="hidden md:flex space-x-10">
              <a href="#features" className="text-base font-medium text-gray-500 hover:text-gray-900 transition-colors">
                Возможности
              </a>
              <a href="#audience" className="text-base font-medium text-gray-500 hover:text-gray-900 transition-colors">
                Для кого
              </a>
              <a href="#pricing" className="text-base font-medium text-gray-500 hover:text-gray-900 transition-colors">
                Тарифы
              </a>
              <a href="#faq" className="text-base font-medium text-gray-500 hover:text-gray-900 transition-colors">
                Блог
              </a>
            </nav>
            <div className="flex items-center justify-end md:flex-1 lg:w-0 space-x-4">
              <Button 
                variant="ghost" 
                onClick={() => navigate('/login')}
                className="text-gray-500 hover:text-gray-900"
              >
                Войти
              </Button>
              <Button 
                onClick={() => navigate('/register')}
                className="bg-indigo-600 hover:bg-indigo-700 text-white"
              >
                Начать бесплатно
              </Button>
            </div>
          </div>
        </div>
      </header>

      {/* Hero Section */}
      <section className="relative bg-gradient-to-br from-indigo-50 via-white to-cyan-50 py-20 lg:py-28">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="text-center">
            <h1 className="text-4xl tracking-tight font-extrabold text-gray-900 sm:text-5xl md:text-6xl">
              <span className="block">Преврати свои цели в</span>
              <span className="block text-indigo-600">захватывающий квест</span>
            </h1>
            <p className="mt-3 max-w-md mx-auto text-base text-gray-500 sm:text-lg md:mt-5 md:text-xl md:max-w-3xl">
              Объедините мощь Pomodoro-таймера с увлекательной геймификацией. Достигайте большего, 
              получая удовольствие от процесса — в одиночку или в команде.
            </p>
            <div className="mt-5 max-w-md mx-auto sm:flex sm:justify-center md:mt-8">
              <div className="rounded-md shadow">
                <Button 
                  size="lg"
                  onClick={() => navigate('/register')}
                  className="w-full flex items-center justify-center px-8 py-3 border border-transparent text-base font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 md:py-4 md:text-lg md:px-10"
                >
                  🚀 Начать свой квест (бесплатно)
                </Button>
              </div>
            </div>
            <p className="mt-3 text-sm text-gray-500">
              Бесплатно навсегда. Не требуется кредитная карта.
            </p>
          </div>
        </div>
        <div className="absolute inset-0 overflow-hidden pointer-events-none">
          <div className="absolute top-1/4 left-1/4 w-4 h-4 bg-indigo-400/20 rounded-full animate-pulse"></div>
          <div className="absolute top-3/4 right-1/4 w-6 h-6 bg-cyan-400/20 rounded-full animate-bounce"></div>
          <div className="absolute top-1/2 right-1/3 w-3 h-3 bg-purple-400/20 rounded-full animate-ping"></div>
        </div>
      </section>

      {/* Target Audience Section */}
      <section id="audience" className="py-20 bg-white">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="text-center mb-16">
            <h2 className="text-3xl font-extrabold text-gray-900 sm:text-4xl">
              Для индивидуальных героев и легендарных команд
            </h2>
          </div>

          <div className="grid lg:grid-cols-2 gap-12">
            {/* Personal Productivity */}
            <div className="bg-gradient-to-br from-blue-50 to-indigo-100 rounded-2xl p-8">
              <div className="text-center mb-8">
                <div className="mx-auto w-16 h-16 bg-blue-600 rounded-full flex items-center justify-center mb-4">
                  <Target className="w-8 h-8 text-white" />
                </div>
                <h3 className="text-2xl font-bold text-gray-900">Для Личной Продуктивности</h3>
                <p className="text-lg text-gray-600 mt-2">Покоряйте свои цели в одиночку</p>
              </div>
              
              <div className="space-y-6">
                <div>
                  <h4 className="font-semibold text-red-600 mb-3">Знакомые проблемы:</h4>
                  <ul className="space-y-2">
                    <li className="flex items-start">
                      <span className="text-red-500 mr-2">❌</span>
                      <span className="text-gray-700">Вечно откладываете важные дела?</span>
                    </li>
                    <li className="flex items-start">
                      <span className="text-red-500 mr-2">❌</span>
                      <span className="text-gray-700">Сложно сфокусироваться на одной задаче?</span>
                    </li>
                    <li className="flex items-start">
                      <span className="text-red-500 mr-2">❌</span>
                      <span className="text-gray-700">Теряете мотивацию на полпути?</span>
                    </li>
                  </ul>
                </div>
                
                <div>
                  <h4 className="font-semibold text-green-600 mb-3">Наши решения:</h4>
                  <ul className="space-y-2">
                    <li className="flex items-start">
                      <CheckCircle className="w-5 h-5 text-green-500 mr-2 mt-0.5 flex-shrink-0" />
                      <span className="text-gray-700">Pomodoro-таймер превратит марафон в серию коротких спринтов</span>
                    </li>
                    <li className="flex items-start">
                      <CheckCircle className="w-5 h-5 text-green-500 mr-2 mt-0.5 flex-shrink-0" />
                      <span className="text-gray-700">Система уровней и наград превратит рутину в увлекательную игру</span>
                    </li>
                    <li className="flex items-start">
                      <CheckCircle className="w-5 h-5 text-green-500 mr-2 mt-0.5 flex-shrink-0" />
                      <span className="text-gray-700">Виртуальный сад будет расти вместе с вашей продуктивностью</span>
                    </li>
                  </ul>
                </div>
              </div>
            </div>

            {/* Team Collaboration */}
            <div className="bg-gradient-to-br from-purple-50 to-pink-100 rounded-2xl p-8">
              <div className="text-center mb-8">
                <div className="mx-auto w-16 h-16 bg-purple-600 rounded-full flex items-center justify-center mb-4">
                  <Users className="w-8 h-8 text-white" />
                </div>
                <h3 className="text-2xl font-bold text-gray-900">Для Командной Работы</h3>
                <p className="text-lg text-gray-600 mt-2">Достигайте великих целей вместе</p>
              </div>
              
              <div className="space-y-6">
                <div>
                  <h4 className="font-semibold text-red-600 mb-3">Командные вызовы:</h4>
                  <ul className="space-y-2">
                    <li className="flex items-start">
                      <span className="text-red-500 mr-2">❌</span>
                      <span className="text-gray-700">Непрозрачный статус задач в проекте?</span>
                    </li>
                    <li className="flex items-start">
                      <span className="text-red-500 mr-2">❌</span>
                      <span className="text-gray-700">Низкая вовлеченность команды?</span>
                    </li>
                    <li className="flex items-start">
                      <span className="text-red-500 mr-2">❌</span>
                      <span className="text-gray-700">Сложно отследить общий прогресс?</span>
                    </li>
                  </ul>
                </div>
                
                <div>
                  <h4 className="font-semibold text-green-600 mb-3">Эффективные решения:</h4>
                  <ul className="space-y-2">
                    <li className="flex items-start">
                      <CheckCircle className="w-5 h-5 text-green-500 mr-2 mt-0.5 flex-shrink-0" />
                      <span className="text-gray-700">Общие рабочие пространства с Kanban-досками для полной прозрачности</span>
                    </li>
                    <li className="flex items-start">
                      <CheckCircle className="w-5 h-5 text-green-500 mr-2 mt-0.5 flex-shrink-0" />
                      <span className="text-gray-700">Командные челленджи и статистика для повышения азарта и сплоченности</span>
                    </li>
                    <li className="flex items-start">
                      <CheckCircle className="w-5 h-5 text-green-500 mr-2 mt-0.5 flex-shrink-0" />
                      <span className="text-gray-700">Гибкие роли и права доступа для структурированной работы</span>
                    </li>
                  </ul>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      {/* Features Section */}
      <section id="features" className="py-20 bg-gray-50">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="text-center mb-16">
            <h2 className="text-3xl font-extrabold text-gray-900 sm:text-4xl">
              Возможности
            </h2>
            <p className="mt-4 text-xl text-gray-600">
              Детальное описание ключевых функций продукта
            </p>
          </div>

          {/* Smart Task Management */}
          <div className="mb-20">
            <div className="lg:grid lg:grid-cols-2 lg:gap-8 lg:items-center">
              <div>
                <h3 className="text-2xl font-bold text-gray-900 sm:text-3xl">
                  Умное Управление Задачами
                </h3>
                <p className="mt-3 text-lg text-gray-500">
                  Создавайте задачи, разбивайте их на подзадачи, устанавливайте приоритеты и сроки. 
                  Визуализируйте свой рабочий процесс с помощью списков или Kanban-досок. 
                  Гибкие подходы (GTD, Матрица Эйзенхауэра) помогут адаптировать систему под себя.
                </p>
                <div className="mt-8 space-y-4">
                  <div className="flex items-start">
                    <div className="flex-shrink-0">
                      <div className="flex items-center justify-center h-12 w-12 rounded-md bg-indigo-500 text-white">
                        <Target className="h-6 w-6" />
                      </div>
                    </div>
                    <div className="ml-4">
                      <h4 className="text-lg font-medium text-gray-900">GTD и Матрица Эйзенхауэра</h4>
                      <p className="mt-2 text-base text-gray-500">
                        Гибкие подходы помогут адаптировать систему под себя.
                      </p>
                    </div>
                  </div>
                </div>
              </div>
              <div className="mt-10 lg:mt-0">
                <div className="bg-white rounded-lg shadow-lg p-6">
                  <div className="space-y-3">
                    <div className="flex items-center p-3 bg-green-50 rounded-lg border-l-4 border-green-400">
                      <CheckCircle className="h-5 w-5 text-green-400 mr-3" />
                      <span className="text-green-800">Завершить презентацию</span>
                    </div>
                    <div className="flex items-center p-3 bg-yellow-50 rounded-lg border-l-4 border-yellow-400">
                      <Clock className="h-5 w-5 text-yellow-400 mr-3" />
                      <span className="text-yellow-800">Подготовить отчет (до 18:00)</span>
                    </div>
                    <div className="flex items-center p-3 bg-blue-50 rounded-lg border-l-4 border-blue-400">
                      <Plus className="h-5 w-5 text-blue-400 mr-3" />
                      <span className="text-blue-800">Планирование спринта</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          {/* Pomodoro Timer */}
          <div className="mb-20">
            <div className="lg:grid lg:grid-cols-2 lg:gap-8 lg:items-center">
              <div className="lg:col-start-2">
                <h3 className="text-2xl font-bold text-gray-900 sm:text-3xl">
                  Pomodoro-таймер нового поколения
                </h3>
                <p className="mt-3 text-lg text-gray-500">
                  Просто оцените время на задачу, и ProgressQuest сам составит план работы и отдыха. 
                  Наш Pomodoro-таймер поможет вам оставаться в потоке и избегать выгорания, 
                  работая в фоне на всех ваших устройствах.
                </p>
              </div>
              <div className="mt-10 lg:mt-0 lg:col-start-1 lg:row-start-1">
                <div className="bg-white rounded-lg shadow-lg p-6">
                  <div className="text-center">
                    <div className="mx-auto w-32 h-32 rounded-full border-8 border-gray-200 relative">
                      <div className="absolute inset-0 rounded-full border-8 border-indigo-500" style={{clipPath: 'polygon(50% 0%, 100% 0%, 100% 50%, 50% 50%)'}}></div>
                      <div className="absolute inset-0 flex items-center justify-center">
                        <span className="text-2xl font-bold text-gray-900">{formatTime(timerTime)}</span>
                      </div>
                    </div>
                    <div className="mt-6 space-y-3">
                      <input
                        type="text"
                        placeholder="Название вашей задачи..."
                        value={taskName}
                        onChange={(e) => setTaskName(e.target.value)}
                        className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
                      />
                      <Button
                        onClick={startTimer}
                        disabled={isTimerRunning}
                        className={`w-full ${isTimerRunning ? 'bg-red-500 hover:bg-red-600' : 'bg-indigo-600 hover:bg-indigo-700'}`}
                      >
                        {isTimerRunning ? (
                          <><Pause className="h-4 w-4 mr-2" />Работаю...</>
                        ) : (
                          <><Play className="h-4 w-4 mr-2" />Запустить фокус на 25 минут</>
                        )}
                      </Button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          {/* Gamification */}
          <div className="mb-20">
            <div className="lg:grid lg:grid-cols-2 lg:gap-8 lg:items-center">
              <div>
                <h3 className="text-2xl font-bold text-gray-900 sm:text-3xl">
                  Геймификация, которая работает
                </h3>
                <p className="mt-3 text-lg text-gray-500">
                  Зарабатывайте опыт (XP) и монеты за каждую выполненную задачу и сессию фокуса. 
                  Повышайте свой уровень, открывайте достижения и соревнуйтесь с коллегами. 
                  Превратите достижение целей в захватывающее приключение!
                </p>
              </div>
              <div className="mt-10 lg:mt-0">
                <div className="grid grid-cols-2 gap-4">
                  <div className="bg-white rounded-lg shadow p-4 text-center">
                    <Trophy className="h-8 w-8 text-yellow-500 mx-auto mb-2" />
                    <div className="text-2xl font-bold text-gray-900">47</div>
                    <div className="text-sm text-gray-500">Достижений</div>
                  </div>
                  <div className="bg-white rounded-lg shadow p-4 text-center">
                    <Star className="h-8 w-8 text-indigo-500 mx-auto mb-2" />
                    <div className="text-2xl font-bold text-gray-900">Ур. 12</div>
                    <div className="text-sm text-gray-500">Текущий уровень</div>
                  </div>
                  <div className="bg-white rounded-lg shadow p-4 text-center col-span-2">
                    <div className="text-sm text-gray-500 mb-2">XP до следующего уровня</div>
                    <div className="w-full bg-gray-200 rounded-full h-2">
                      <div className="bg-indigo-600 h-2 rounded-full" style={{width: '65%'}}></div>
                    </div>
                    <div className="text-xs text-gray-500 mt-1">1,950 / 3,000 XP</div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          {/* Virtual Garden */}
          <div>
            <div className="lg:grid lg:grid-cols-2 lg:gap-8 lg:items-center">
              <div className="lg:col-start-2">
                <h3 className="text-2xl font-bold text-gray-900 sm:text-3xl">
                  Ваш Виртуальный Сад Продуктивности
                </h3>
                <p className="mt-3 text-lg text-gray-500">
                  Каждая сфокусированная минута помогает вашему виртуальному растению расти. 
                  Заботьтесь о своем саде, поливайте растения и наблюдайте, как он расцветает 
                  вместе с вашей продуктивностью. Это ваше наглядное воплощение приложенных усилий.
                </p>
              </div>
              <div className="mt-10 lg:mt-0 lg:col-start-1 lg:row-start-1">
                <div className="bg-gradient-to-b from-blue-400 to-green-400 rounded-lg p-6 text-center">
                  <div className="text-6xl mb-4">🌻</div>
                  <div className="text-white font-semibold">Подсолнух Продуктивности</div>
                  <div className="text-blue-100 text-sm mt-2">Вырос за 15 дней фокуса</div>
                  <div className="mt-4 flex justify-center space-x-2">
                    <span className="text-2xl">🌱</span>
                    <span className="text-2xl">🌿</span>
                    <span className="text-2xl">🌸</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      {/* Pricing Section */}
      <section id="pricing" className="py-20 bg-white">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="text-center mb-16">
            <h2 className="text-3xl font-extrabold text-gray-900 sm:text-4xl">
              Выберите свой путь
            </h2>
            <div className="mt-6">
              <div className="flex items-center justify-center">
                <span className={`mr-3 ${isMonthly ? 'text-gray-900' : 'text-gray-500'}`}>Ежемесячно</span>
                <button
                  onClick={() => setIsMonthly(!isMonthly)}
                  className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${isMonthly ? 'bg-gray-200' : 'bg-indigo-600'}`}
                >
                  <span className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${isMonthly ? 'translate-x-1' : 'translate-x-6'}`} />
                </button>
                <span className={`ml-3 ${!isMonthly ? 'text-gray-900' : 'text-gray-500'}`}>Ежегодно <span className="text-green-600 font-semibold">(скидка 20%)</span></span>
              </div>
            </div>
          </div>

          <div className="grid md:grid-cols-3 gap-8">
            {/* Free Plan */}
            <Card className="relative flex flex-col h-full bg-gray-800">
              <CardHeader className="bg-gray-800 rounded-t-lg">
                <CardTitle className="text-center">
                  <div className="text-2xl font-bold text-white">Искатель</div>
                  <div className="text-4xl font-bold text-indigo-400 mt-2">0 ₽</div>
                  <div className="text-gray-300 font-medium">навсегда</div>
                </CardTitle>
              </CardHeader>
              <CardContent className="flex-grow flex flex-col bg-gray-800">
                <p className="text-center text-gray-300 mb-6">Идеально для старта и личных задач</p>
                <ul className="space-y-3 flex-grow">
                  <li className="flex items-start">
                    <CheckCircle className="h-5 w-5 text-green-400 mr-3 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-200">Неограниченные личные задачи</span>
                  </li>
                  <li className="flex items-start">
                    <CheckCircle className="h-5 w-5 text-green-400 mr-3 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-200">Pomodoro-таймер</span>
                  </li>
                  <li className="flex items-start">
                    <CheckCircle className="h-5 w-5 text-green-400 mr-3 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-200">Базовая геймификация</span>
                  </li>
                  <li className="flex items-start">
                    <CheckCircle className="h-5 w-5 text-green-400 mr-3 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-200">1 рабочее пространство</span>
                  </li>
                </ul>
                <div className="mt-auto pt-6">
                  <Button 
                    className="w-full bg-gray-600 text-white hover:bg-gray-700"
                    onClick={() => navigate('/register')}
                  >
                    Начать бесплатно
                  </Button>
                </div>
              </CardContent>
            </Card>

            {/* Pro Plan */}
            <Card className="relative flex flex-col h-full border-2 border-indigo-500 shadow-xl bg-gray-800">
              <div className="absolute top-0 left-1/2 transform -translate-x-1/2 -translate-y-1/2">
                <span className="bg-indigo-500 text-white px-4 py-1 rounded-full text-sm font-semibold">
                  Популярный
                </span>
              </div>
              <CardHeader className="bg-gray-800 rounded-t-lg pt-8">
                <CardTitle className="text-center">
                  <div className="text-2xl font-bold text-white">Герой</div>
                  <div className="text-4xl font-bold text-indigo-400 mt-2">
                    {isMonthly ? '299' : '239'} ₽
                  </div>
                  <div className="text-gray-300 font-medium">{isMonthly ? 'в месяц' : 'в месяц (при годовой оплате)'}</div>
                </CardTitle>
              </CardHeader>
              <CardContent className="flex-grow flex flex-col bg-gray-800">
                <p className="text-center text-gray-300 mb-6">Для профессионалов, которым нужны все инструменты</p>
                <ul className="space-y-3 flex-grow">
                  <li className="flex items-start">
                    <CheckCircle className="h-5 w-5 text-green-400 mr-3 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-200">Все из "Искателя"</span>
                  </li>
                  <li className="flex items-start">
                    <CheckCircle className="h-5 w-5 text-green-400 mr-3 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-200">Неограниченные личные Workspace</span>
                  </li>
                  <li className="flex items-start">
                    <CheckCircle className="h-5 w-5 text-green-400 mr-3 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-200">Продвинутая статистика и отчеты</span>
                  </li>
                  <li className="flex items-start">
                    <CheckCircle className="h-5 w-5 text-green-400 mr-3 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-200">Пользовательские челленджи</span>
                  </li>
                  <li className="flex items-start">
                    <CheckCircle className="h-5 w-5 text-green-400 mr-3 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-200">Интеграция с календарями</span>
                  </li>
                </ul>
                <div className="mt-auto pt-6">
                  <Button 
                    className="w-full bg-indigo-600 hover:bg-indigo-700 text-white"
                    onClick={() => navigate('/register')}
                  >
                    Выбрать "Героя"
                  </Button>
                </div>
              </CardContent>
            </Card>

            {/* Team Plan */}
            <Card className="relative flex flex-col h-full bg-gray-800">
              <CardHeader className="bg-gray-800 rounded-t-lg">
                <CardTitle className="text-center">
                  <div className="text-2xl font-bold text-white">Гильдия</div>
                  <div className="text-4xl font-bold text-purple-400 mt-2">
                    {isMonthly ? '249' : '199'} ₽
                  </div>
                  <div className="text-gray-300 font-medium">за пользователя {isMonthly ? 'в месяц' : 'в месяц (при годовой оплате)'}</div>
                </CardTitle>
              </CardHeader>
              <CardContent className="flex-grow flex flex-col bg-gray-800">
                <p className="text-center text-gray-300 mb-6">Для совместной работы и управления командой</p>
                <ul className="space-y-3 flex-grow">
                  <li className="flex items-start">
                    <CheckCircle className="h-5 w-5 text-green-400 mr-3 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-200">Все из "Героя"</span>
                  </li>
                  <li className="flex items-start">
                    <CheckCircle className="h-5 w-5 text-green-400 mr-3 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-200">Командные Workspace</span>
                  </li>
                  <li className="flex items-start">
                    <CheckCircle className="h-5 w-5 text-green-400 mr-3 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-200">Управление ролями и доступом</span>
                  </li>
                  <li className="flex items-start">
                    <CheckCircle className="h-5 w-5 text-green-400 mr-3 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-200">Общая Kanban-доска</span>
                  </li>
                  <li className="flex items-start">
                    <CheckCircle className="h-5 w-5 text-green-400 mr-3 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-200">Командная аналитика</span>
                  </li>
                  <li className="flex items-start">
                    <CheckCircle className="h-5 w-5 text-green-400 mr-3 mt-0.5 flex-shrink-0" />
                    <span className="text-gray-200">Приоритетная поддержка</span>
                  </li>
                </ul>
                <div className="mt-auto pt-6">
                  <Button 
                    className="w-full bg-purple-600 hover:bg-purple-700 text-white"
                    onClick={() => navigate('/register')}
                  >
                    Создать команду
                  </Button>
                </div>
              </CardContent>
            </Card>
          </div>
        </div>
      </section>

      {/* FAQ Section */}
      <section id="faq" className="py-20 bg-gray-50">
        <div className="max-w-3xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="text-center mb-16">
            <h2 className="text-3xl font-extrabold text-gray-900 sm:text-4xl">
              Часто Задаваемые Вопросы
            </h2>
          </div>

          <div className="space-y-4">
            {faqData.map((faq, index) => (
              <div key={index} className="bg-white rounded-lg shadow">
                <button
                  className="w-full px-6 py-4 text-left flex justify-between items-center focus:outline-none"
                  onClick={() => toggleFAQ(index)}
                >
                  <span className="text-lg font-medium text-gray-900">{faq.question}</span>
                  <ChevronDown 
                    className={`h-5 w-5 text-gray-500 transform transition-transform ${
                      openFAQ === index ? 'rotate-180' : ''
                    }`} 
                  />
                </button>
                {openFAQ === index && (
                  <div className="px-6 pb-4">
                    <p className="text-gray-600">{faq.answer}</p>
                  </div>
                )}
              </div>
            ))}
          </div>
        </div>
      </section>

      {/* Final CTA Section */}
      <section className="bg-indigo-700 py-16">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 text-center">
          <h2 className="text-3xl font-extrabold text-white">
            Готовы начать свой квест?
          </h2>
          <p className="mt-4 text-xl text-indigo-200">
            Присоединяйтесь к тысячам пользователей, которые уже повысили свою продуктивность
          </p>
          <div className="mt-8">
            <Button 
              size="lg"
              onClick={() => navigate('/register')}
              className="bg-white text-indigo-700 hover:bg-gray-100 font-bold text-lg px-8 py-4"
            >
              🚀 Зарегистрироваться бесплатно
            </Button>
          </div>
        </div>
      </section>

      {/* Footer */}
      <footer className="bg-gray-900 text-white py-12">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="grid md:grid-cols-4 gap-8">
            <div>
              <h3 className="text-lg font-semibold mb-4">Продукт</h3>
              <ul className="space-y-2">
                <li><a href="#features" className="text-gray-300 hover:text-white transition-colors">Возможности</a></li>
                <li><a href="#pricing" className="text-gray-300 hover:text-white transition-colors">Тарифы</a></li>
                <li><a href="#" className="text-gray-300 hover:text-white transition-colors">Для команд</a></li>
                <li><a href="#" className="text-gray-300 hover:text-white transition-colors">Для себя</a></li>
              </ul>
            </div>
            <div>
              <h3 className="text-lg font-semibold mb-4">Компания</h3>
              <ul className="space-y-2">
                <li><a href="#" className="text-gray-300 hover:text-white transition-colors">О нас</a></li>
                <li><a href="#" className="text-gray-300 hover:text-white transition-colors">Блог</a></li>
                <li><a href="#" className="text-gray-300 hover:text-white transition-colors">Контакты</a></li>
              </ul>
            </div>
            <div>
              <h3 className="text-lg font-semibold mb-4">Поддержка</h3>
              <ul className="space-y-2">
                <li><a href="#faq" className="text-gray-300 hover:text-white transition-colors">Центр помощи (FAQ)</a></li>
                <li><a href="#" className="text-gray-300 hover:text-white transition-colors">Руководства</a></li>
                <li><a href="#" className="text-gray-300 hover:text-white transition-colors">Сообщить об ошибке</a></li>
              </ul>
            </div>
            <div>
              <h3 className="text-lg font-semibold mb-4">Юридическая информация</h3>
              <ul className="space-y-2">
                <li><a href="#" className="text-gray-300 hover:text-white transition-colors">Политика конфиденциальности</a></li>
                <li><a href="#" className="text-gray-300 hover:text-white transition-colors">Условия использования</a></li>
              </ul>
            </div>
          </div>
          <div className="mt-8 pt-8 border-t border-gray-800 text-center">
            <p className="text-gray-400">
              © 2025 ProgressQuest Universal. Все права защищены.
            </p>
          </div>
        </div>
      </footer>
    </div>
  );
}

--- src/pages/LoginPage.tsx ---

import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Button } from "@/components/ui/button";
import { useAuth } from "@/contexts/AuthContext";

export const LoginPage = () => {
  const navigate = useNavigate();
  const { login, loginWithGoogle } = useAuth();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!email || !password) return;
    
    setLoading(true);
    try {
      await login(email, password);
      navigate('/app');
    } catch (error) {
      console.error('Login failed:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleGoogleLogin = async () => {
    try {
      await loginWithGoogle();
      navigate('/app');
    } catch (error) {
      console.error('Google login failed:', error);
    }
  };

  return (
    <div className="min-h-screen bg-gray-50 flex items-center justify-center">
      <div className="max-w-md w-full bg-white rounded-lg shadow-md p-8">
        <h2 className="text-2xl font-bold text-center mb-8">Вход в систему</h2>
        <form onSubmit={handleSubmit} className="space-y-6">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Email
            </label>
            <input
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
              placeholder="your@email.com"
              required
            />
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Пароль
            </label>
            <input
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
              placeholder="••••••••"
              required
            />
          </div>
          <Button
            type="submit"
            disabled={loading}
            className="w-full bg-indigo-600 hover:bg-indigo-700"
          >
            {loading ? 'Вход...' : 'Войти'}
          </Button>
          <p className="text-center">
            <a href="/forgot-password" className="text-sm text-indigo-600 hover:text-indigo-500">
              Забыли пароль?
            </a>
          </p>
        </form>

        <div className="mt-6">
          <div className="relative">
            <div className="absolute inset-0 flex items-center">
              <div className="w-full border-t border-gray-300"></div>
            </div>
            <div className="relative flex justify-center text-sm">
              <span className="px-2 bg-white text-gray-500">Или войдите с помощью</span>
            </div>
          </div>

          <div className="mt-6">
            <Button 
              variant="outline"
              className="w-full"
              onClick={handleGoogleLogin}
            >
              <svg className="w-5 h-5 mr-2" viewBox="0 0 24 24">
                <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
              </svg>
              Google
            </Button>
          </div>
        </div>

        <p className="mt-8 text-center text-sm text-gray-600">
          Нет аккаунта?
          <a href="/register" className="font-medium text-indigo-600 hover:text-indigo-500 ml-1">
            Зарегистрироваться
          </a>
        </p>
      </div>
    </div>
  );
};


--- src/pages/NotFoundPage.tsx ---

import { Link } from 'react-router-dom';

export const NotFoundPage = () => {
  return (
    <div className="min-h-screen bg-gray-50 flex items-center justify-center">
      <div className="text-center">
        <div className="text-9xl font-bold text-gray-300 mb-4">404</div>
        <h1 className="text-4xl font-bold text-gray-900 mb-4">Страница не найдена</h1>
        <p className="text-xl text-gray-600 mb-8">
          Извините, запрашиваемая страница не существует.
        </p>
        <Link 
          to="/" 
          className="bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors"
        >
          Вернуться на главную
        </Link>
      </div>
    </div>
  );
};


--- src/pages/ProfilePage.tsx ---

import React, { useState } from 'react';
import { useAuth } from '@/contexts/AuthContext';
import { toast } from 'sonner';

export const ProfilePage = () => {
  const { currentUser, updateUserProfile } = useAuth();
  const [isEditingName, setIsEditingName] = useState(false);
  const [newDisplayName, setNewDisplayName] = useState(currentUser?.displayName || '');

  const handleUpdateProfile = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newDisplayName.trim()) {
      toast.error('Имя не может быть пустым');
      return;
    }
    
    try {
      await updateUserProfile(newDisplayName.trim());
      setIsEditingName(false);
    } catch (error) {
      console.error('Error updating profile:', error);
    }
  };

  const formatJoinDate = (user: any) => {
    if (user?.metadata?.creationTime) {
      return new Date(user.metadata.creationTime).toLocaleDateString('ru-RU', {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });
    }
    return 'Неизвестно';
  };

  const getEmailVerificationStatus = () => {
    if (currentUser?.emailVerified) {
      return { text: 'Подтвержден', color: 'text-green-600' };
    }
    return { text: 'Не подтвержден', color: 'text-orange-600' };
  };

  return (
    <div className="p-6 bg-gradient-to-br from-slate-50 to-purple-50 min-h-screen">
      <div className="mb-6">
        <h1 className="text-3xl font-bold text-slate-800 mb-2 drop-shadow-sm">Профиль</h1>
        <p className="text-slate-600 font-medium">Управляйте своим профилем и достижениями</p>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <div className="lg:col-span-1">
          <div className="bg-white/90 backdrop-blur-sm rounded-lg shadow-lg border border-white/50 p-6 text-center">
            <div className="w-24 h-24 bg-gradient-to-br from-purple-100 to-blue-100 rounded-full mx-auto mb-4 flex items-center justify-center">
              {currentUser?.photoURL ? (
                <img
                  src={currentUser.photoURL}
                  alt={currentUser.displayName || 'Пользователь'}
                  className="w-24 h-24 rounded-full object-cover"
                />
              ) : (
                <span className="text-2xl text-slate-600">👤</span>
              )}
            </div>
            
            {isEditingName ? (
              <form onSubmit={handleUpdateProfile} className="mb-4">
                <input
                  type="text"
                  value={newDisplayName}
                  onChange={(e) => setNewDisplayName(e.target.value)}
                  className="w-full px-3 py-2 border border-slate-300 rounded-md focus:outline-none focus:ring-2 focus:ring-purple-500 text-center font-semibold"
                  autoFocus
                />
                <div className="flex justify-center space-x-2 mt-2">
                  <button
                    type="submit"
                    className="px-3 py-1 bg-purple-600 text-white rounded text-sm hover:bg-purple-700"
                  >
                    Сохранить
                  </button>
                  <button
                    type="button"
                    onClick={() => {
                      setIsEditingName(false);
                      setNewDisplayName(currentUser?.displayName || '');
                    }}
                    className="px-3 py-1 bg-gray-500 text-white rounded text-sm hover:bg-gray-600"
                  >
                    Отмена
                  </button>
                </div>
              </form>
            ) : (
              <div className="mb-4">
                <h2 className="text-xl font-semibold mb-1 text-slate-800">
                  {currentUser?.displayName || 'Пользователь'}
                </h2>
                <button
                  onClick={() => setIsEditingName(true)}
                  className="text-sm text-purple-600 hover:text-purple-800 underline"
                >
                  Изменить имя
                </button>
              </div>
            )}
            
            <p className="text-slate-600 mb-2">{currentUser?.email}</p>
            <div className={`text-xs ${getEmailVerificationStatus().color} mb-4`}>
              Email: {getEmailVerificationStatus().text}
            </div>
            
            <div className="border-t border-slate-200 pt-4">
              <div className="text-center mb-4">
                <div className="text-2xl font-bold text-purple-600">1</div>
                <div className="text-sm text-slate-600">Уровень</div>
              </div>
              <div className="w-full bg-slate-200 rounded-full h-2 mb-4">
                <div className="bg-purple-600 h-2 rounded-full" style={{width: '0%'}}></div>
              </div>
              <div className="text-sm text-slate-600">0 / 100 XP</div>
            </div>
            
            <div className="border-t border-slate-200 pt-4 mt-4">
              <div className="text-xs text-slate-500">
                Регистрация: {formatJoinDate(currentUser)}
              </div>
            </div>
          </div>

          <div className="bg-white/90 backdrop-blur-sm rounded-lg shadow-lg border border-white/50 p-6 mt-6">
            <h3 className="text-lg font-semibold mb-4 text-slate-700">Статистика</h3>
            <div className="space-y-3">
              <div className="flex justify-between">
                <span className="text-slate-600">Выполнено задач:</span>
                <span className="font-semibold text-slate-800">0</span>
              </div>
              <div className="flex justify-between">
                <span className="text-slate-600">Pomodoro сессий:</span>
                <span className="font-semibold text-slate-800">0</span>
              </div>
              <div className="flex justify-between">
                <span className="text-slate-600">Дней подряд:</span>
                <span className="font-semibold text-slate-800">0</span>
              </div>
              <div className="flex justify-between">
                <span className="text-slate-600">Проектов:</span>
                <span className="font-semibold text-slate-800">0</span>
              </div>
            </div>
          </div>
        </div>

        <div className="lg:col-span-2">
          <div className="bg-white/90 backdrop-blur-sm rounded-lg shadow-lg border border-white/50 p-6 mb-6">
            <h3 className="text-xl font-semibold mb-6 text-slate-700">Информация об аккаунте</h3>
            <div className="space-y-4">
              <div>
                <label className="block text-sm font-semibold text-slate-700 mb-2">
                  Отображаемое имя
                </label>
                <div className="px-3 py-2 border border-slate-300 rounded-md bg-slate-50 text-slate-700">
                  {currentUser?.displayName || 'Не указано'}
                </div>
                <p className="text-xs text-slate-500 mt-1">Используйте кнопку "Изменить имя" в боковой панели</p>
              </div>
              <div>
                <label className="block text-sm font-semibold text-slate-700 mb-2">
                  Email адрес
                </label>
                <div className="px-3 py-2 border border-slate-300 rounded-md bg-slate-50 text-slate-700">
                  {currentUser?.email}
                </div>
                <p className="text-xs text-slate-500 mt-1">Email нельзя изменить после регистрации</p>
              </div>
              <div>
                <label className="block text-sm font-semibold text-slate-700 mb-2">
                  Статус верификации
                </label>
                <div className={`px-3 py-2 border border-slate-300 rounded-md ${currentUser?.emailVerified ? 'bg-green-50 text-green-700' : 'bg-orange-50 text-orange-700'}`}>
                  {currentUser?.emailVerified ? '✅ Email подтвержден' : '⚠️ Email не подтвержден'}
                </div>
                {!currentUser?.emailVerified && (
                  <p className="text-xs text-orange-600 mt-1">Проверьте почту и подтвердите email адрес</p>
                )}
              </div>
              <div>
                <label className="block text-sm font-semibold text-slate-700 mb-2">
                  Провайдер входа
                </label>
                <div className="px-3 py-2 border border-slate-300 rounded-md bg-slate-50 text-slate-700">
                  {currentUser?.providerData?.[0]?.providerId === 'google.com' ? '🔗 Google' : '📧 Email/Пароль'}
                </div>
              </div>
            </div>
          </div>

          <div className="bg-white/90 backdrop-blur-sm rounded-lg shadow-lg border border-white/50 p-6">
            <h3 className="text-xl font-semibold mb-6 text-slate-700">Достижения</h3>
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
              <div className="text-center p-4 bg-gradient-to-br from-slate-100 to-slate-200 rounded-lg hover:shadow-md transition-all duration-200">
                <div className="text-2xl mb-2">🏆</div>
                <div className="text-sm font-medium text-slate-700">Первые шаги</div>
                <div className="text-xs text-slate-500">Заблокировано</div>
              </div>
              <div className="text-center p-4 bg-gradient-to-br from-slate-100 to-slate-200 rounded-lg hover:shadow-md transition-all duration-200">
                <div className="text-2xl mb-2">⭐</div>
                <div className="text-sm font-medium text-slate-700">Продуктивный</div>
                <div className="text-xs text-slate-500">Заблокировано</div>
              </div>
              <div className="text-center p-4 bg-gradient-to-br from-slate-100 to-slate-200 rounded-lg hover:shadow-md transition-all duration-200">
                <div className="text-2xl mb-2">🔥</div>
                <div className="text-sm font-medium text-slate-700">Streak мастер</div>
                <div className="text-xs text-slate-500">Заблокировано</div>
              </div>
              <div className="text-center p-4 bg-gradient-to-br from-slate-100 to-slate-200 rounded-lg hover:shadow-md transition-all duration-200">
                <div className="text-2xl mb-2">🌱</div>
                <div className="text-sm font-medium text-slate-700">Садовник</div>
                <div className="text-xs text-slate-500">Заблокировано</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};


--- src/pages/ProjectsPage.tsx ---


export const ProjectsPage = () => {
  return (
    <div className="p-6">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-gray-900">Проекты</h1>
        <button className="bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700">
          Новый проект
        </button>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <div className="bg-white p-6 rounded-lg shadow-md border-2 border-dashed border-gray-200 flex flex-col items-center justify-center min-h-[200px]">
          <div className="text-gray-400 text-4xl mb-4">+</div>
          <h3 className="text-lg font-medium text-gray-600 mb-2">Создать проект</h3>
          <p className="text-gray-500 text-sm text-center">
            Организуйте свои задачи в проекты для лучшего управления
          </p>
        </div>
      </div>
    </div>
  );
};


--- src/pages/RegisterPage.tsx ---

import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Button } from "@/components/ui/button";
import { useAuth } from "@/contexts/AuthContext";
import { toast } from 'sonner';

export const RegisterPage = () => {
  const navigate = useNavigate();
  const { register, loginWithGoogle } = useAuth();
  const [formData, setFormData] = useState({
    displayName: '',
    email: '',
    password: '',
    confirmPassword: ''
  });
  const [loading, setLoading] = useState(false);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value
    });
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (formData.password !== formData.confirmPassword) {
      toast.error('Пароли не совпадают');
      return;
    }
    
    if (formData.password.length < 6) {
      toast.error('Пароль должен содержать минимум 6 символов');
      return;
    }
    
    setLoading(true);
    try {
      await register(formData.email, formData.password, formData.displayName);
      navigate('/app');
    } catch (error) {
      console.error('Registration failed:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleGoogleLogin = async () => {
    try {
      await loginWithGoogle();
      navigate('/app');
    } catch (error) {
      console.error('Google login failed:', error);
    }
  };

  return (
    <div className="min-h-screen bg-gray-50 flex items-center justify-center">
      <div className="max-w-md w-full bg-white rounded-lg shadow-md p-8">
        <h2 className="text-2xl font-bold text-center mb-8">Регистрация</h2>
        <form onSubmit={handleSubmit} className="space-y-6">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Имя
            </label>
            <input
              type="text"
              name="displayName"
              value={formData.displayName}
              onChange={handleChange}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
              placeholder="Ваше имя"
              required
            />
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Email
            </label>
            <input
              type="email"
              name="email"
              value={formData.email}
              onChange={handleChange}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
              placeholder="your@email.com"
              required
            />
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Пароль
            </label>
            <input
              type="password"
              name="password"
              value={formData.password}
              onChange={handleChange}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
              placeholder="••••••••"
              required
              minLength={6}
            />
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Подтвердите пароль
            </label>
            <input
              type="password"
              name="confirmPassword"
              value={formData.confirmPassword}
              onChange={handleChange}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
              placeholder="••••••••"
              required
              minLength={6}
            />
          </div>
          <Button
            type="submit"
            disabled={loading}
            className="w-full bg-indigo-600 hover:bg-indigo-700"
          >
            {loading ? 'Регистрация...' : 'Зарегистрироваться'}
          </Button>
        </form>

        <div className="mt-6">
          <div className="relative">
            <div className="absolute inset-0 flex items-center">
              <div className="w-full border-t border-gray-300"></div>
            </div>
            <div className="relative flex justify-center text-sm">
              <span className="px-2 bg-white text-gray-500">Или зарегистрируйтесь с помощью</span>
            </div>
          </div>

          <div className="mt-6">
            <Button 
              variant="outline"
              className="w-full"
              onClick={handleGoogleLogin}
            >
              <svg className="w-5 h-5 mr-2" viewBox="0 0 24 24">
                <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
              </svg>
              Google
            </Button>
          </div>
        </div>

        <p className="mt-8 text-center text-sm text-gray-600">
          Уже есть аккаунт?
          <a href="/login" className="font-medium text-indigo-600 hover:text-indigo-500 ml-1">
            Войти
          </a>
        </p>
      </div>
    </div>
  );
};


--- src/pages/SettingsPage.tsx ---

import React, { useState } from 'react';

type SettingsSection = 'general' | 'notifications' | 'pomodoro' | 'gamification' | 'security';

export const SettingsPage = () => {
  const [activeSection, setActiveSection] = useState<SettingsSection>('general');

  const sections = [
    { id: 'general' as const, name: 'Общие', icon: '⚙️' },
    { id: 'notifications' as const, name: 'Уведомления', icon: '🔔' },
    { id: 'pomodoro' as const, name: 'Pomodoro', icon: '🍅' },
    { id: 'gamification' as const, name: 'Геймификация', icon: '🎮' },
    { id: 'security' as const, name: 'Безопасность', icon: '🔒' },
  ];

  const renderContent = () => {
    switch (activeSection) {
      case 'general':
        return (
          <div>
            <h2 className="text-xl font-semibold mb-6 text-slate-700">Общие настройки</h2>
            <div className="space-y-6">
              <div>
                <label className="block text-sm font-semibold text-slate-700 mb-2">
                  Тема
                </label>
                <select className="w-full px-3 py-2 border border-slate-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white/90 text-slate-700 font-medium">
                  <option>Системная</option>
                  <option>Светлая</option>
                  <option>Темная</option>
                </select>
              </div>
              <div>
                <label className="block text-sm font-semibold text-slate-700 mb-2">
                  Язык
                </label>
                <select className="w-full px-3 py-2 border border-slate-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white/90 text-slate-700 font-medium">
                  <option>Русский</option>
                  <option>English</option>
                </select>
              </div>
              <div>
                <label className="block text-sm font-semibold text-slate-700 mb-2">
                  Часовой пояс
                </label>
                <select className="w-full px-3 py-2 border border-slate-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white/90 text-slate-700 font-medium">
                  <option>UTC+3 (Москва)</option>
                  <option>UTC+0 (GMT)</option>
                </select>
              </div>
              <div className="pt-4">
                <button className="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 shadow-md font-medium transition-all duration-200 hover:shadow-lg">
                  Сохранить изменения
                </button>
              </div>
            </div>
          </div>
        );
      
      case 'notifications':
        return (
          <div>
            <h2 className="text-xl font-semibold mb-6 text-slate-700">Настройки уведомлений</h2>
            <div className="space-y-6">
              <div className="flex items-center justify-between">
                <div>
                  <h3 className="text-sm font-semibold text-slate-700">Уведомления о задачах</h3>
                  <p className="text-xs text-slate-500">Получать уведомления о новых задачах</p>
                </div>
                <label className="relative inline-flex items-center cursor-pointer">
                  <input type="checkbox" className="sr-only peer" defaultChecked />
                  <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                </label>
              </div>
              <div className="flex items-center justify-between">
                <div>
                  <h3 className="text-sm font-semibold text-slate-700">Pomodoro уведомления</h3>
                  <p className="text-xs text-slate-500">Уведомления о окончании сессий</p>
                </div>
                <label className="relative inline-flex items-center cursor-pointer">
                  <input type="checkbox" className="sr-only peer" defaultChecked />
                  <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                </label>
              </div>
              <div className="flex items-center justify-between">
                <div>
                  <h3 className="text-sm font-semibold text-slate-700">Достижения</h3>
                  <p className="text-xs text-slate-500">Уведомления о новых достижениях</p>
                </div>
                <label className="relative inline-flex items-center cursor-pointer">
                  <input type="checkbox" className="sr-only peer" defaultChecked />
                  <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                </label>
              </div>
            </div>
          </div>
        );
      
      case 'pomodoro':
        return (
          <div>
            <h2 className="text-xl font-semibold mb-6 text-slate-700">Настройки Pomodoro</h2>
            <div className="space-y-6">
              <div>
                <label className="block text-sm font-semibold text-slate-700 mb-2">
                  Продолжительность рабочей сессии (минут)
                </label>
                <input
                  type="number"
                  min="1"
                  max="60"
                  defaultValue="25"
                  className="w-full px-3 py-2 border border-slate-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white/90 text-slate-700 font-medium"
                />
              </div>
              <div>
                <label className="block text-sm font-semibold text-slate-700 mb-2">
                  Короткий перерыв (минут)
                </label>
                <input
                  type="number"
                  min="1"
                  max="30"
                  defaultValue="5"
                  className="w-full px-3 py-2 border border-slate-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white/90 text-slate-700 font-medium"
                />
              </div>
              <div>
                <label className="block text-sm font-semibold text-slate-700 mb-2">
                  Длинный перерыв (минут)
                </label>
                <input
                  type="number"
                  min="10"
                  max="60"
                  defaultValue="15"
                  className="w-full px-3 py-2 border border-slate-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white/90 text-slate-700 font-medium"
                />
              </div>
              <div>
                <label className="block text-sm font-semibold text-slate-700 mb-2">
                  Количество сессий до длинного перерыва
                </label>
                <input
                  type="number"
                  min="2"
                  max="8"
                  defaultValue="4"
                  className="w-full px-3 py-2 border border-slate-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white/90 text-slate-700 font-medium"
                />
              </div>
            </div>
          </div>
        );
      
      case 'gamification':
        return (
          <div>
            <h2 className="text-xl font-semibold mb-6 text-slate-700">Настройки геймификации</h2>
            <div className="space-y-6">
              <div className="flex items-center justify-between">
                <div>
                  <h3 className="text-sm font-semibold text-slate-700">Система опыта</h3>
                  <p className="text-xs text-slate-500">Получать опыт за выполненные задачи</p>
                </div>
                <label className="relative inline-flex items-center cursor-pointer">
                  <input type="checkbox" className="sr-only peer" defaultChecked />
                  <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                </label>
              </div>
              <div className="flex items-center justify-between">
                <div>
                  <h3 className="text-sm font-semibold text-slate-700">Достижения</h3>
                  <p className="text-xs text-slate-500">Отображать достижения и награды</p>
                </div>
                <label className="relative inline-flex items-center cursor-pointer">
                  <input type="checkbox" className="sr-only peer" defaultChecked />
                  <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                </label>
              </div>
              <div className="flex items-center justify-between">
                <div>
                  <h3 className="text-sm font-semibold text-slate-700">Виртуальный сад</h3>
                  <p className="text-xs text-slate-500">Выращивать растения за выполненные задачи</p>
                </div>
                <label className="relative inline-flex items-center cursor-pointer">
                  <input type="checkbox" className="sr-only peer" defaultChecked />
                  <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                </label>
              </div>
            </div>
          </div>
        );
      
      case 'security':
        return (
          <div>
            <h2 className="text-xl font-semibold mb-6 text-slate-700">Настройки безопасности</h2>
            <div className="space-y-6">
              <div>
                <h3 className="text-sm font-semibold text-slate-700 mb-4">Смена пароля</h3>
                <div className="space-y-4">
                  <div>
                    <label className="block text-sm font-medium text-slate-700 mb-2">
                      Текущий пароль
                    </label>
                    <input
                      type="password"
                      className="w-full px-3 py-2 border border-slate-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white/90 text-slate-700"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-slate-700 mb-2">
                      Новый пароль
                    </label>
                    <input
                      type="password"
                      className="w-full px-3 py-2 border border-slate-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white/90 text-slate-700"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-slate-700 mb-2">
                      Подтверждение пароля
                    </label>
                    <input
                      type="password"
                      className="w-full px-3 py-2 border border-slate-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white/90 text-slate-700"
                    />
                  </div>
                  <button className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors">
                    Изменить пароль
                  </button>
                </div>
              </div>
              <div className="border-t border-slate-200 pt-6">
                <h3 className="text-sm font-semibold text-slate-700 mb-4 text-red-600">Опасная зона</h3>
                <button className="bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700 transition-colors">
                  Удалить аккаунт
                </button>
                <p className="text-xs text-slate-500 mt-2">Это действие нельзя отменить</p>
              </div>
            </div>
          </div>
        );
      
      default:
        return null;
    }
  };

  return (
    <div className="p-6 bg-gradient-to-br from-slate-50 to-indigo-50 min-h-screen">
      <div className="mb-6">
        <h1 className="text-3xl font-bold text-slate-800 mb-2 drop-shadow-sm">Настройки</h1>
        <p className="text-slate-600 font-medium">Персонализируйте свой опыт использования</p>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <div className="lg:col-span-1">
          <div className="bg-white/90 backdrop-blur-sm rounded-lg shadow-lg border border-white/50 p-4">
            <nav className="space-y-2">
              {sections.map((section) => (
                <button
                  key={section.id}
                  onClick={() => setActiveSection(section.id)}
                  className={`w-full text-left px-4 py-2 rounded-lg font-medium transition-all duration-200 flex items-center space-x-3 ${
                    activeSection === section.id
                      ? 'bg-blue-100 text-blue-800 shadow-sm border border-blue-200'
                      : 'text-slate-700 hover:bg-slate-100 hover:text-slate-800'
                  }`}
                >
                  <span className="text-lg">{section.icon}</span>
                  <span>{section.name}</span>
                </button>
              ))}
            </nav>
          </div>
        </div>

        <div className="lg:col-span-2">
          <div className="bg-white/90 backdrop-blur-sm rounded-lg shadow-lg border border-white/50 p-6">
            {renderContent()}
          </div>
        </div>
      </div>
    </div>
  );
};


--- src/pages/TasksPage.tsx ---

import React, { useState } from 'react';
import { CreateTaskModal } from '@/components/CreateTaskModal';

export const TasksPage = () => {
  const [isCreateTaskModalOpen, setIsCreateTaskModalOpen] = useState(false);

  const handleCreateTask = (taskData: any) => {
    // Здесь будет логика сохранения задачи
    console.log('Создаётся задача на странице задач:', taskData);
    // TODO: Интеграция с backend/Firebase
  };

  return (
    <div className="p-6 bg-gradient-to-br from-slate-50 to-blue-50 min-h-screen">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-slate-800 drop-shadow-sm">Задачи</h1>
        <button
          onClick={() => setIsCreateTaskModalOpen(true)}
          className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 shadow-md transition-all duration-200 hover:shadow-lg"
        >
          + Новая задача
        </button>
      </div>

      <div className="bg-white rounded-lg shadow-md">
        <div className="p-6">
          <div className="flex space-x-4 mb-6">
            <button className="px-4 py-2 bg-blue-100 text-blue-800 rounded-lg">
              Все
            </button>
            <button className="px-4 py-2 text-gray-600 hover:bg-gray-100 rounded-lg">
              К выполнению
            </button>
            <button className="px-4 py-2 text-gray-600 hover:bg-gray-100 rounded-lg">
              В работе
            </button>
            <button className="px-4 py-2 text-gray-600 hover:bg-gray-100 rounded-lg">
              Выполнено
            </button>
          </div>

          <div className="text-center py-12">
            <p className="text-slate-500 text-lg">Задач пока нет</p>
            <p className="text-slate-400 mt-2">Создайте свою первую задачу, чтобы начать</p>
          </div>
        </div>
      </div>

      {/* Create Task Modal */}
      <CreateTaskModal
        isOpen={isCreateTaskModalOpen}
        onClose={() => setIsCreateTaskModalOpen(false)}
        onSubmit={handleCreateTask}
      />
    </div>
  );
};


--- src/pages/WorkspacePage.tsx ---

import React, { useState, useEffect } from 'react'
import { useSearchParams } from 'react-router-dom'
import { useWorkspaces, useCreateWorkspace, useUpdateWorkspace, useDeleteWorkspace } from '@/hooks/useWorkspaces'
import { useWorkspaceStore } from '@/stores/workspaceStore'
import { WorkspaceCard } from '@/components/WorkspaceCard'
import { WorkspaceModal } from '@/components/WorkspaceModal'
import { WorkspaceClientDto, CreateWorkspacePayload } from '@/services/workspaceService'
import { toast } from 'sonner'

export const WorkspacesPage: React.FC = () => {
  const [searchParams, setSearchParams] = useSearchParams()
  
  const {
    workspaces,
    searchQuery,
    viewMode,
    showPersonalOnly,
    showTeamOnly,
    selectedTags,
    sortBy,
    sortOrder,
    getAllTags,
    getFilteredWorkspaces,
    setWorkspaces,
    setSearchQuery,
    setViewMode,
    setShowPersonalOnly,
    setShowTeamOnly,
    toggleTag,
    setSortBy,
    setSortOrder,
    clearFilters,
  } = useWorkspaceStore()

  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false)
  const [isEditModalOpen, setIsEditModalOpen] = useState(false)
  const [editingWorkspace, setEditingWorkspace] = useState<WorkspaceClientDto | null>(null)

  // React Query hooks
  const {
    data: workspacesData,
    isLoading: isLoadingWorkspaces,
    error: workspacesError,
  } = useWorkspaces()

  const createWorkspaceMutation = useCreateWorkspace()
  const updateWorkspaceMutation = useUpdateWorkspace()
  const deleteWorkspaceMutation = useDeleteWorkspace()

  // Синхронизация данных с сервера
  useEffect(() => {
    if (workspacesData?.workspaces) {
      setWorkspaces(workspacesData.workspaces)
    }
  }, [workspacesData, setWorkspaces])

  // Обработка URL параметра create
  useEffect(() => {
    if (searchParams.get('create') === 'true') {
      setIsCreateModalOpen(true)
      // Удаляем параметр из URL
      setSearchParams(prev => {
        const newParams = new URLSearchParams(prev)
        newParams.delete('create')
        return newParams
      })
    }
  }, [searchParams, setSearchParams])

  // Получаем отфильтрованные рабочие пространства
  const filteredWorkspaces = getFilteredWorkspaces()
  const allTags = getAllTags()

  // Обработчики
  const handleCreateWorkspace = async (payload: CreateWorkspacePayload) => {
    try {
      await createWorkspaceMutation.mutateAsync(payload)
      setIsCreateModalOpen(false)
    } catch (error) {
      console.error('Ошибка создания рабочего пространства:', error)
    }
  }

  const handleEditWorkspace = (workspace: WorkspaceClientDto) => {
    setEditingWorkspace(workspace)
    setIsEditModalOpen(true)
  }

  const handleUpdateWorkspace = async (payload: CreateWorkspacePayload) => {
    if (!editingWorkspace) return

    try {
      await updateWorkspaceMutation.mutateAsync({
        workspaceId: editingWorkspace.id,
        ...payload,
      })
      setIsEditModalOpen(false)
      setEditingWorkspace(null)
    } catch (error) {
      console.error('Ошибка обновления рабочего пространства:', error)
    }
  }

  const handleDeleteWorkspace = async (workspaceId: string) => {
    try {
      await deleteWorkspaceMutation.mutateAsync(workspaceId)
    } catch (error) {
      console.error('Ошибка удаления рабочего пространства:', error)
    }
  }

  const handleSortChange = (newSortBy: 'name' | 'created' | 'updated') => {
    if (sortBy === newSortBy) {
      setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc')
    } else {
      setSortBy(newSortBy)
      setSortOrder('desc')
    }
  }

  if (isLoadingWorkspaces) {
    return (
      <div className="p-6 bg-gradient-to-br from-slate-50 to-blue-50 min-h-screen">
        <div className="flex items-center justify-center h-64">
          <div className="text-center">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
            <p className="text-slate-600">Загружаем рабочие пространства...</p>
          </div>
        </div>
      </div>
    )
  }

  if (workspacesError) {
    return (
      <div className="p-6 bg-gradient-to-br from-slate-50 to-blue-50 min-h-screen">
        <div className="flex items-center justify-center h-64">
          <div className="text-center">
            <div className="text-red-500 text-xl mb-4">⚠️</div>
            <h3 className="text-lg font-semibold text-slate-800 mb-2">Ошибка загрузки</h3>
            <p className="text-slate-600 mb-4">{workspacesError.message}</p>
            <button
              onClick={() => window.location.reload()}
              className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
            >
              Попробовать снова
            </button>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="p-6 bg-gradient-to-br from-slate-50 to-blue-50 min-h-screen">
      {/* Header */}
      <div className="mb-8">
        <div className="flex items-center justify-between mb-4">
          <div>
            <h1 className="text-3xl font-bold text-slate-800 mb-2">Рабочие пространства</h1>
            <p className="text-slate-600">
              Управляйте своими проектами и задачами в организованных пространствах
            </p>
          </div>
          <button
            onClick={() => setIsCreateModalOpen(true)}
            disabled={createWorkspaceMutation.isPending}
            className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 shadow-md transition-all duration-200 hover:shadow-lg disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {createWorkspaceMutation.isPending ? '⏳ Создание...' : '+ Новое пространство'}
          </button>
        </div>

        {/* Stats */}
        <div className="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
          <div className="bg-white p-4 rounded-lg shadow-sm border">
            <div className="text-2xl font-bold text-blue-600">{workspaces.length}</div>
            <div className="text-sm text-slate-600">Всего пространств</div>
          </div>
          <div className="bg-white p-4 rounded-lg shadow-sm border">
            <div className="text-2xl font-bold text-green-600">
              {workspaces.filter(w => w.isPersonal).length}
            </div>
            <div className="text-sm text-slate-600">Личных</div>
          </div>
          <div className="bg-white p-4 rounded-lg shadow-sm border">
            <div className="text-2xl font-bold text-purple-600">
              {workspaces.filter(w => !w.isPersonal).length}
            </div>
            <div className="text-sm text-slate-600">Командных</div>
          </div>
          <div className="bg-white p-4 rounded-lg shadow-sm border">
            <div className="text-2xl font-bold text-orange-600">{allTags.length}</div>
            <div className="text-sm text-slate-600">Уникальных тегов</div>
          </div>
        </div>
      </div>

      {/* Filters and Controls */}
      <div className="bg-white rounded-lg border border-slate-200 shadow-sm mb-6">
        <div className="p-4 border-b border-slate-200">
          {/* Search and View Toggle */}
          <div className="flex items-center justify-between mb-4">
            <div className="flex-1 max-w-md">
              <input
                type="text"
                placeholder="Поиск по названию или описанию..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="w-full px-3 py-2 border border-slate-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white text-slate-900"
              />
            </div>
            
            {/* View Mode Toggle */}
            <div className="flex items-center space-x-2 ml-4">
              <button
                onClick={() => setViewMode('grid')}
                className={`p-2 rounded ${viewMode === 'grid' ? 'bg-blue-100 text-blue-700' : 'text-slate-600 hover:bg-slate-100'}`}
                title="Сетка"
              >
                ⊞
              </button>
              <button
                onClick={() => setViewMode('list')}
                className={`p-2 rounded ${viewMode === 'list' ? 'bg-blue-100 text-blue-700' : 'text-slate-600 hover:bg-slate-100'}`}
                title="Список"
              >
                ☰
              </button>
            </div>
          </div>

          {/* Filter buttons */}
          <div className="flex flex-wrap items-center gap-3 mb-4">
            <button
              onClick={() => setShowPersonalOnly(!showPersonalOnly)}
              className={`px-3 py-1 rounded-full text-sm border transition-colors ${
                showPersonalOnly
                  ? 'bg-blue-100 text-blue-700 border-blue-300'
                  : 'bg-white text-slate-600 border-slate-300 hover:bg-slate-50'
              }`}
            >
              👤 Только личные
            </button>
            
            <button
              onClick={() => setShowTeamOnly(!showTeamOnly)}
              className={`px-3 py-1 rounded-full text-sm border transition-colors ${
                showTeamOnly
                  ? 'bg-purple-100 text-purple-700 border-purple-300'
                  : 'bg-white text-slate-600 border-slate-300 hover:bg-slate-50'
              }`}
            >
              👥 Только командные
            </button>

            {/* Tag filters */}
            {allTags.slice(0, 5).map((tag) => (
              <button
                key={tag}
                onClick={() => toggleTag(tag)}
                className={`px-3 py-1 rounded-full text-sm border transition-colors ${
                  selectedTags.includes(tag)
                    ? 'bg-green-100 text-green-700 border-green-300'
                    : 'bg-white text-slate-600 border-slate-300 hover:bg-slate-50'
                }`}
              >
                #{tag}
              </button>
            ))}

            {(searchQuery || showPersonalOnly || showTeamOnly || selectedTags.length > 0) && (
              <button
                onClick={clearFilters}
                className="px-3 py-1 text-sm text-red-600 hover:bg-red-50 rounded"
              >
                ✕ Очистить фильтры
              </button>
            )}
          </div>

          {/* Sort options */}
          <div className="flex items-center space-x-4">
            <span className="text-sm text-slate-600">Сортировать:</span>
            {(['name', 'created', 'updated'] as const).map((option) => (
              <button
                key={option}
                onClick={() => handleSortChange(option)}
                className={`text-sm px-2 py-1 rounded transition-colors ${
                  sortBy === option
                    ? 'bg-blue-100 text-blue-700'
                    : 'text-slate-600 hover:bg-slate-100'
                }`}
              >
                {option === 'name' && 'По названию'}
                {option === 'created' && 'По дате создания'}
                {option === 'updated' && 'По обновлению'}
                {sortBy === option && (sortOrder === 'asc' ? ' ↑' : ' ↓')}
              </button>
            ))}
          </div>
        </div>

        {/* Results count */}
        <div className="px-4 py-2 bg-slate-50 text-sm text-slate-600">
          Найдено: {filteredWorkspaces.length} из {workspaces.length} пространств
        </div>
      </div>

      {/* Workspaces Grid/List */}
      {filteredWorkspaces.length === 0 ? (
        <div className="text-center py-12">
          <div className="text-6xl mb-4">🏢</div>
          <h3 className="text-xl font-semibold text-slate-800 mb-2">
            {workspaces.length === 0 ? 'Пространств пока нет' : 'Ничего не найдено'}
          </h3>
          <p className="text-slate-600 mb-6">
            {workspaces.length === 0
              ? 'Создайте своё первое рабочее пространство для организации задач'
              : 'Попробуйте изменить параметры поиска или очистить фильтры'
            }
          </p>
          {workspaces.length === 0 && (
            <button
              onClick={() => setIsCreateModalOpen(true)}
              className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
            >
              + Создать первое пространство
            </button>
          )}
        </div>
      ) : (
        <div className={`${
          viewMode === 'grid'
            ? 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6'
            : 'space-y-4'
        }`}>
          {filteredWorkspaces.map((workspace) => (
            <WorkspaceCard
              key={workspace.id}
              workspace={workspace}
              onEdit={handleEditWorkspace}
              onDelete={handleDeleteWorkspace}
              variant={viewMode === 'list' ? 'detailed' : 'default'}
            />
          ))}
        </div>
      )}

      {/* Create Workspace Modal */}
      <WorkspaceModal
        isOpen={isCreateModalOpen}
        onClose={() => setIsCreateModalOpen(false)}
        onSubmit={handleCreateWorkspace}
        mode="create"
      />

      {/* Edit Workspace Modal */}
      <WorkspaceModal
        isOpen={isEditModalOpen}
        onClose={() => {
          setIsEditModalOpen(false)
          setEditingWorkspace(null)
        }}
        onSubmit={handleUpdateWorkspace}
        workspace={editingWorkspace}
        mode="edit"
      />
    </div>
  )
}



--- src/services/firebase.ts ---

import { app } from '@/lib/firebase'

// Initialize Firebase app
export function initializeApp() {
  return app
}

// Utility function to handle Firebase errors
export function handleFirebaseError(error: any): string {
  switch (error.code) {
    case 'auth/user-not-found':
      return 'Пользователь не найден'
    case 'auth/wrong-password':
      return 'Неверный пароль'
    case 'auth/email-already-in-use':
      return 'Email уже используется'
    case 'auth/weak-password':
      return 'Пароль должен содержать минимум 6 символов'
    case 'auth/invalid-email':
      return 'Неверный формат email'
    case 'auth/too-many-requests':
      return 'Слишком много попыток. Попробуйте позже'
    case 'permission-denied':
      return 'Недостаточно прав доступа'
    case 'not-found':
      return 'Документ не найден'
    case 'already-exists':
      return 'Документ уже существует'
    case 'resource-exhausted':
      return 'Превышен лимит запросов'
    case 'unavailable':
      return 'Сервис временно недоступен'
    default:
      console.error('Firebase error:', error)
      return error.message || 'Произошла неизвестная ошибка'
  }
}


--- src/services/taskService.ts ---

import {
  collection,
  doc,
  getDoc,
  getDocs,
  addDoc,
  updateDoc,
  deleteDoc,
  query,
  where,
  orderBy,
  limit,
  startAfter,
  serverTimestamp,
  writeBatch,
} from 'firebase/firestore'
import { db } from '@/lib/firebase'
import { Task, TaskStatus, TaskPriority, PaginatedResponse } from '@/types'
import { handleFirebaseError } from './firebase'
import { generateId } from '@/utils/helpers'

const TASKS_COLLECTION = 'tasks'

export interface TaskFilters {
  workspaceId?: string
  projectId?: string
  assigneeId?: string
  status?: TaskStatus
  priority?: TaskPriority
  tags?: string[]
  dueDate?: Date
  isArchived?: boolean
}

export interface TaskCreateData {
  title: string
  description?: string
  workspaceId: string
  projectId?: string
  assigneeId?: string
  priority: TaskPriority
  tags?: string[]
  dueDate?: Date
  estimatedDuration?: number
  parentId?: string
}

export class TaskService {
  // Create a new task
  static async createTask(
    userId: string,
    taskData: TaskCreateData
  ): Promise<string> {
    try {
      const taskRef = collection(db, TASKS_COLLECTION)
      
      const task: Omit<Task, 'id'> = {
        title: taskData.title,
        description: taskData.description,
        workspaceId: taskData.workspaceId,
        projectId: taskData.projectId,
        assigneeId: taskData.assigneeId,
        createdById: userId,
        parentId: taskData.parentId,
        status: 'todo',
        priority: taskData.priority,
        tags: taskData.tags || [],
        dueDate: taskData.dueDate,
        createdAt: new Date(),
        updatedAt: new Date(),
        estimatedDuration: taskData.estimatedDuration,
        pomodoroCount: 0,
        attachments: [],
        comments: [],
        dependencies: [],
        customFields: {},
        isArchived: false,
      }

      const docRef = await addDoc(taskRef, {
        ...task,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
      })

      return docRef.id
    } catch (error) {
      throw new Error(handleFirebaseError(error))
    }
  }

  // Get task by ID
  static async getTask(taskId: string): Promise<Task | null> {
    try {
      const taskRef = doc(db, TASKS_COLLECTION, taskId)
      const taskSnap = await getDoc(taskRef)
      
      if (taskSnap.exists()) {
        const data = taskSnap.data()
        return {
          id: taskSnap.id,
          ...data,
          createdAt: data.createdAt?.toDate() || new Date(),
          updatedAt: data.updatedAt?.toDate() || new Date(),
          dueDate: data.dueDate?.toDate(),
          completedAt: data.completedAt?.toDate(),
        } as Task
      }
      
      return null
    } catch (error) {
      throw new Error(handleFirebaseError(error))
    }
  }

  // Get tasks with filters and pagination
  static async getTasks(
    filters: TaskFilters = {},
    pageSize: number = 20,
    lastDoc?: any
  ): Promise<PaginatedResponse<Task>> {
    try {
      let q = query(collection(db, TASKS_COLLECTION))

      // Apply filters
      if (filters.workspaceId) {
        q = query(q, where('workspaceId', '==', filters.workspaceId))
      }
      if (filters.projectId) {
        q = query(q, where('projectId', '==', filters.projectId))
      }
      if (filters.assigneeId) {
        q = query(q, where('assigneeId', '==', filters.assigneeId))
      }
      if (filters.status) {
        q = query(q, where('status', '==', filters.status))
      }
      if (filters.priority) {
        q = query(q, where('priority', '==', filters.priority))
      }
      if (filters.isArchived !== undefined) {
        q = query(q, where('isArchived', '==', filters.isArchived))
      }

      // Order by creation date (newest first)
      q = query(q, orderBy('createdAt', 'desc'))

      // Pagination
      if (lastDoc) {
        q = query(q, startAfter(lastDoc))
      }
      q = query(q, limit(pageSize + 1)) // Get one extra to check if there are more

      const querySnapshot = await getDocs(q)
      const tasks: Task[] = []
      const docs = querySnapshot.docs

      docs.slice(0, pageSize).forEach((doc) => {
        const data = doc.data()
        tasks.push({
          id: doc.id,
          ...data,
          createdAt: data.createdAt?.toDate() || new Date(),
          updatedAt: data.updatedAt?.toDate() || new Date(),
          dueDate: data.dueDate?.toDate(),
          completedAt: data.completedAt?.toDate(),
        } as Task)
      })

      const hasNext = docs.length > pageSize
      const hasPrev = !!lastDoc

      return {
        items: tasks,
        total: tasks.length, // Note: Firestore doesn't provide total count efficiently
        page: 1, // We don't track page numbers with cursor pagination
        limit: pageSize,
        hasNext,
        hasPrev,
      }
    } catch (error) {
      throw new Error(handleFirebaseError(error))
    }
  }

  // Update task
  static async updateTask(taskId: string, updates: Partial<Task>): Promise<void> {
    try {
      const taskRef = doc(db, TASKS_COLLECTION, taskId)
      await updateDoc(taskRef, {
        ...updates,
        updatedAt: serverTimestamp(),
      })
    } catch (error) {
      throw new Error(handleFirebaseError(error))
    }
  }

  // Update task status
  static async updateTaskStatus(taskId: string, status: TaskStatus): Promise<void> {
    try {
      const taskRef = doc(db, TASKS_COLLECTION, taskId)
      const updates: any = {
        status,
        updatedAt: serverTimestamp(),
      }

      if (status === 'done') {
        updates.completedAt = serverTimestamp()
      }

      await updateDoc(taskRef, updates)
    } catch (error) {
      throw new Error(handleFirebaseError(error))
    }
  }

  // Delete task
  static async deleteTask(taskId: string): Promise<void> {
    try {
      const taskRef = doc(db, TASKS_COLLECTION, taskId)
      await deleteDoc(taskRef)
    } catch (error) {
      throw new Error(handleFirebaseError(error))
    }
  }

  // Archive/Unarchive task
  static async archiveTask(taskId: string, isArchived: boolean): Promise<void> {
    try {
      const taskRef = doc(db, TASKS_COLLECTION, taskId)
      await updateDoc(taskRef, {
        isArchived,
        updatedAt: serverTimestamp(),
      })
    } catch (error) {
      throw new Error(handleFirebaseError(error))
    }
  }

  // Add comment to task
  static async addComment(
    taskId: string,
    userId: string,
    content: string
  ): Promise<void> {
    try {
      const taskRef = doc(db, TASKS_COLLECTION, taskId)
      const task = await this.getTask(taskId)
      
      if (!task) throw new Error('Task not found')

      const newComment = {
        id: generateId(),
        content,
        authorId: userId,
        createdAt: new Date(),
        updatedAt: new Date(),
        isEdited: false,
        mentions: [], // TODO: Extract mentions from content
      }

      const updatedComments = [...task.comments, newComment]

      await updateDoc(taskRef, {
        comments: updatedComments,
        updatedAt: serverTimestamp(),
      })
    } catch (error) {
      throw new Error(handleFirebaseError(error))
    }
  }

  // Increment pomodoro count
  static async incrementPomodoroCount(taskId: string): Promise<void> {
    try {
      const taskRef = doc(db, TASKS_COLLECTION, taskId)
      const task = await this.getTask(taskId)
      
      if (!task) throw new Error('Task not found')

      await updateDoc(taskRef, {
        pomodoroCount: task.pomodoroCount + 1,
        updatedAt: serverTimestamp(),
      })
    } catch (error) {
      throw new Error(handleFirebaseError(error))
    }
  }

  // Bulk update tasks
  static async bulkUpdateTasks(
    updates: Array<{ id: string; data: Partial<Task> }>
  ): Promise<void> {
    try {
      const batch = writeBatch(db)

      updates.forEach(({ id, data }) => {
        const taskRef = doc(db, TASKS_COLLECTION, id)
        batch.update(taskRef, {
          ...data,
          updatedAt: serverTimestamp(),
        })
      })

      await batch.commit()
    } catch (error) {
      throw new Error(handleFirebaseError(error))
    }
  }

  // Get user's tasks statistics
  static async getTasksStats(userId: string, workspaceId?: string): Promise<{
    total: number
    completed: number
    inProgress: number
    overdue: number
  }> {
    try {
      const filters: TaskFilters = { isArchived: false }
      if (workspaceId) filters.workspaceId = workspaceId
      
      // Get user's assigned tasks
      const assignedTasks = await this.getTasks({ ...filters, assigneeId: userId }, 1000)
      
      // Get tasks created by user
      const createdQuery = query(
        collection(db, TASKS_COLLECTION),
        where('createdById', '==', userId),
        where('isArchived', '==', false)
      )
      const createdSnapshot = await getDocs(createdQuery)
      
      const allTasks = [
        ...assignedTasks.items,
        ...createdSnapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data(),
          createdAt: doc.data().createdAt?.toDate() || new Date(),
          updatedAt: doc.data().updatedAt?.toDate() || new Date(),
          dueDate: doc.data().dueDate?.toDate(),
          completedAt: doc.data().completedAt?.toDate(),
        } as Task))
      ]

      // Remove duplicates
      const uniqueTasks = allTasks.filter((task, index, self) => 
        index === self.findIndex(t => t.id === task.id)
      )

      const now = new Date()
      const stats = {
        total: uniqueTasks.length,
        completed: uniqueTasks.filter(task => task.status === 'done').length,
        inProgress: uniqueTasks.filter(task => task.status === 'in_progress').length,
        overdue: uniqueTasks.filter(task => 
          task.dueDate && task.dueDate < now && task.status !== 'done'
        ).length,
      }

      return stats
    } catch (error) {
      throw new Error(handleFirebaseError(error))
    }
  }
}


--- src/services/userService.ts ---

import {
  doc,
  getDoc,
  setDoc,
  updateDoc,
  deleteDoc,
  serverTimestamp,
} from 'firebase/firestore'
import { db } from '@/lib/firebase'
import { User, UserPreferences } from '@/types'
import { handleFirebaseError } from './firebase'

const USERS_COLLECTION = 'users'

export class UserService {
  // Create a new user document
  static async createUser(userId: string, userData: Partial<User>): Promise<void> {
    try {
      const userRef = doc(db, USERS_COLLECTION, userId)
      
      const defaultPreferences: UserPreferences = {
        theme: 'system',
        language: 'ru',
        timezone: 'Europe/Moscow',
        notifications: {
          email: true,
          push: true,
          desktop: true,
          taskReminders: true,
          pomodoroBreaks: true,
          achievements: true,
          weeklyReports: true,
        },
        pomodoro: {
          workDuration: 25,
          shortBreakDuration: 5,
          longBreakDuration: 15,
          longBreakInterval: 4,
          autoStartBreaks: false,
          autoStartPomodoros: false,
          soundEnabled: true,
          soundVolume: 50,
        },
        gamification: {
          showBadges: true,
          showLevel: true,
          showXP: true,
          showStreak: true,
          gardenEnabled: true,
          soundEffects: true,
        },
      }

      const user: User = {
        id: userId,
        email: userData.email || '',
        displayName: userData.displayName || '',
        photoURL: userData.photoURL,
        role: 'free',
        createdAt: new Date(),
        updatedAt: new Date(),
        preferences: defaultPreferences,
        achievements: [],
        level: 1,
        xp: 0,
        streakCount: 0,
        totalTasksCompleted: 0,
        totalPomodoroCompleted: 0,
        ...userData,
      }

      await setDoc(userRef, {
        ...user,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
      })
    } catch (error) {
      throw new Error(handleFirebaseError(error))
    }
  }

  // Get user by ID
  static async getUser(userId: string): Promise<User | null> {
    try {
      const userRef = doc(db, USERS_COLLECTION, userId)
      const userSnap = await getDoc(userRef)
      
      if (userSnap.exists()) {
        const data = userSnap.data()
        return {
          ...data,
          createdAt: data.createdAt?.toDate() || new Date(),
          updatedAt: data.updatedAt?.toDate() || new Date(),
        } as User
      }
      
      return null
    } catch (error) {
      throw new Error(handleFirebaseError(error))
    }
  }

  // Update user
  static async updateUser(userId: string, updates: Partial<User>): Promise<void> {
    try {
      const userRef = doc(db, USERS_COLLECTION, userId)
      await updateDoc(userRef, {
        ...updates,
        updatedAt: serverTimestamp(),
      })
    } catch (error) {
      throw new Error(handleFirebaseError(error))
    }
  }

  // Update user preferences
  static async updateUserPreferences(
    userId: string,
    preferences: Partial<UserPreferences>
  ): Promise<void> {
    try {
      const userRef = doc(db, USERS_COLLECTION, userId)
      await updateDoc(userRef, {
        preferences,
        updatedAt: serverTimestamp(),
      })
    } catch (error) {
      throw new Error(handleFirebaseError(error))
    }
  }

  // Add XP to user
  static async addXP(userId: string, xpAmount: number): Promise<void> {
    try {
      const userRef = doc(db, USERS_COLLECTION, userId)
      const userSnap = await getDoc(userRef)
      
      if (userSnap.exists()) {
        const userData = userSnap.data() as User
        const newXP = userData.xp + xpAmount
        const newLevel = this.calculateLevel(newXP)
        
        await updateDoc(userRef, {
          xp: newXP,
          level: newLevel,
          updatedAt: serverTimestamp(),
        })
      }
    } catch (error) {
      throw new Error(handleFirebaseError(error))
    }
  }

  // Update streak count
  static async updateStreak(userId: string, streakCount: number): Promise<void> {
    try {
      const userRef = doc(db, USERS_COLLECTION, userId)
      await updateDoc(userRef, {
        streakCount,
        updatedAt: serverTimestamp(),
      })
    } catch (error) {
      throw new Error(handleFirebaseError(error))
    }
  }

  // Increment task completion count
  static async incrementTaskCount(userId: string): Promise<void> {
    try {
      const userRef = doc(db, USERS_COLLECTION, userId)
      const userSnap = await getDoc(userRef)
      
      if (userSnap.exists()) {
        const userData = userSnap.data() as User
        await updateDoc(userRef, {
          totalTasksCompleted: userData.totalTasksCompleted + 1,
          updatedAt: serverTimestamp(),
        })
      }
    } catch (error) {
      throw new Error(handleFirebaseError(error))
    }
  }

  // Increment pomodoro completion count
  static async incrementPomodoroCount(userId: string): Promise<void> {
    try {
      const userRef = doc(db, USERS_COLLECTION, userId)
      const userSnap = await getDoc(userRef)
      
      if (userSnap.exists()) {
        const userData = userSnap.data() as User
        await updateDoc(userRef, {
          totalPomodoroCompleted: userData.totalPomodoroCompleted + 1,
          updatedAt: serverTimestamp(),
        })
      }
    } catch (error) {
      throw new Error(handleFirebaseError(error))
    }
  }

  // Delete user
  static async deleteUser(userId: string): Promise<void> {
    try {
      const userRef = doc(db, USERS_COLLECTION, userId)
      await deleteDoc(userRef)
    } catch (error) {
      throw new Error(handleFirebaseError(error))
    }
  }

  // Helper method to calculate level from XP
  private static calculateLevel(xp: number): number {
    const baseXP = 100
    const multiplier = 1.5
    let level = 1
    let requiredXP = 0
    
    while (requiredXP <= xp) {
      level++
      requiredXP += Math.floor(baseXP * Math.pow(multiplier, level - 2))
    }
    
    return level - 1
  }
}


--- src/services/workspaceService.ts ---

import { 
  getFunctions, 
  httpsCallable, 
  connectFunctionsEmulator 
} from 'firebase/functions'
import { getAuth } from 'firebase/auth'

// Типы для workspace API
export interface CreateWorkspacePayload {
  name: string
  description?: string | null
  isPersonal: boolean
  teamId?: string | null
  activeApproach?: string
  defaultTags?: string[]
  settings?: { [key: string]: any }
}

export interface UpdateWorkspacePayload {
  workspaceId: string
  name?: string
  description?: string | null
  activeApproach?: string
  defaultTags?: string[]
  settings?: { [key: string]: any }
}

export interface WorkspaceClientDto {
  id: string
  name: string
  description: string | null
  ownerUid: string
  isPersonal: boolean
  teamId: string | null
  createdAt: string
  updatedAt: string
  activeApproach: string
  defaultTags: string[]
  settings: { [key: string]: any }
  currentUserWorkspaceRole?: 'owner' | 'admin' | 'manager' | 'editor' | 'member' | 'viewer' | null
}

export interface CreateWorkspaceResponse {
  workspace: WorkspaceClientDto
}

export interface GetUserWorkspacesResponse {
  workspaces: WorkspaceClientDto[]
}

export interface GetWorkspaceDetailsResponse {
  workspace: WorkspaceClientDto
}

export interface UpdateWorkspaceResponse {
  success: boolean
  updatedWorkspace: WorkspaceClientDto
}

export interface DeleteWorkspaceResponse {
  success: boolean
  message: string
}

class WorkspaceService {
  private functions = getFunctions()
  private isEmulatorConnected = false
  
  constructor() {
    // Подключение к эмулятору в режиме разработки
    if (import.meta.env.DEV && import.meta.env.VITE_USE_FIREBASE_EMULATORS === 'true') {
      try {
        if (!this.isEmulatorConnected) {
          connectFunctionsEmulator(this.functions, 'localhost', 5001)
          this.isEmulatorConnected = true
          console.log('✅ Functions emulator connected')
        }
      } catch (error) {
        console.warn('⚠️ Functions emulator connection failed:', error)
        console.warn('Make sure Firebase emulator is running: firebase emulators:start')
      }
    }
  }

  /**
   * Создание нового рабочего пространства
   */
  async createWorkspace(payload: CreateWorkspacePayload): Promise<CreateWorkspaceResponse> {
    try {
      const auth = getAuth()
      if (!auth.currentUser) {
        throw new Error('Пользователь не авторизован')
      }

      const createWorkspaceFunction = httpsCallable<CreateWorkspacePayload, CreateWorkspaceResponse>(
        this.functions,
        'createWorkspace'
      )

      const result = await createWorkspaceFunction(payload)
      return result.data
    } catch (error: any) {
      console.error('Ошибка создания рабочего пространства:', error)
      throw new Error(error.message || 'Не удалось создать рабочее пространство')
    }
  }

  /**
   * Получение списка рабочих пространств пользователя
   */
  async getUserWorkspaces(): Promise<GetUserWorkspacesResponse> {
    try {
      const auth = getAuth()
      if (!auth.currentUser) {
        throw new Error('Пользователь не авторизован')
      }

      const getUserWorkspacesFunction = httpsCallable<void, GetUserWorkspacesResponse>(
        this.functions,
        'getUserWorkspaces'
      )

      const result = await getUserWorkspacesFunction()
      return result.data
    } catch (error: any) {
      console.error('Ошибка получения рабочих пространств:', error)
      throw new Error(error.message || 'Не удалось загрузить рабочие пространства')
    }
  }

  /**
   * Получение деталей рабочего пространства
   */
  async getWorkspaceDetails(workspaceId: string): Promise<GetWorkspaceDetailsResponse> {
    try {
      const auth = getAuth()
      if (!auth.currentUser) {
        throw new Error('Пользователь не авторизован')
      }

      const getWorkspaceDetailsFunction = httpsCallable<
        { workspaceId: string },
        GetWorkspaceDetailsResponse
      >(this.functions, 'getWorkspaceDetails')

      const result = await getWorkspaceDetailsFunction({ workspaceId })
      return result.data
    } catch (error: any) {
      console.error('Ошибка получения деталей рабочего пространства:', error)
      throw new Error(error.message || 'Не удалось загрузить детали рабочего пространства')
    }
  }

  /**
   * Обновление рабочего пространства
   */
  async updateWorkspace(payload: UpdateWorkspacePayload): Promise<UpdateWorkspaceResponse> {
    try {
      const auth = getAuth()
      if (!auth.currentUser) {
        throw new Error('Пользователь не авторизован')
      }

      const updateWorkspaceFunction = httpsCallable<UpdateWorkspacePayload, UpdateWorkspaceResponse>(
        this.functions,
        'updateWorkspace'
      )

      const result = await updateWorkspaceFunction(payload)
      return result.data
    } catch (error: any) {
      console.error('Ошибка обновления рабочего пространства:', error)
      throw new Error(error.message || 'Не удалось обновить рабочее пространство')
    }
  }

  /**
   * Удаление рабочего пространства
   */
  async deleteWorkspace(workspaceId: string): Promise<DeleteWorkspaceResponse> {
    try {
      const auth = getAuth()
      if (!auth.currentUser) {
        throw new Error('Пользователь не авторизован')
      }

      const deleteWorkspaceFunction = httpsCallable<
        { workspaceId: string },
        DeleteWorkspaceResponse
      >(this.functions, 'deleteWorkspace')

      const result = await deleteWorkspaceFunction({ workspaceId })
      return result.data
    } catch (error: any) {
      console.error('Ошибка удаления рабочего пространства:', error)
      throw new Error(error.message || 'Не удалось удалить рабочее пространство')
    }
  }
}

// Экспортируем единственный экземпляр сервиса
export const workspaceService = new WorkspaceService()
export default workspaceService


--- src/stores/appStore.ts ---

import { create } from 'zustand'
import { devtools, persist } from 'zustand/middleware'
import { immer } from 'zustand/middleware/immer'
import { User, Workspace, Project } from '@/types'
import { WorkspaceClientDto } from '@/services/workspaceService'

interface AppState {
  // User state
  currentUser: User | null
  
  // Current workspace and project
  currentWorkspace: Workspace | null
  currentProject: Project | null
  
  // UI state
  sidebarOpen: boolean
  theme: 'light' | 'dark' | 'system'
  
  // Loading states
  isLoading: boolean
  isInitializing: boolean
  
  // Error state
  error: string | null
  
  // Actions
  setCurrentUser: (user: User | null) => void
  setCurrentWorkspace: (workspace: Workspace | null) => void
  setCurrentProject: (project: Project | null) => void
  setSidebarOpen: (open: boolean) => void
  setTheme: (theme: 'light' | 'dark' | 'system') => void
  setLoading: (loading: boolean) => void
  setInitializing: (initializing: boolean) => void
  setError: (error: string | null) => void
  clearError: () => void
  reset: () => void
}

const initialState = {
  currentUser: null,
  currentWorkspace: null,
  currentProject: null,
  sidebarOpen: true,
  theme: 'system' as const,
  isLoading: false,
  isInitializing: true,
  error: null,
}

export const useAppStore = create<AppState>()(
  devtools(
    persist(
      immer((set) => ({
        ...initialState,

        setCurrentUser: (user) =>
          set((state) => {
            state.currentUser = user
          }),

        setCurrentWorkspace: (workspace) =>
          set((state) => {
            state.currentWorkspace = workspace
          }),

        setCurrentProject: (project) =>
          set((state) => {
            state.currentProject = project
          }),

        setSidebarOpen: (open) =>
          set((state) => {
            state.sidebarOpen = open
          }),

        setTheme: (theme) =>
          set((state) => {
            state.theme = theme
          }),

        setLoading: (loading) =>
          set((state) => {
            state.isLoading = loading
          }),

        setInitializing: (initializing) =>
          set((state) => {
            state.isInitializing = initializing
          }),

        setError: (error) =>
          set((state) => {
            state.error = error
          }),

        clearError: () =>
          set((state) => {
            state.error = null
          }),

        reset: () =>
          set((state) => {
            Object.assign(state, initialState)
          }),
      })),
      {
        name: 'app-store',
        partialize: (state) => ({
          sidebarOpen: state.sidebarOpen,
          theme: state.theme,
          currentWorkspace: state.currentWorkspace,
          currentProject: state.currentProject,
        }),
      }
    ),
    {
      name: 'app-store',
    }
  )
)


--- src/stores/pomodoroStore.ts ---

import { create } from 'zustand'
import { devtools } from 'zustand/middleware'
import { immer } from 'zustand/middleware/immer'
import { PomodoroSession, PomodoroSettings } from '@/types'
import { POMODORO } from '@/constants'

type PomodoroStatus = 'idle' | 'running' | 'paused' | 'completed'
type SessionType = 'work' | 'short_break' | 'long_break'

interface PomodoroState {
  // Timer state
  timeRemaining: number
  totalTime: number
  status: PomodoroStatus
  sessionType: SessionType
  currentSession: PomodoroSession | null
  
  // Session tracking
  completedPomodoros: number
  dailyGoal: number
  
  // Settings
  settings: PomodoroSettings
  
  // Current task
  currentTaskId: string | null
  
  // Actions
  startTimer: (taskId?: string) => void
  pauseTimer: () => void
  resumeTimer: () => void
  stopTimer: () => void
  completeSession: () => void
  skipSession: () => void
  resetTimer: () => void
  setTimeRemaining: (time: number) => void
  setSettings: (settings: Partial<PomodoroSettings>) => void
  setDailyGoal: (goal: number) => void
  setCurrentTask: (taskId: string | null) => void
  tick: () => void
}

const defaultSettings: PomodoroSettings = {
  workDuration: POMODORO.DEFAULT_WORK_DURATION / 60, // Convert to minutes
  shortBreakDuration: POMODORO.DEFAULT_SHORT_BREAK / 60,
  longBreakDuration: POMODORO.DEFAULT_LONG_BREAK / 60,
  longBreakInterval: POMODORO.DEFAULT_LONG_BREAK_INTERVAL,
  autoStartBreaks: false,
  autoStartPomodoros: false,
  soundEnabled: true,
  soundVolume: 50,
}

const initialState = {
  timeRemaining: defaultSettings.workDuration * 60,
  totalTime: defaultSettings.workDuration * 60,
  status: 'idle' as PomodoroStatus,
  sessionType: 'work' as SessionType,
  currentSession: null,
  completedPomodoros: 0,
  dailyGoal: 8,
  settings: defaultSettings,
  currentTaskId: null,
}

export const usePomodoroStore = create<PomodoroState>()(
  devtools(
    immer((set) => ({
      ...initialState,

      startTimer: (taskId) =>
        set((state) => {
          const { settings, sessionType } = state
          let duration: number

          switch (sessionType) {
            case 'work':
              duration = settings.workDuration * 60
              break
            case 'short_break':
              duration = settings.shortBreakDuration * 60
              break
            case 'long_break':
              duration = settings.longBreakDuration * 60
              break
          }

          state.status = 'running'
          state.timeRemaining = duration
          state.totalTime = duration
          state.currentTaskId = taskId || null
          
          // Create new session
          state.currentSession = {
            id: Date.now().toString(),
            taskId: taskId,
            workspaceId: '', // TODO: Get from current workspace
            userId: '', // TODO: Get from current user
            type: sessionType,
            duration,
            startTime: new Date(),
            isCompleted: false,
            isPaused: false,
            pausedDuration: 0,
            tags: [],
          }
        }),

      pauseTimer: () =>
        set((state) => {
          if (state.status === 'running') {
            state.status = 'paused'
            if (state.currentSession) {
              state.currentSession.isPaused = true
            }
          }
        }),

      resumeTimer: () =>
        set((state) => {
          if (state.status === 'paused') {
            state.status = 'running'
            if (state.currentSession) {
              state.currentSession.isPaused = false
            }
          }
        }),

      stopTimer: () =>
        set((state) => {
          state.status = 'idle'
          state.timeRemaining = state.totalTime
          state.currentSession = null
          state.currentTaskId = null
        }),

      completeSession: () =>
        set((state) => {
          if (state.currentSession) {
            state.currentSession.isCompleted = true
            state.currentSession.endTime = new Date()
          }

          if (state.sessionType === 'work') {
            state.completedPomodoros += 1
            
            // Determine next session type
            const isLongBreakTime = 
              state.completedPomodoros % state.settings.longBreakInterval === 0
            
            state.sessionType = isLongBreakTime ? 'long_break' : 'short_break'
          } else {
            state.sessionType = 'work'
          }

          state.status = 'completed'
          state.timeRemaining = 0
        }),

      skipSession: () =>
        set((state) => {
          if (state.sessionType === 'work') {
            const isLongBreakTime = 
              (state.completedPomodoros + 1) % state.settings.longBreakInterval === 0
            state.sessionType = isLongBreakTime ? 'long_break' : 'short_break'
          } else {
            state.sessionType = 'work'
          }

          state.status = 'idle'
          state.currentSession = null
          state.currentTaskId = null
        }),

      resetTimer: () =>
        set((state) => {
          Object.assign(state, initialState)
        }),

      setTimeRemaining: (time) =>
        set((state) => {
          state.timeRemaining = time
        }),

      setSettings: (newSettings) =>
        set((state) => {
          state.settings = { ...state.settings, ...newSettings }
          
          // Update timer if idle and session type matches
          if (state.status === 'idle') {
            switch (state.sessionType) {
              case 'work':
                state.timeRemaining = state.settings.workDuration * 60
                state.totalTime = state.settings.workDuration * 60
                break
              case 'short_break':
                state.timeRemaining = state.settings.shortBreakDuration * 60
                state.totalTime = state.settings.shortBreakDuration * 60
                break
              case 'long_break':
                state.timeRemaining = state.settings.longBreakDuration * 60
                state.totalTime = state.settings.longBreakDuration * 60
                break
            }
          }
        }),

      setDailyGoal: (goal) =>
        set((state) => {
          state.dailyGoal = goal
        }),

      setCurrentTask: (taskId) =>
        set((state) => {
          state.currentTaskId = taskId
        }),

      tick: () =>
        set((state) => {
          if (state.status === 'running' && state.timeRemaining > 0) {
            state.timeRemaining -= 1
            
            if (state.timeRemaining === 0) {
              // Auto-complete session
              if (state.currentSession) {
                state.currentSession.isCompleted = true
                state.currentSession.endTime = new Date()
              }

              if (state.sessionType === 'work') {
                state.completedPomodoros += 1
                
                const isLongBreakTime = 
                  state.completedPomodoros % state.settings.longBreakInterval === 0
                
                state.sessionType = isLongBreakTime ? 'long_break' : 'short_break'
              } else {
                state.sessionType = 'work'
              }

              state.status = 'completed'
            }
          }
        }),
    })),
    {
      name: 'pomodoro-store',
    }
  )
)


--- src/stores/workspaceStore.ts ---

import { create } from 'zustand'
import { devtools, persist } from 'zustand/middleware'
import { immer } from 'zustand/middleware/immer'
import { WorkspaceClientDto } from '@/services/workspaceService'

interface WorkspaceState {
  // Текущее активное рабочее пространство
  currentWorkspace: WorkspaceClientDto | null
  
  // Список всех рабочих пространств пользователя
  workspaces: WorkspaceClientDto[]
  
  // Состояния загрузки
  isLoading: boolean
  isCreating: boolean
  isUpdating: boolean
  isDeleting: boolean
  
  // Состояние ошибок
  error: string | null
  
  // Настройки отображения
  viewMode: 'grid' | 'list'
  showPersonalOnly: boolean
  showTeamOnly: boolean
  
  // Поиск и фильтрация
  searchQuery: string
  selectedTags: string[]
  sortBy: 'name' | 'created' | 'updated'
  sortOrder: 'asc' | 'desc'
  
  // Actions
  setCurrentWorkspace: (workspace: WorkspaceClientDto | null) => void
  setWorkspaces: (workspaces: WorkspaceClientDto[]) => void
  addWorkspace: (workspace: WorkspaceClientDto) => void
  updateWorkspace: (workspaceId: string, updates: Partial<WorkspaceClientDto>) => void
  removeWorkspace: (workspaceId: string) => void
  
  // Loading states
  setLoading: (loading: boolean) => void
  setCreating: (creating: boolean) => void
  setUpdating: (updating: boolean) => void
  setDeleting: (deleting: boolean) => void
  
  // Error handling
  setError: (error: string | null) => void
  clearError: () => void
  
  // View settings
  setViewMode: (mode: 'grid' | 'list') => void
  setShowPersonalOnly: (show: boolean) => void
  setShowTeamOnly: (show: boolean) => void
  
  // Search and filtering
  setSearchQuery: (query: string) => void
  setSelectedTags: (tags: string[]) => void
  toggleTag: (tag: string) => void
  setSortBy: (sortBy: 'name' | 'created' | 'updated') => void
  setSortOrder: (order: 'asc' | 'desc') => void
  
  // Computed selectors
  getFilteredWorkspaces: () => WorkspaceClientDto[]
  getPersonalWorkspaces: () => WorkspaceClientDto[]
  getTeamWorkspaces: () => WorkspaceClientDto[]
  getWorkspaceById: (id: string) => WorkspaceClientDto | undefined
  getAllTags: () => string[]
  
  // Utility actions
  reset: () => void
  clearFilters: () => void
}

const initialState = {
  currentWorkspace: null,
  workspaces: [],
  isLoading: false,
  isCreating: false,
  isUpdating: false,
  isDeleting: false,
  error: null,
  viewMode: 'grid' as const,
  showPersonalOnly: false,
  showTeamOnly: false,
  searchQuery: '',
  selectedTags: [],
  sortBy: 'updated' as const,
  sortOrder: 'desc' as const,
}

export const useWorkspaceStore = create<WorkspaceState>()(
  devtools(
    persist(
      immer((set, get) => ({
        ...initialState,

        // Workspace management
        setCurrentWorkspace: (workspace) =>
          set((state) => {
            state.currentWorkspace = workspace
          }),

        setWorkspaces: (workspaces) =>
          set((state) => {
            state.workspaces = workspaces
          }),

        addWorkspace: (workspace) =>
          set((state) => {
            state.workspaces.unshift(workspace)
          }),

        updateWorkspace: (workspaceId, updates) =>
          set((state) => {
            const index = state.workspaces.findIndex(ws => ws.id === workspaceId)
            if (index !== -1) {
              Object.assign(state.workspaces[index], updates)
            }
            
            // Обновляем текущее рабочее пространство если оно совпадает
            if (state.currentWorkspace?.id === workspaceId) {
              Object.assign(state.currentWorkspace, updates)
            }
          }),

        removeWorkspace: (workspaceId) =>
          set((state) => {
            state.workspaces = state.workspaces.filter(ws => ws.id !== workspaceId)
            
            // Сбрасываем текущее рабочее пространство если оно было удалено
            if (state.currentWorkspace?.id === workspaceId) {
              state.currentWorkspace = null
            }
          }),

        // Loading states
        setLoading: (loading) =>
          set((state) => {
            state.isLoading = loading
          }),

        setCreating: (creating) =>
          set((state) => {
            state.isCreating = creating
          }),

        setUpdating: (updating) =>
          set((state) => {
            state.isUpdating = updating
          }),

        setDeleting: (deleting) =>
          set((state) => {
            state.isDeleting = deleting
          }),

        // Error handling
        setError: (error) =>
          set((state) => {
            state.error = error
          }),

        clearError: () =>
          set((state) => {
            state.error = null
          }),

        // View settings
        setViewMode: (mode) =>
          set((state) => {
            state.viewMode = mode
          }),

        setShowPersonalOnly: (show) =>
          set((state) => {
            state.showPersonalOnly = show
            if (show) state.showTeamOnly = false
          }),

        setShowTeamOnly: (show) =>
          set((state) => {
            state.showTeamOnly = show
            if (show) state.showPersonalOnly = false
          }),

        // Search and filtering
        setSearchQuery: (query) =>
          set((state) => {
            state.searchQuery = query
          }),

        setSelectedTags: (tags) =>
          set((state) => {
            state.selectedTags = tags
          }),

        toggleTag: (tag) =>
          set((state) => {
            const index = state.selectedTags.indexOf(tag)
            if (index === -1) {
              state.selectedTags.push(tag)
            } else {
              state.selectedTags.splice(index, 1)
            }
          }),

        setSortBy: (sortBy) =>
          set((state) => {
            state.sortBy = sortBy
          }),

        setSortOrder: (order) =>
          set((state) => {
            state.sortOrder = order
          }),

        // Computed selectors
        getFilteredWorkspaces: () => {
          const state = get()
          let filtered = [...state.workspaces]

          // Фильтрация по типу
          if (state.showPersonalOnly) {
            filtered = filtered.filter(ws => ws.isPersonal)
          } else if (state.showTeamOnly) {
            filtered = filtered.filter(ws => !ws.isPersonal)
          }

          // Поиск по названию и описанию
          if (state.searchQuery) {
            const query = state.searchQuery.toLowerCase()
            filtered = filtered.filter(ws =>
              ws.name.toLowerCase().includes(query) ||
              ws.description?.toLowerCase().includes(query)
            )
          }

          // Фильтрация по тегам
          if (state.selectedTags.length > 0) {
            filtered = filtered.filter(ws =>
              state.selectedTags.some(tag =>
                ws.defaultTags.includes(tag)
              )
            )
          }

          // Сортировка
          filtered.sort((a, b) => {
            let aValue: string | Date
            let bValue: string | Date

            switch (state.sortBy) {
              case 'name':
                aValue = a.name
                bValue = b.name
                break
              case 'created':
                aValue = new Date(a.createdAt)
                bValue = new Date(b.createdAt)
                break
              case 'updated':
                aValue = new Date(a.updatedAt)
                bValue = new Date(b.updatedAt)
                break
              default:
                return 0
            }

            if (state.sortOrder === 'asc') {
              return aValue < bValue ? -1 : aValue > bValue ? 1 : 0
            } else {
              return aValue > bValue ? -1 : aValue < bValue ? 1 : 0
            }
          })

          return filtered
        },

        getPersonalWorkspaces: () => {
          return get().workspaces.filter(ws => ws.isPersonal)
        },

        getTeamWorkspaces: () => {
          return get().workspaces.filter(ws => !ws.isPersonal)
        },

        getWorkspaceById: (id) => {
          return get().workspaces.find(ws => ws.id === id)
        },

        getAllTags: () => {
          const allTags = get().workspaces.flatMap(ws => ws.defaultTags)
          return [...new Set(allTags)].sort()
        },

        // Utility actions
        reset: () =>
          set((state) => {
            Object.assign(state, initialState)
          }),

        clearFilters: () =>
          set((state) => {
            state.searchQuery = ''
            state.selectedTags = []
            state.showPersonalOnly = false
            state.showTeamOnly = false
          }),
      })),
      {
        name: 'workspace-store',
        partialize: (state) => ({
          currentWorkspace: state.currentWorkspace,
          viewMode: state.viewMode,
          sortBy: state.sortBy,
          sortOrder: state.sortOrder,
        }),
      }
    ),
    {
      name: 'workspace-store',
    }
  )
)


--- src/types/index.ts ---

// Пользователь
export interface User {
  id: string
  email: string
  displayName: string
  photoURL?: string
  role: 'free' | 'premium' | 'admin'
  createdAt: Date
  updatedAt: Date
  preferences: UserPreferences
  achievements: string[]
  level: number
  xp: number
  streakCount: number
  totalTasksCompleted: number
  totalPomodoroCompleted: number
}

export interface UserPreferences {
  theme: 'light' | 'dark' | 'system'
  language: string
  timezone: string
  notifications: NotificationSettings
  pomodoro: PomodoroSettings
  gamification: GamificationSettings
}

export interface NotificationSettings {
  email: boolean
  push: boolean
  desktop: boolean
  taskReminders: boolean
  pomodoroBreaks: boolean
  achievements: boolean
  weeklyReports: boolean
}

export interface PomodoroSettings {
  workDuration: number // в минутах
  shortBreakDuration: number
  longBreakDuration: number
  longBreakInterval: number // после скольких циклов
  autoStartBreaks: boolean
  autoStartPomodoros: boolean
  soundEnabled: boolean
  soundVolume: number
}

export interface GamificationSettings {
  showBadges: boolean
  showLevel: boolean
  showXP: boolean
  showStreak: boolean
  gardenEnabled: boolean
  soundEffects: boolean
}

// Рабочие пространства
export interface Workspace {
  id: string
  name: string
  description?: string
  ownerId: string
  type: 'personal' | 'team'
  members: WorkspaceMember[]
  createdAt: Date
  updatedAt: Date
  settings: WorkspaceSettings
  isArchived: boolean
}

export interface WorkspaceMember {
  userId: string
  email: string
  displayName: string
  role: 'owner' | 'admin' | 'member' | 'viewer'
  joinedAt: Date
  permissions: Permission[]
}

export interface Permission {
  resource: 'tasks' | 'projects' | 'members' | 'settings'
  actions: ('create' | 'read' | 'update' | 'delete')[]
}

export interface WorkspaceSettings {
  isPublic: boolean
  allowMemberInvites: boolean
  defaultTaskView: 'list' | 'kanban' | 'calendar' | 'timeline'
  workingHours: {
    start: string // HH:mm
    end: string // HH:mm
    workDays: number[] // 0-6, 0 = воскресенье
  }
  timezone: string
}

// Проекты
export interface Project {
  id: string
  name: string
  description?: string
  color: string
  icon?: string
  workspaceId: string
  ownerId: string
  isArchived: boolean
  createdAt: Date
  updatedAt: Date
  settings: ProjectSettings
  stats: ProjectStats
}

export interface ProjectSettings {
  isPublic: boolean
  defaultAssignee?: string
  template?: TaskTemplate
  autoArchive: boolean
  autoArchiveDays: number
}

export interface ProjectStats {
  totalTasks: number
  completedTasks: number
  activeTasks: number
  overdueTasks: number
  totalTimeSpent: number // в минутах
}

export interface TaskTemplate {
  title: string
  description?: string
  priority: TaskPriority
  estimatedDuration?: number
  tags: string[]
  subtasks: Omit<TaskTemplate, 'subtasks'>[]
}

// Задачи
export interface Task {
  id: string
  title: string
  description?: string
  projectId?: string
  workspaceId: string
  assigneeId?: string
  createdById: string
  parentId?: string // для подзадач
  status: TaskStatus
  priority: TaskPriority
  tags: string[]
  dueDate?: Date
  createdAt: Date
  updatedAt: Date
  completedAt?: Date
  estimatedDuration?: number // в минутах
  actualDuration?: number // в минутах
  pomodoroCount: number
  attachments: TaskAttachment[]
  comments: TaskComment[]
  dependencies: TaskDependency[]
  customFields: Record<string, any>
  isArchived: boolean
}

export type TaskStatus = 'todo' | 'in_progress' | 'review' | 'done' | 'cancelled'
export type TaskPriority = 'low' | 'medium' | 'high' | 'urgent'

export interface TaskAttachment {
  id: string
  name: string
  url: string
  type: string
  size: number
  uploadedAt: Date
  uploadedBy: string
}

export interface TaskComment {
  id: string
  content: string
  authorId: string
  createdAt: Date
  updatedAt: Date
  isEdited: boolean
  mentions: string[]
}

export interface TaskDependency {
  id: string
  type: 'blocks' | 'blocked_by'
  taskId: string
}

// Пользовательские представления
export interface CustomView {
  id: string
  name: string
  description?: string
  workspaceId: string
  createdById: string
  type: 'list' | 'kanban' | 'calendar' | 'timeline' | 'analytics'
  filters: ViewFilter[]
  sorting: ViewSorting[]
  grouping?: ViewGrouping
  settings: ViewSettings
  isShared: boolean
  createdAt: Date
  updatedAt: Date
}

export interface ViewFilter {
  field: string
  operator: 'equals' | 'not_equals' | 'contains' | 'not_contains' | 'greater_than' | 'less_than' | 'in' | 'not_in' | 'is_empty' | 'is_not_empty'
  value: any
  logic?: 'and' | 'or'
}

export interface ViewSorting {
  field: string
  direction: 'asc' | 'desc'
}

export interface ViewGrouping {
  field: string
  showEmptyGroups: boolean
}

export interface ViewSettings {
  columns?: string[] // для списочного представления
  showSubtasks: boolean
  showCompleted: boolean
  showArchived: boolean
  colorBy?: string
  density: 'compact' | 'normal' | 'comfortable'
}

// Pomodoro
export interface PomodoroSession {
  id: string
  taskId?: string
  workspaceId: string
  userId: string
  type: 'work' | 'short_break' | 'long_break'
  duration: number // в секундах
  startTime: Date
  endTime?: Date
  isCompleted: boolean
  isPaused: boolean
  pausedDuration: number // в секундах
  tags: string[]
  notes?: string
}

// Достижения и геймификация
export interface Achievement {
  id: string
  name: string
  description: string
  icon: string
  category: 'tasks' | 'pomodoro' | 'streak' | 'social' | 'garden'
  type: 'single' | 'progressive'
  requirements: AchievementRequirement[]
  rewards: AchievementReward[]
  isSecret: boolean
}

export interface AchievementRequirement {
  type: 'task_count' | 'pomodoro_count' | 'streak_days' | 'level_reached' | 'custom'
  value: number
  timeframe?: 'daily' | 'weekly' | 'monthly' | 'all_time'
}

export interface AchievementReward {
  type: 'xp' | 'badge' | 'garden_item' | 'custom'
  value: number | string
}

export interface UserAchievement {
  achievementId: string
  userId: string
  unlockedAt: Date
  progress: number // 0-100
}

// Сад
export interface GardenPlant {
  id: string
  name: string
  description: string
  icon: string
  rarity: 'common' | 'rare' | 'epic' | 'legendary'
  unlockRequirements: AchievementRequirement[]
  growthStages: GrowthStage[]
}

export interface GrowthStage {
  name: string
  icon: string
  requiredXP: number
  duration: number // в часах
}

export interface UserGardenPlant {
  id: string
  userId: string
  plantId: string
  plantedAt: Date
  currentStage: number
  currentXP: number
  position: { x: number; y: number }
  isWatered: boolean
  lastWateredAt?: Date
}

// Уведомления
export interface Notification {
  id: string
  userId: string
  type: 'task_reminder' | 'pomodoro_break' | 'achievement' | 'invitation' | 'mention' | 'system'
  title: string
  message: string
  data?: Record<string, any>
  isRead: boolean
  createdAt: Date
  scheduledFor?: Date
}

// Аналитика
export interface AnalyticsData {
  period: 'day' | 'week' | 'month' | 'year'
  startDate: Date
  endDate: Date
  metrics: {
    tasksCompleted: number
    tasksCreated: number
    pomodoroSessions: number
    timeSpent: number // в минутах
    productivity: number // 0-100
    streakDays: number
    xpGained: number
  }
  charts: {
    tasksPerDay: { date: string; count: number }[]
    pomodoroPerDay: { date: string; count: number; duration: number }[]
    productivityTrend: { date: string; score: number }[]
    categoryBreakdown: { category: string; count: number; percentage: number }[]
  }
}

// API Response типы
export interface ApiResponse<T = any> {
  success: boolean
  data?: T
  error?: string
  message?: string
}

export interface PaginatedResponse<T = any> {
  items: T[]
  total: number
  page: number
  limit: number
  hasNext: boolean
  hasPrev: boolean
}

// Формы
export interface LoginForm {
  email: string
  password: string
  rememberMe: boolean
}

export interface RegisterForm {
  email: string
  password: string
  confirmPassword: string
  displayName: string
  acceptTerms: boolean
}

export interface TaskForm {
  title: string
  description?: string
  projectId?: string
  assigneeId?: string
  priority: TaskPriority
  tags: string[]
  dueDate?: Date
  estimatedDuration?: number
}

export interface ProjectForm {
  name: string
  description?: string
  color: string
  icon?: string
  isPublic: boolean
}

export interface WorkspaceForm {
  name: string
  description?: string
  type: 'personal' | 'team'
  isPublic: boolean
}

// Константы
export const TASK_PRIORITIES: Record<TaskPriority, { label: string; color: string; icon: string }> = {
  low: { label: 'Низкий', color: 'text-green-600', icon: '🔵' },
  medium: { label: 'Средний', color: 'text-yellow-600', icon: '🟡' },
  high: { label: 'Высокий', color: 'text-orange-600', icon: '🟠' },
  urgent: { label: 'Срочный', color: 'text-red-600', icon: '🔴' }
}

export const TASK_STATUSES: Record<TaskStatus, { label: string; color: string; icon: string }> = {
  todo: { label: 'К выполнению', color: 'text-gray-600', icon: '⚪' },
  in_progress: { label: 'В работе', color: 'text-blue-600', icon: '🔵' },
  review: { label: 'На проверке', color: 'text-purple-600', icon: '🟣' },
  done: { label: 'Выполнено', color: 'text-green-600', icon: '✅' },
  cancelled: { label: 'Отменено', color: 'text-red-600', icon: '❌' }
}


--- src/utils/dateTime.ts ---

// Utility functions for date-time manipulations

// Format a date as 'YYYY-MM-DD'
export function formatDate(date: Date): string {
  return date.toISOString().split('T')[0];
}

// Calculate difference in days between two dates
export function dateDiffInDays(a: Date, b: Date): number {
  const _MS_PER_DAY = 1000 * 60 * 60 * 24;
  // Discard time and time-zone information.
  const utc1 = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());
  const utc2 = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());
  return Math.floor((utc2 - utc1) / _MS_PER_DAY);
}

// Check if a date is today
export function isToday(date: Date): boolean {
  const today = new Date();
  return (
    date.getDate() === today.getDate() &&
    date.getMonth() === today.getMonth() &&
    date.getFullYear() === today.getFullYear()
  );
}


--- src/utils/helpers.ts ---

import { type ClassValue, clsx } from 'clsx'
import { twMerge } from 'tailwind-merge'

// Combine class names utility
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

// Generate unique ID
export function generateId(): string {
  return Math.random().toString(36).substring(2) + Date.now().toString(36)
}

// Debounce function
export function debounce<T extends (...args: any[]) => any>(
  func: T,
  delay: number
): (...args: Parameters<T>) => void {
  let timeoutId: NodeJS.Timeout
  return (...args: Parameters<T>) => {
    clearTimeout(timeoutId)
    timeoutId = setTimeout(() => func(...args), delay)
  }
}

// Throttle function
export function throttle<T extends (...args: any[]) => any>(
  func: T,
  limit: number
): (...args: Parameters<T>) => void {
  let inThrottle: boolean
  return (...args: Parameters<T>) => {
    if (!inThrottle) {
      func(...args)
      inThrottle = true
      setTimeout(() => (inThrottle = false), limit)
    }
  }
}

// Format file size
export function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 Bytes'
  const k = 1024
  const sizes = ['Bytes', 'KB', 'MB', 'GB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
}

// Format duration in seconds to human readable format
export function formatDuration(seconds: number): string {
  const hours = Math.floor(seconds / 3600)
  const minutes = Math.floor((seconds % 3600) / 60)
  const remainingSeconds = seconds % 60

  if (hours > 0) {
    return `${hours}ч ${minutes}м ${remainingSeconds}с`
  } else if (minutes > 0) {
    return `${minutes}м ${remainingSeconds}с`
  } else {
    return `${remainingSeconds}с`
  }
}

// Calculate XP required for a specific level
export function calculateXPForLevel(level: number): number {
  const baseXP = 100
  const multiplier = 1.5
  return Math.floor(baseXP * Math.pow(multiplier, level - 1))
}

// Calculate level from total XP
export function calculateLevelFromXP(totalXP: number): number {
  let level = 1
  let requiredXP = 0
  
  while (requiredXP <= totalXP) {
    level++
    requiredXP += calculateXPForLevel(level)
  }
  
  return level - 1
}

// Get XP progress for current level
export function getXPProgress(totalXP: number): { currentLevel: number; currentLevelXP: number; nextLevelXP: number; progress: number } {
  const currentLevel = calculateLevelFromXP(totalXP)
  const currentLevelStartXP = Array.from({ length: currentLevel - 1 }, (_, i) => calculateXPForLevel(i + 1)).reduce((a, b) => a + b, 0)
  const currentLevelXP = totalXP - currentLevelStartXP
  const nextLevelXP = calculateXPForLevel(currentLevel + 1)
  const progress = Math.round((currentLevelXP / nextLevelXP) * 100)

  return {
    currentLevel,
    currentLevelXP,
    nextLevelXP,
    progress
  }
}

// Capitalize first letter
export function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1)
}

// Truncate text
export function truncate(text: string, length: number): string {
  if (text.length <= length) return text
  return text.substring(0, length) + '...'
}

// Format number with thousand separators
export function formatNumber(num: number): string {
  return num.toLocaleString('ru-RU')
}

// Get random element from array
export function getRandomElement<T>(array: T[]): T {
  return array[Math.floor(Math.random() * array.length)]
}

// Sleep function for async operations
export function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms))
}


